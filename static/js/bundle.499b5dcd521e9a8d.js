/*! For license information please see bundle.499b5dcd521e9a8d.js.LICENSE.txt */
(()=>{
    "use strict";
    var t = {
        d: (e,n)=>{
            for (var i in n)
                t.o(n, i) && !t.o(e, i) && Object.defineProperty(e, i, {
                    enumerable: !0,
                    get: n[i]
                })
        }
    };
    t.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window)
                return window
        }
    }(),
    t.o = (t,e)=>Object.prototype.hasOwnProperty.call(t, e),
    t.r = t=>{
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }
    ;
    var e = {};
    function n(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function i(t, e) {
        t.prototype = Object.create(e.prototype),
        t.prototype.constructor = t,
        t.__proto__ = e
    }
    t.r(e),
    t.d(e, {
        AsyncCompress: ()=>$_,
        AsyncDecompress: ()=>mx,
        AsyncDeflate: ()=>j_,
        AsyncGunzip: ()=>ix,
        AsyncGzip: ()=>$_,
        AsyncInflate: ()=>Z_,
        AsyncUnzipInflate: ()=>Vx,
        AsyncUnzlib: ()=>ux,
        AsyncZipDeflate: ()=>Nx,
        AsyncZlib: ()=>ax,
        Compress: ()=>Q_,
        DecodeUTF8: ()=>Mx,
        Decompress: ()=>fx,
        Deflate: ()=>W_,
        EncodeUTF8: ()=>Sx,
        Gunzip: ()=>nx,
        Gzip: ()=>Q_,
        Inflate: ()=>Y_,
        Unzip: ()=>Gx,
        UnzipInflate: ()=>Hx,
        UnzipPassThrough: ()=>Ux,
        Unzlib: ()=>hx,
        Zip: ()=>zx,
        ZipDeflate: ()=>kx,
        ZipPassThrough: ()=>Ox,
        Zlib: ()=>ox,
        compress: ()=>tx,
        compressSync: ()=>ex,
        decompress: ()=>gx,
        decompressSync: ()=>vx,
        deflate: ()=>X_,
        deflateSync: ()=>q_,
        gunzip: ()=>rx,
        gunzipSync: ()=>sx,
        gzip: ()=>tx,
        gzipSync: ()=>ex,
        inflate: ()=>J_,
        inflateSync: ()=>K_,
        strFromU8: ()=>Ex,
        strToU8: ()=>Tx,
        unzip: ()=>Wx,
        unzipSync: ()=>jx,
        unzlib: ()=>dx,
        unzlibSync: ()=>px,
        zip: ()=>Bx,
        zipSync: ()=>Fx,
        zlib: ()=>lx,
        zlibSync: ()=>cx
    });
    var r, s, o, a, l, c, h, u, d, p, f, m, g = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    }, v = {
        duration: .5,
        overwrite: !1,
        delay: 0
    }, y = 1e8, _ = 1e-8, x = 2 * Math.PI, b = x / 4, w = 0, M = Math.sqrt, S = Math.cos, T = Math.sin, E = function(t) {
        return "string" == typeof t
    }, A = function(t) {
        return "function" == typeof t
    }, R = function(t) {
        return "number" == typeof t
    }, L = function(t) {
        return void 0 === t
    }, C = function(t) {
        return "object" == typeof t
    }, P = function(t) {
        return !1 !== t
    }, D = function() {
        return "undefined" != typeof window
    }, I = function(t) {
        return A(t) || E(t)
    }, O = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
    , k = Array.isArray, N = /(?:-?\.?\d|\.)+/gi, z = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, B = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, F = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, U = /[+-]=-?[.\d]+/, H = /[^,'"\[\]\s]+/gi, V = /[\d.+\-=]+(?:e[-+]\d*)*/i, G = {}, W = {}, j = function(t) {
        return (W = gt(t, G)) && rn
    }, X = function(t, e) {
        return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
    }, q = function(t, e) {
        return !e && console.warn(t)
    }, Y = function(t, e) {
        return t && (G[t] = e) && W && (W[t] = e) || G
    }, Z = function() {
        return 0
    }, J = {}, K = [], Q = {}, $ = {}, tt = {}, et = 30, nt = [], it = "", rt = function(t) {
        var e, n, i = t[0];
        if (C(i) || A(i) || (t = [t]),
        !(e = (i._gsap || {}).harness)) {
            for (n = nt.length; n-- && !nt[n].targetTest(i); )
                ;
            e = nt[n]
        }
        for (n = t.length; n--; )
            t[n] && (t[n]._gsap || (t[n]._gsap = new Ae(t[n],e))) || t.splice(n, 1);
        return t
    }, st = function(t) {
        return t._gsap || rt(Xt(t))[0]._gsap
    }, ot = function(t, e, n) {
        return (n = t[e]) && A(n) ? t[e]() : L(n) && t.getAttribute && t.getAttribute(e) || n
    }, at = function(t, e) {
        return (t = t.split(",")).forEach(e) || t
    }, lt = function(t) {
        return Math.round(1e5 * t) / 1e5 || 0
    }, ct = function(t) {
        return Math.round(1e7 * t) / 1e7 || 0
    }, ht = function(t, e) {
        for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; )
            ;
        return i < n
    }, ut = function() {
        var t, e, n = K.length, i = K.slice(0);
        for (Q = {},
        K.length = 0,
        t = 0; t < n; t++)
            (e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
    }, dt = function(t, e, n, i) {
        K.length && ut(),
        t.render(e, n, i),
        K.length && ut()
    }, pt = function(t) {
        var e = parseFloat(t);
        return (e || 0 === e) && (t + "").match(H).length < 2 ? e : E(t) ? t.trim() : t
    }, ft = function(t) {
        return t
    }, mt = function(t, e) {
        for (var n in e)
            n in t || (t[n] = e[n]);
        return t
    }, gt = function(t, e) {
        for (var n in e)
            t[n] = e[n];
        return t
    }, vt = function t(e, n) {
        for (var i in n)
            "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = C(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
        return e
    }, yt = function(t, e) {
        var n, i = {};
        for (n in t)
            n in e || (i[n] = t[n]);
        return i
    }, _t = function(t) {
        var e, n = t.parent || s, i = t.keyframes ? (e = k(t.keyframes),
        function(t, n) {
            for (var i in n)
                i in t || "duration" === i && e || "ease" === i || (t[i] = n[i])
        }
        ) : mt;
        if (P(t.inherit))
            for (; n; )
                i(t, n.vars.defaults),
                n = n.parent || n._dp;
        return t
    }, xt = function(t, e, n, i) {
        void 0 === n && (n = "_first"),
        void 0 === i && (i = "_last");
        var r = e._prev
          , s = e._next;
        r ? r._next = s : t[n] === e && (t[n] = s),
        s ? s._prev = r : t[i] === e && (t[i] = r),
        e._next = e._prev = e.parent = null
    }, bt = function(t, e) {
        t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
        t._act = 0
    }, wt = function(t, e) {
        if (t && (!e || e._end > t._dur || e._start < 0))
            for (var n = t; n; )
                n._dirty = 1,
                n = n.parent;
        return t
    }, Mt = function(t) {
        for (var e = t.parent; e && e.parent; )
            e._dirty = 1,
            e.totalDuration(),
            e = e.parent;
        return t
    }, St = function t(e) {
        return !e || e._ts && t(e.parent)
    }, Tt = function(t) {
        return t._repeat ? Et(t._tTime, t = t.duration() + t._rDelay) * t : 0
    }, Et = function(t, e) {
        var n = Math.floor(t /= e);
        return t && n === t ? n - 1 : n
    }, At = function(t, e) {
        return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    }, Rt = function(t) {
        return t._end = ct(t._start + (t._tDur / Math.abs(t._ts || t._rts || _) || 0))
    }, Lt = function(t, e) {
        var n = t._dp;
        return n && n.smoothChildTiming && t._ts && (t._start = ct(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
        Rt(t),
        n._dirty || wt(n, t)),
        t
    }, Ct = function(t, e) {
        var n;
        if ((e._time || e._initted && !e._dur) && (n = At(t.rawTime(), e),
        (!e._dur || Vt(0, e.totalDuration(), n) - e._tTime > _) && e.render(n, !0)),
        wt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
            if (t._dur < t.duration())
                for (n = t; n._dp; )
                    n.rawTime() >= 0 && n.totalTime(n._tTime),
                    n = n._dp;
            t._zTime = -1e-8
        }
    }, Pt = function(t, e, n, i) {
        return e.parent && bt(e),
        e._start = ct((R(n) ? n : n || t !== s ? Ft(t, n, e) : t._time) + e._delay),
        e._end = ct(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
        function(t, e, n, i, r) {
            void 0 === n && (n = "_first"),
            void 0 === i && (i = "_last");
            var s, o = t[i];
            if (r)
                for (s = e[r]; o && o[r] > s; )
                    o = o._prev;
            o ? (e._next = o._next,
            o._next = e) : (e._next = t[n],
            t[n] = e),
            e._next ? e._next._prev = e : t[i] = e,
            e._prev = o,
            e.parent = e._dp = t
        }(t, e, "_first", "_last", t._sort ? "_start" : 0),
        kt(e) || (t._recent = e),
        i || Ct(t, e),
        t
    }, Dt = function(t, e) {
        return (G.ScrollTrigger || X("scrollTrigger", e)) && G.ScrollTrigger.create(e, t)
    }, It = function(t, e, n, i) {
        return Oe(t, e),
        t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== fe.frame ? (K.push(t),
        t._lazy = [e, i],
        1) : void 0 : 1
    }, Ot = function t(e) {
        var n = e.parent;
        return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
    }, kt = function(t) {
        var e = t.data;
        return "isFromStart" === e || "isStart" === e
    }, Nt = function(t, e, n, i) {
        var r = t._repeat
          , s = ct(e) || 0
          , o = t._tTime / t._tDur;
        return o && !i && (t._time *= s / t._dur),
        t._dur = s,
        t._tDur = r ? r < 0 ? 1e10 : ct(s * (r + 1) + t._rDelay * r) : s,
        o > 0 && !i ? Lt(t, t._tTime = t._tDur * o) : t.parent && Rt(t),
        n || wt(t.parent, t),
        t
    }, zt = function(t) {
        return t instanceof Le ? wt(t) : Nt(t, t._dur)
    }, Bt = {
        _start: 0,
        endTime: Z,
        totalDuration: Z
    }, Ft = function t(e, n, i) {
        var r, s, o, a = e.labels, l = e._recent || Bt, c = e.duration() >= y ? l.endTime(!1) : e._dur;
        return E(n) && (isNaN(n) || n in a) ? (s = n.charAt(0),
        o = "%" === n.substr(-1),
        r = n.indexOf("="),
        "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")),
        ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = c),
        a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)),
        o && i && (s = s / 100 * (k(i) ? i[0] : i).totalDuration()),
        r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n
    }, Ut = function(t, e, n) {
        var i, r, s = R(e[1]), o = (s ? 2 : 1) + (t < 2 ? 0 : 1), a = e[o];
        if (s && (a.duration = e[1]),
        a.parent = n,
        t) {
            for (i = a,
            r = n; r && !("immediateRender"in i); )
                i = r.vars.defaults || {},
                r = P(r.vars.inherit) && r.parent;
            a.immediateRender = P(i.immediateRender),
            t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1]
        }
        return new Fe(e[0],a,e[o + 1])
    }, Ht = function(t, e) {
        return t || 0 === t ? e(t) : e
    }, Vt = function(t, e, n) {
        return n < t ? t : n > e ? e : n
    }, Gt = function(t, e) {
        return E(t) && (e = V.exec(t)) ? t.substr(e.index + e[0].length) : ""
    }, Wt = [].slice, jt = function(t, e) {
        return t && C(t) && "length"in t && (!e && !t.length || t.length - 1 in t && C(t[0])) && !t.nodeType && t !== o
    }, Xt = function(t, e, n) {
        return !E(t) || n || !a && me() ? k(t) ? function(t, e, n) {
            return void 0 === n && (n = []),
            t.forEach((function(t) {
                var i;
                return E(t) && !e || jt(t, 1) ? (i = n).push.apply(i, Xt(t)) : n.push(t)
            }
            )) || n
        }(t, n) : jt(t) ? Wt.call(t, 0) : t ? [t] : [] : Wt.call((e || l).querySelectorAll(t), 0)
    }, qt = function(t) {
        return t.sort((function() {
            return .5 - Math.random()
        }
        ))
    }, Yt = function(t) {
        if (A(t))
            return t;
        var e = C(t) ? t : {
            each: t
        }
          , n = we(e.ease)
          , i = e.from || 0
          , r = parseFloat(e.base) || 0
          , s = {}
          , o = i > 0 && i < 1
          , a = isNaN(i) || o
          , l = e.axis
          , c = i
          , h = i;
        return E(i) ? c = h = {
            center: .5,
            edges: .5,
            end: 1
        }[i] || 0 : !o && a && (c = i[0],
        h = i[1]),
        function(t, o, u) {
            var d, p, f, m, g, v, _, x, b, w = (u || e).length, S = s[w];
            if (!S) {
                if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, y])[1])) {
                    for (_ = -y; _ < (_ = u[b++].getBoundingClientRect().left) && b < w; )
                        ;
                    b--
                }
                for (S = s[w] = [],
                d = a ? Math.min(b, w) * c - .5 : i % b,
                p = b === y ? 0 : a ? w * h / b - .5 : i / b | 0,
                _ = 0,
                x = y,
                v = 0; v < w; v++)
                    f = v % b - d,
                    m = p - (v / b | 0),
                    S[v] = g = l ? Math.abs("y" === l ? m : f) : M(f * f + m * m),
                    g > _ && (_ = g),
                    g < x && (x = g);
                "random" === i && qt(S),
                S.max = _ - x,
                S.min = x,
                S.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (b > w ? w - 1 : l ? "y" === l ? w / b : b : Math.max(b, w / b)) || 0) * ("edges" === i ? -1 : 1),
                S.b = w < 0 ? r - w : r,
                S.u = Gt(e.amount || e.each) || 0,
                n = n && w < 0 ? xe(n) : n
            }
            return w = (S[t] - S.min) / S.max || 0,
            ct(S.b + (n ? n(w) : w) * S.v) + S.u
        }
    }, Zt = function(t) {
        var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
        return function(n) {
            var i = Math.round(parseFloat(n) / t) * t * e;
            return (i - i % 1) / e + (R(n) ? 0 : Gt(n))
        }
    }, Jt = function(t, e) {
        var n, i, r = k(t);
        return !r && C(t) && (n = r = t.radius || y,
        t.values ? (t = Xt(t.values),
        (i = !R(t[0])) && (n *= n)) : t = Zt(t.increment)),
        Ht(e, r ? A(t) ? function(e) {
            return i = t(e),
            Math.abs(i - e) <= n ? i : e
        }
        : function(e) {
            for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = y, c = 0, h = t.length; h--; )
                (r = i ? (r = t[h].x - o) * r + (s = t[h].y - a) * s : Math.abs(t[h] - o)) < l && (l = r,
                c = h);
            return c = !n || l <= n ? t[c] : e,
            i || c === e || R(e) ? c : c + Gt(e)
        }
        : Zt(t))
    }, Kt = function(t, e, n, i) {
        return Ht(k(t) ? !e : !0 === n ? !!(n = 0) : !i, (function() {
            return k(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
        }
        ))
    }, Qt = function(t, e, n) {
        return Ht(n, (function(n) {
            return t[~~e(n)]
        }
        ))
    }, $t = function(t) {
        for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s)); )
            i = t.indexOf(")", e),
            r = "[" === t.charAt(e + 7),
            n = t.substr(e + 7, i - e - 7).match(r ? H : N),
            o += t.substr(s, e - s) + Kt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5),
            s = i + 1;
        return o + t.substr(s, t.length - s)
    }, te = function(t, e, n, i, r) {
        var s = e - t
          , o = i - n;
        return Ht(r, (function(e) {
            return n + ((e - t) / s * o || 0)
        }
        ))
    }, ee = function(t, e, n) {
        var i, r, s, o = t.labels, a = y;
        for (i in o)
            (r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i,
            a = r);
        return s
    }, ne = function(t, e, n) {
        var i, r, s = t.vars, o = s[e];
        if (o)
            return i = s[e + "Params"],
            r = s.callbackScope || t,
            n && K.length && ut(),
            i ? o.apply(r, i) : o.call(r)
    }, ie = function(t) {
        return bt(t),
        t.scrollTrigger && t.scrollTrigger.kill(!1),
        t.progress() < 1 && ne(t, "onInterrupt"),
        t
    }, re = function(t) {
        var e = (t = !t.name && t.default || t).name
          , n = A(t)
          , i = e && !n && t.init ? function() {
            this._props = []
        }
        : t
          , r = {
            init: Z,
            render: Ye,
            add: De,
            kill: Je,
            modifier: Ze,
            rawVars: 0
        }
          , s = {
            targetTest: 0,
            get: 0,
            getSetter: We,
            aliases: {},
            register: 0
        };
        if (me(),
        t !== i) {
            if ($[e])
                return;
            mt(i, mt(yt(t, r), s)),
            gt(i.prototype, gt(r, yt(t, s))),
            $[i.prop = e] = i,
            t.targetTest && (nt.push(i),
            J[e] = 1),
            e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
        }
        Y(e, i),
        t.register && t.register(rn, i, $e)
    }, se = 255, oe = {
        aqua: [0, se, se],
        lime: [0, se, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, se],
        navy: [0, 0, 128],
        white: [se, se, se],
        olive: [128, 128, 0],
        yellow: [se, se, 0],
        orange: [se, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [se, 0, 0],
        pink: [se, 192, 203],
        cyan: [0, se, se],
        transparent: [se, se, se, 0]
    }, ae = function(t, e, n) {
        return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * se + .5 | 0
    }, le = function(t, e, n) {
        var i, r, s, o, a, l, c, h, u, d, p = t ? R(t) ? [t >> 16, t >> 8 & se, t & se] : 0 : oe.black;
        if (!p) {
            if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
            oe[t])
                p = oe[t];
            else if ("#" === t.charAt(0)) {
                if (t.length < 6 && (i = t.charAt(1),
                r = t.charAt(2),
                s = t.charAt(3),
                t = "#" + i + i + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")),
                9 === t.length)
                    return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & se, p & se, parseInt(t.substr(7), 16) / 255];
                p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & se, t & se]
            } else if ("hsl" === t.substr(0, 3))
                if (p = d = t.match(N),
                e) {
                    if (~t.indexOf("="))
                        return p = t.match(z),
                        n && p.length < 4 && (p[3] = 1),
                        p
                } else
                    o = +p[0] % 360 / 360,
                    a = +p[1] / 100,
                    i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a),
                    p.length > 3 && (p[3] *= 1),
                    p[0] = ae(o + 1 / 3, i, r),
                    p[1] = ae(o, i, r),
                    p[2] = ae(o - 1 / 3, i, r);
            else
                p = t.match(N) || oe.transparent;
            p = p.map(Number)
        }
        return e && !d && (i = p[0] / se,
        r = p[1] / se,
        s = p[2] / se,
        l = ((c = Math.max(i, r, s)) + (h = Math.min(i, r, s))) / 2,
        c === h ? o = a = 0 : (u = c - h,
        a = l > .5 ? u / (2 - c - h) : u / (c + h),
        o = c === i ? (r - s) / u + (r < s ? 6 : 0) : c === r ? (s - i) / u + 2 : (i - r) / u + 4,
        o *= 60),
        p[0] = ~~(o + .5),
        p[1] = ~~(100 * a + .5),
        p[2] = ~~(100 * l + .5)),
        n && p.length < 4 && (p[3] = 1),
        p
    }, ce = function(t) {
        var e = []
          , n = []
          , i = -1;
        return t.split(ue).forEach((function(t) {
            var r = t.match(B) || [];
            e.push.apply(e, r),
            n.push(i += r.length + 1)
        }
        )),
        e.c = n,
        e
    }, he = function(t, e, n) {
        var i, r, s, o, a = "", l = (t + a).match(ue), c = e ? "hsla(" : "rgba(", h = 0;
        if (!l)
            return t;
        if (l = l.map((function(t) {
            return (t = le(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
        }
        )),
        n && (s = ce(t),
        (i = n.c).join(a) !== s.c.join(a)))
            for (o = (r = t.replace(ue, "1").split(B)).length - 1; h < o; h++)
                a += r[h] + (~i.indexOf(h) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
        if (!r)
            for (o = (r = t.split(ue)).length - 1; h < o; h++)
                a += r[h] + l[h];
        return a + r[o]
    }, ue = function() {
        var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
        for (t in oe)
            e += "|" + t + "\\b";
        return new RegExp(e + ")","gi")
    }(), de = /hsl[a]?\(/, pe = function(t) {
        var e, n = t.join(" ");
        if (ue.lastIndex = 0,
        ue.test(n))
            return e = de.test(n),
            t[1] = he(t[1], e),
            t[0] = he(t[0], e, ce(t[1])),
            !0
    }, fe = function() {
        var t, e, n, i, r, s, h = Date.now, u = 500, p = 33, f = h(), m = f, g = 1e3 / 240, v = g, y = [], _ = function n(o) {
            var a, l, c, d, _ = h() - m, x = !0 === o;
            if (_ > u && (f += _ - p),
            ((a = (c = (m += _) - f) - v) > 0 || x) && (d = ++i.frame,
            r = c - 1e3 * i.time,
            i.time = c /= 1e3,
            v += a + (a >= g ? 4 : g - a),
            l = 1),
            x || (t = e(n)),
            l)
                for (s = 0; s < y.length; s++)
                    y[s](c, r, d, o)
        };
        return i = {
            time: 0,
            frame: 0,
            tick: function() {
                _(!0)
            },
            deltaRatio: function(t) {
                return r / (1e3 / (t || 60))
            },
            wake: function() {
                c && (!a && D() && (o = a = window,
                l = o.document || {},
                G.gsap = rn,
                (o.gsapVersions || (o.gsapVersions = [])).push(rn.version),
                j(W || o.GreenSockGlobals || !o.gsap && o || {}),
                n = o.requestAnimationFrame),
                t && i.sleep(),
                e = n || function(t) {
                    return setTimeout(t, v - 1e3 * i.time + 1 | 0)
                }
                ,
                d = 1,
                _(2))
            },
            sleep: function() {
                (n ? o.cancelAnimationFrame : clearTimeout)(t),
                d = 0,
                e = Z
            },
            lagSmoothing: function(t, e) {
                u = t || 1e8,
                p = Math.min(e, u, 0)
            },
            fps: function(t) {
                g = 1e3 / (t || 240),
                v = 1e3 * i.time + g
            },
            add: function(t) {
                y.indexOf(t) < 0 && y.push(t),
                me()
            },
            remove: function(t, e) {
                ~(e = y.indexOf(t)) && y.splice(e, 1) && s >= e && s--
            },
            _listeners: y
        },
        i
    }(), me = function() {
        return !d && fe.wake()
    }, ge = {}, ve = /^[\d.\-M][\d.\-,\s]/, ye = /["']/g, _e = function(t) {
        for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++)
            n = s[a],
            e = a !== l - 1 ? n.lastIndexOf(",") : n.length,
            i = n.substr(0, e),
            r[o] = isNaN(i) ? i.replace(ye, "").trim() : +i,
            o = n.substr(e + 1).trim();
        return r
    }, xe = function(t) {
        return function(e) {
            return 1 - t(1 - e)
        }
    }, be = function t(e, n) {
        for (var i, r = e._first; r; )
            r instanceof Le ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease,
            r._ease = r._yEase,
            r._yEase = i,
            r._yoyo = n)),
            r = r._next
    }, we = function(t, e) {
        return t && (A(t) ? t : ge[t] || function(t) {
            var e, n, i, r, s = (t + "").split("("), o = ge[s[0]];
            return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [_e(s[1])] : (e = t,
            n = e.indexOf("(") + 1,
            i = e.indexOf(")"),
            r = e.indexOf("(", n),
            e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(pt)) : ge._CE && ve.test(t) ? ge._CE("", t) : o
        }(t)) || e
    }, Me = function(t, e, n, i) {
        void 0 === n && (n = function(t) {
            return 1 - e(1 - t)
        }
        ),
        void 0 === i && (i = function(t) {
            return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
        }
        );
        var r, s = {
            easeIn: e,
            easeOut: n,
            easeInOut: i
        };
        return at(t, (function(t) {
            for (var e in ge[t] = G[t] = s,
            ge[r = t.toLowerCase()] = n,
            s)
                ge[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = ge[t + "." + e] = s[e]
        }
        )),
        s
    }, Se = function(t) {
        return function(e) {
            return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
        }
    }, Te = function t(e, n, i) {
        var r = n >= 1 ? n : 1
          , s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1)
          , o = s / x * (Math.asin(1 / r) || 0)
          , a = function(t) {
            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * T((t - o) * s) + 1
        }
          , l = "out" === e ? a : "in" === e ? function(t) {
            return 1 - a(1 - t)
        }
        : Se(a);
        return s = x / s,
        l.config = function(n, i) {
            return t(e, n, i)
        }
        ,
        l
    }, Ee = function t(e, n) {
        void 0 === n && (n = 1.70158);
        var i = function(t) {
            return t ? --t * t * ((n + 1) * t + n) + 1 : 0
        }
          , r = "out" === e ? i : "in" === e ? function(t) {
            return 1 - i(1 - t)
        }
        : Se(i);
        return r.config = function(n) {
            return t(e, n)
        }
        ,
        r
    };
    at("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
        var n = e < 5 ? e + 1 : e;
        Me(t + ",Power" + (n - 1), e ? function(t) {
            return Math.pow(t, n)
        }
        : function(t) {
            return t
        }
        , (function(t) {
            return 1 - Math.pow(1 - t, n)
        }
        ), (function(t) {
            return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
        }
        ))
    }
    )),
    ge.Linear.easeNone = ge.none = ge.Linear.easeIn,
    Me("Elastic", Te("in"), Te("out"), Te()),
    p = 7.5625,
    f = 2.75,
    Me("Bounce", (function(t) {
        return 1 - m(1 - t)
    }
    ), m = function(t) {
        return t < .36363636363636365 ? p * t * t : t < .7272727272727273 ? p * Math.pow(t - 1.5 / f, 2) + .75 : t < .9090909090909092 ? p * (t -= 2.25 / f) * t + .9375 : p * Math.pow(t - 2.625 / f, 2) + .984375
    }
    ),
    Me("Expo", (function(t) {
        return t ? Math.pow(2, 10 * (t - 1)) : 0
    }
    )),
    Me("Circ", (function(t) {
        return -(M(1 - t * t) - 1)
    }
    )),
    Me("Sine", (function(t) {
        return 1 === t ? 1 : 1 - S(t * b)
    }
    )),
    Me("Back", Ee("in"), Ee("out"), Ee()),
    ge.SteppedEase = ge.steps = G.SteppedEase = {
        config: function(t, e) {
            void 0 === t && (t = 1);
            var n = 1 / t
              , i = t + (e ? 0 : 1)
              , r = e ? 1 : 0;
            return function(t) {
                return ((i * Vt(0, .99999999, t) | 0) + r) * n
            }
        }
    },
    v.ease = ge["quad.out"],
    at("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
        return it += t + "," + t + "Params,"
    }
    ));
    var Ae = function(t, e) {
        this.id = w++,
        t._gsap = this,
        this.target = t,
        this.harness = e,
        this.get = e ? e.get : ot,
        this.set = e ? e.getSetter : We
    }
      , Re = function() {
        function t(t) {
            this.vars = t,
            this._delay = +t.delay || 0,
            (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
            this._yoyo = !!t.yoyo || !!t.yoyoEase),
            this._ts = 1,
            Nt(this, +t.duration, 1, 1),
            this.data = t.data,
            d || fe.wake()
        }
        var e = t.prototype;
        return e.delay = function(t) {
            return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
            this._delay = t,
            this) : this._delay
        }
        ,
        e.duration = function(t) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
        }
        ,
        e.totalDuration = function(t) {
            return arguments.length ? (this._dirty = 0,
            Nt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }
        ,
        e.totalTime = function(t, e) {
            if (me(),
            !arguments.length)
                return this._tTime;
            var n = this._dp;
            if (n && n.smoothChildTiming && this._ts) {
                for (Lt(this, t),
                !n._dp || n.parent || Ct(n, this); n && n.parent; )
                    n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                    n = n.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Pt(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === _ || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t),
            dt(this, t, e)),
            this
        }
        ,
        e.time = function(t, e) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Tt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
        }
        ,
        e.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }
        ,
        e.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Tt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }
        ,
        e.iteration = function(t, e) {
            var n = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Et(this._tTime, n) + 1 : 1
        }
        ,
        e.timeScale = function(t) {
            if (!arguments.length)
                return -1e-8 === this._rts ? 0 : this._rts;
            if (this._rts === t)
                return this;
            var e = this.parent && this._ts ? At(this.parent._time, this) : this._tTime;
            return this._rts = +t || 0,
            this._ts = this._ps || -1e-8 === t ? 0 : this._rts,
            Mt(this.totalTime(Vt(-this._delay, this._tDur, e), !0)),
            Rt(this),
            this
        }
        ,
        e.paused = function(t) {
            return arguments.length ? (this._ps !== t && (this._ps = t,
            t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
            this._ts = this._act = 0) : (me(),
            this._ts = this._rts,
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== _ && (this._tTime -= _)))),
            this) : this._ps
        }
        ,
        e.startTime = function(t) {
            if (arguments.length) {
                this._start = t;
                var e = this.parent || this._dp;
                return e && (e._sort || !this.parent) && Pt(e, this, t - this._delay),
                this
            }
            return this._start
        }
        ,
        e.endTime = function(t) {
            return this._start + (P(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }
        ,
        e.rawTime = function(t) {
            var e = this.parent || this._dp;
            return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? At(e.rawTime(t), this) : this._tTime : this._tTime
        }
        ,
        e.globalTime = function(t) {
            for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
                n = e._start + n / (e._ts || 1),
                e = e._dp;
            return n
        }
        ,
        e.repeat = function(t) {
            return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t,
            zt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
        }
        ,
        e.repeatDelay = function(t) {
            if (arguments.length) {
                var e = this._time;
                return this._rDelay = t,
                zt(this),
                e ? this.time(e) : this
            }
            return this._rDelay
        }
        ,
        e.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t,
            this) : this._yoyo
        }
        ,
        e.seek = function(t, e) {
            return this.totalTime(Ft(this, t), P(e))
        }
        ,
        e.restart = function(t, e) {
            return this.play().totalTime(t ? -this._delay : 0, P(e))
        }
        ,
        e.play = function(t, e) {
            return null != t && this.seek(t, e),
            this.reversed(!1).paused(!1)
        }
        ,
        e.reverse = function(t, e) {
            return null != t && this.seek(t || this.totalDuration(), e),
            this.reversed(!0).paused(!1)
        }
        ,
        e.pause = function(t, e) {
            return null != t && this.seek(t, e),
            this.paused(!0)
        }
        ,
        e.resume = function() {
            return this.paused(!1)
        }
        ,
        e.reversed = function(t) {
            return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)),
            this) : this._rts < 0
        }
        ,
        e.invalidate = function() {
            return this._initted = this._act = 0,
            this._zTime = -1e-8,
            this
        }
        ,
        e.isActive = function() {
            var t, e = this.parent || this._dp, n = this._start;
            return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - _))
        }
        ,
        e.eventCallback = function(t, e, n) {
            var i = this.vars;
            return arguments.length > 1 ? (e ? (i[t] = e,
            n && (i[t + "Params"] = n),
            "onUpdate" === t && (this._onUpdate = e)) : delete i[t],
            this) : i[t]
        }
        ,
        e.then = function(t) {
            var e = this;
            return new Promise((function(n) {
                var i = A(t) ? t : ft
                  , r = function() {
                    var t = e.then;
                    e.then = null,
                    A(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                    n(i),
                    e.then = t
                };
                e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
            }
            ))
        }
        ,
        e.kill = function() {
            ie(this)
        }
        ,
        t
    }();
    mt(Re.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Le = function(t) {
        function e(e, i) {
            var r;
            return void 0 === e && (e = {}),
            (r = t.call(this, e) || this).labels = {},
            r.smoothChildTiming = !!e.smoothChildTiming,
            r.autoRemoveChildren = !!e.autoRemoveChildren,
            r._sort = P(e.sortChildren),
            s && Pt(e.parent || s, n(r), i),
            e.reversed && r.reverse(),
            e.paused && r.paused(!0),
            e.scrollTrigger && Dt(n(r), e.scrollTrigger),
            r
        }
        i(e, t);
        var r = e.prototype;
        return r.to = function(t, e, n) {
            return Ut(0, arguments, this),
            this
        }
        ,
        r.from = function(t, e, n) {
            return Ut(1, arguments, this),
            this
        }
        ,
        r.fromTo = function(t, e, n, i) {
            return Ut(2, arguments, this),
            this
        }
        ,
        r.set = function(t, e, n) {
            return e.duration = 0,
            e.parent = this,
            _t(e).repeatDelay || (e.repeat = 0),
            e.immediateRender = !!e.immediateRender,
            new Fe(t,e,Ft(this, n),1),
            this
        }
        ,
        r.call = function(t, e, n) {
            return Pt(this, Fe.delayedCall(0, t, e), n)
        }
        ,
        r.staggerTo = function(t, e, n, i, r, s, o) {
            return n.duration = e,
            n.stagger = n.stagger || i,
            n.onComplete = s,
            n.onCompleteParams = o,
            n.parent = this,
            new Fe(t,n,Ft(this, r)),
            this
        }
        ,
        r.staggerFrom = function(t, e, n, i, r, s, o) {
            return n.runBackwards = 1,
            _t(n).immediateRender = P(n.immediateRender),
            this.staggerTo(t, e, n, i, r, s, o)
        }
        ,
        r.staggerFromTo = function(t, e, n, i, r, s, o, a) {
            return i.startAt = n,
            _t(i).immediateRender = P(i.immediateRender),
            this.staggerTo(t, e, i, r, s, o, a)
        }
        ,
        r.render = function(t, e, n) {
            var i, r, o, a, l, c, h, u, d, p, f, m, g = this._time, v = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = t <= 0 ? 0 : ct(t), b = this._zTime < 0 != t < 0 && (this._initted || !y);
            if (this !== s && x > v && t >= 0 && (x = v),
            x !== this._tTime || n || b) {
                if (g !== this._time && y && (x += this._time - g,
                t += this._time - g),
                i = x,
                d = this._start,
                c = !(u = this._ts),
                b && (y || (g = this._zTime),
                (t || !e) && (this._zTime = t)),
                this._repeat) {
                    if (f = this._yoyo,
                    l = y + this._rDelay,
                    this._repeat < -1 && t < 0)
                        return this.totalTime(100 * l + t, e, n);
                    if (i = ct(x % l),
                    x === v ? (a = this._repeat,
                    i = y) : ((a = ~~(x / l)) && a === x / l && (i = y,
                    a--),
                    i > y && (i = y)),
                    p = Et(this._tTime, l),
                    !g && this._tTime && p !== a && (p = a),
                    f && 1 & a && (i = y - i,
                    m = 1),
                    a !== p && !this._lock) {
                        var w = f && 1 & p
                          , M = w === (f && 1 & a);
                        if (a < p && (w = !w),
                        g = w ? 0 : y,
                        this._lock = 1,
                        this.render(g || (m ? 0 : ct(a * l)), e, !y)._lock = 0,
                        this._tTime = x,
                        !e && this.parent && ne(this, "onRepeat"),
                        this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1),
                        g && g !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                            return this;
                        if (y = this._dur,
                        v = this._tDur,
                        M && (this._lock = 2,
                        g = w ? y : -1e-4,
                        this.render(g, !0),
                        this.vars.repeatRefresh && !m && this.invalidate()),
                        this._lock = 0,
                        !this._ts && !c)
                            return this;
                        be(this, m)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(t, e, n) {
                    var i;
                    if (n > e)
                        for (i = t._first; i && i._start <= n; ) {
                            if ("isPause" === i.data && i._start > e)
                                return i;
                            i = i._next
                        }
                    else
                        for (i = t._last; i && i._start >= n; ) {
                            if ("isPause" === i.data && i._start < e)
                                return i;
                            i = i._prev
                        }
                }(this, ct(g), ct(i)),
                h && (x -= i - (i = h._start))),
                this._tTime = x,
                this._time = i,
                this._act = !u,
                this._initted || (this._onUpdate = this.vars.onUpdate,
                this._initted = 1,
                this._zTime = t,
                g = 0),
                !g && i && !e && (ne(this, "onStart"),
                this._tTime !== x))
                    return this;
                if (i >= g && t >= 0)
                    for (r = this._first; r; ) {
                        if (o = r._next,
                        (r._act || i >= r._start) && r._ts && h !== r) {
                            if (r.parent !== this)
                                return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n),
                            i !== this._time || !this._ts && !c) {
                                h = 0,
                                o && (x += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = o
                    }
                else {
                    r = this._last;
                    for (var S = t < 0 ? t : i; r; ) {
                        if (o = r._prev,
                        (r._act || S <= r._end) && r._ts && h !== r) {
                            if (r.parent !== this)
                                return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (S - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (S - r._start) * r._ts, e, n),
                            i !== this._time || !this._ts && !c) {
                                h = 0,
                                o && (x += this._zTime = S ? -1e-8 : _);
                                break
                            }
                        }
                        r = o
                    }
                }
                if (h && !e && (this.pause(),
                h.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1,
                this._ts))
                    return this._start = d,
                    Rt(this),
                    this.render(t, e, n);
                this._onUpdate && !e && ne(this, "onUpdate", !0),
                (x === v && v >= this.totalDuration() || !x && g) && (d !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !y) && (x === v && this._ts > 0 || !x && this._ts < 0) && bt(this, 1),
                e || t < 0 && !g || !x && !g && v || (ne(this, x === v && t >= 0 ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(x < v && this.timeScale() > 0) && this._prom())))
            }
            return this
        }
        ,
        r.add = function(t, e) {
            var n = this;
            if (R(e) || (e = Ft(this, e, t)),
            !(t instanceof Re)) {
                if (k(t))
                    return t.forEach((function(t) {
                        return n.add(t, e)
                    }
                    )),
                    this;
                if (E(t))
                    return this.addLabel(t, e);
                if (!A(t))
                    return this;
                t = Fe.delayedCall(0, t)
            }
            return this !== t ? Pt(this, t, e) : this
        }
        ,
        r.getChildren = function(t, e, n, i) {
            void 0 === t && (t = !0),
            void 0 === e && (e = !0),
            void 0 === n && (n = !0),
            void 0 === i && (i = -y);
            for (var r = [], s = this._first; s; )
                s._start >= i && (s instanceof Fe ? e && r.push(s) : (n && r.push(s),
                t && r.push.apply(r, s.getChildren(!0, e, n)))),
                s = s._next;
            return r
        }
        ,
        r.getById = function(t) {
            for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
                if (e[n].vars.id === t)
                    return e[n]
        }
        ,
        r.remove = function(t) {
            return E(t) ? this.removeLabel(t) : A(t) ? this.killTweensOf(t) : (xt(this, t),
            t === this._recent && (this._recent = this._last),
            wt(this))
        }
        ,
        r.totalTime = function(e, n) {
            return arguments.length ? (this._forcing = 1,
            !this._dp && this._ts && (this._start = ct(fe.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))),
            t.prototype.totalTime.call(this, e, n),
            this._forcing = 0,
            this) : this._tTime
        }
        ,
        r.addLabel = function(t, e) {
            return this.labels[t] = Ft(this, e),
            this
        }
        ,
        r.removeLabel = function(t) {
            return delete this.labels[t],
            this
        }
        ,
        r.addPause = function(t, e, n) {
            var i = Fe.delayedCall(0, e || Z, n);
            return i.data = "isPause",
            this._hasPause = 1,
            Pt(this, i, Ft(this, t))
        }
        ,
        r.removePause = function(t) {
            var e = this._first;
            for (t = Ft(this, t); e; )
                e._start === t && "isPause" === e.data && bt(e),
                e = e._next
        }
        ,
        r.killTweensOf = function(t, e, n) {
            for (var i = this.getTweensOf(t, n), r = i.length; r--; )
                Ce !== i[r] && i[r].kill(t, e);
            return this
        }
        ,
        r.getTweensOf = function(t, e) {
            for (var n, i = [], r = Xt(t), s = this._first, o = R(e); s; )
                s instanceof Fe ? ht(s._targets, r) && (o ? (!Ce || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
                s = s._next;
            return i
        }
        ,
        r.tweenTo = function(t, e) {
            e = e || {};
            var n, i = this, r = Ft(i, t), s = e, o = s.startAt, a = s.onStart, l = s.onStartParams, c = s.immediateRender, h = Fe.to(i, mt({
                ease: e.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: r,
                overwrite: "auto",
                duration: e.duration || Math.abs((r - (o && "time"in o ? o.time : i._time)) / i.timeScale()) || _,
                onStart: function() {
                    if (i.pause(),
                    !n) {
                        var t = e.duration || Math.abs((r - (o && "time"in o ? o.time : i._time)) / i.timeScale());
                        h._dur !== t && Nt(h, t, 0, 1).render(h._time, !0, !0),
                        n = 1
                    }
                    a && a.apply(h, l || [])
                }
            }, e));
            return c ? h.render(0) : h
        }
        ,
        r.tweenFromTo = function(t, e, n) {
            return this.tweenTo(e, mt({
                startAt: {
                    time: Ft(this, t)
                }
            }, n))
        }
        ,
        r.recent = function() {
            return this._recent
        }
        ,
        r.nextLabel = function(t) {
            return void 0 === t && (t = this._time),
            ee(this, Ft(this, t))
        }
        ,
        r.previousLabel = function(t) {
            return void 0 === t && (t = this._time),
            ee(this, Ft(this, t), 1)
        }
        ,
        r.currentLabel = function(t) {
            return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + _)
        }
        ,
        r.shiftChildren = function(t, e, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, s = this.labels; r; )
                r._start >= n && (r._start += t,
                r._end += t),
                r = r._next;
            if (e)
                for (i in s)
                    s[i] >= n && (s[i] += t);
            return wt(this)
        }
        ,
        r.invalidate = function() {
            var e = this._first;
            for (this._lock = 0; e; )
                e.invalidate(),
                e = e._next;
            return t.prototype.invalidate.call(this)
        }
        ,
        r.clear = function(t) {
            void 0 === t && (t = !0);
            for (var e, n = this._first; n; )
                e = n._next,
                this.remove(n),
                n = e;
            return this._dp && (this._time = this._tTime = this._pTime = 0),
            t && (this.labels = {}),
            wt(this)
        }
        ,
        r.totalDuration = function(t) {
            var e, n, i, r = 0, o = this, a = o._last, l = y;
            if (arguments.length)
                return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
            if (o._dirty) {
                for (i = o.parent; a; )
                    e = a._prev,
                    a._dirty && a.totalDuration(),
                    (n = a._start) > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                    Pt(o, a, n - a._delay, 1)._lock = 0) : l = n,
                    n < 0 && a._ts && (r -= n,
                    (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts,
                    o._time -= n,
                    o._tTime -= n),
                    o.shiftChildren(-n, !1, -Infinity),
                    l = 0),
                    a._end > r && a._ts && (r = a._end),
                    a = e;
                Nt(o, o === s && o._time > r ? o._time : r, 1, 1),
                o._dirty = 0
            }
            return o._tDur
        }
        ,
        e.updateRoot = function(t) {
            if (s._ts && (dt(s, At(t, s)),
            h = fe.frame),
            fe.frame >= et) {
                et += g.autoSleep || 120;
                var e = s._first;
                if ((!e || !e._ts) && g.autoSleep && fe._listeners.length < 2) {
                    for (; e && !e._ts; )
                        e = e._next;
                    e || fe.sleep()
                }
            }
        }
        ,
        e
    }(Re);
    mt(Le.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var Ce, Pe = function(t, e, n, i, r, s, o) {
        var a, l, c, h, u, d, p, f, m = new $e(this._pt,t,e,0,1,qe,null,r), g = 0, v = 0;
        for (m.b = n,
        m.e = i,
        n += "",
        (p = ~(i += "").indexOf("random(")) && (i = $t(i)),
        s && (s(f = [n, i], t, e),
        n = f[0],
        i = f[1]),
        l = n.match(F) || []; a = F.exec(i); )
            h = a[0],
            u = i.substring(g, a.index),
            c ? c = (c + 1) % 5 : "rgba(" === u.substr(-5) && (c = 1),
            h !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
            m._pt = {
                _next: m._pt,
                p: u || 1 === v ? u : ",",
                s: d,
                c: "=" === h.charAt(1) ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1) : parseFloat(h) - d,
                m: c && c < 4 ? Math.round : 0
            },
            g = F.lastIndex);
        return m.c = g < i.length ? i.substring(g, i.length) : "",
        m.fp = o,
        (U.test(i) || p) && (m.e = 0),
        this._pt = m,
        m
    }, De = function(t, e, n, i, r, s, o, a, l) {
        A(i) && (i = i(r || 0, t, s));
        var c, h = t[e], u = "get" !== n ? n : A(h) ? l ? t[e.indexOf("set") || !A(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : h, d = A(h) ? l ? Ve : He : Ue;
        if (E(i) && (~i.indexOf("random(") && (i = $t(i)),
        "=" === i.charAt(1) && ((c = parseFloat(u) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Gt(u) || 0)) || 0 === c) && (i = c)),
        u !== i)
            return isNaN(u * i) || "" === i ? (!h && !(e in t) && X(e, i),
            Pe.call(this, t, e, u, i, d, a || g.stringFilter, l)) : (c = new $e(this._pt,t,e,+u || 0,i - (u || 0),"boolean" == typeof h ? Xe : je,0,d),
            l && (c.fp = l),
            o && c.modifier(o, this, t),
            this._pt = c)
    }, Ie = function(t, e, n, i, r, s) {
        var o, a, l, c;
        if ($[t] && !1 !== (o = new $[t]).init(r, o.rawVars ? e[t] : function(t, e, n, i, r) {
            if (A(t) && (t = Ne(t, r, e, n, i)),
            !C(t) || t.style && t.nodeType || k(t) || O(t))
                return E(t) ? Ne(t, r, e, n, i) : t;
            var s, o = {};
            for (s in t)
                o[s] = Ne(t[s], r, e, n, i);
            return o
        }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new $e(n._pt,r,t,0,1,o.render,o,0,o.priority),
        n !== u))
            for (l = n._ptLookup[n._targets.indexOf(r)],
            c = o._props.length; c--; )
                l[o._props[c]] = a;
        return o
    }, Oe = function t(e, n) {
        var i, o, a, l, c, h, u, d, p, f, m, g, x, b = e.vars, w = b.ease, M = b.startAt, S = b.immediateRender, T = b.lazy, E = b.onUpdate, A = b.onUpdateParams, R = b.callbackScope, L = b.runBackwards, C = b.yoyoEase, D = b.keyframes, I = b.autoRevert, O = e._dur, k = e._startAt, N = e._targets, z = e.parent, B = z && "nested" === z.data ? z.parent._targets : N, F = "auto" === e._overwrite && !r, U = e.timeline;
        if (U && (!D || !w) && (w = "none"),
        e._ease = we(w, v.ease),
        e._yEase = C ? xe(we(!0 === C ? w : C, v.ease)) : 0,
        C && e._yoyo && !e._repeat && (C = e._yEase,
        e._yEase = e._ease,
        e._ease = C),
        e._from = !U && !!b.runBackwards,
        !U || D && !b.stagger) {
            if (g = (d = N[0] ? st(N[0]).harness : 0) && b[d.prop],
            i = yt(b, J),
            k && bt(k.render(-1, !0)),
            M)
                if (bt(e._startAt = Fe.set(N, mt({
                    data: "isStart",
                    overwrite: !1,
                    parent: z,
                    immediateRender: !0,
                    lazy: P(T),
                    startAt: null,
                    delay: 0,
                    onUpdate: E,
                    onUpdateParams: A,
                    callbackScope: R,
                    stagger: 0
                }, M))),
                n < 0 && !S && !I && e._startAt.render(-1, !0),
                S) {
                    if (n > 0 && !I && (e._startAt = 0),
                    O && n <= 0)
                        return void (n && (e._zTime = n))
                } else
                    !1 === I && (e._startAt = 0);
            else if (L && O)
                if (k)
                    !I && (e._startAt = 0);
                else if (n && (S = !1),
                a = mt({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: S && P(T),
                    immediateRender: S,
                    stagger: 0,
                    parent: z
                }, i),
                g && (a[d.prop] = g),
                bt(e._startAt = Fe.set(N, a)),
                n < 0 && e._startAt.render(-1, !0),
                e._zTime = n,
                S) {
                    if (!n)
                        return
                } else
                    t(e._startAt, _);
            for (e._pt = 0,
            T = O && P(T) || T && !O,
            o = 0; o < N.length; o++) {
                if (u = (c = N[o])._gsap || rt(N)[o]._gsap,
                e._ptLookup[o] = f = {},
                Q[u.id] && K.length && ut(),
                m = B === N ? o : B.indexOf(c),
                d && !1 !== (p = new d).init(c, g || i, e, m, B) && (e._pt = l = new $e(e._pt,c,p.name,0,1,p.render,p,0,p.priority),
                p._props.forEach((function(t) {
                    f[t] = l
                }
                )),
                p.priority && (h = 1)),
                !d || g)
                    for (a in i)
                        $[a] && (p = Ie(a, i, e, m, c, B)) ? p.priority && (h = 1) : f[a] = l = De.call(e, c, a, "get", i[a], m, B, 0, b.stringFilter);
                e._op && e._op[o] && e.kill(c, e._op[o]),
                F && e._pt && (Ce = e,
                s.killTweensOf(c, f, e.globalTime(n)),
                x = !e.parent,
                Ce = 0),
                e._pt && T && (Q[u.id] = 1)
            }
            h && Qe(e),
            e._onInit && e._onInit(e)
        }
        e._onUpdate = E,
        e._initted = (!e._op || e._pt) && !x,
        D && n <= 0 && U.render(y, !0, !0)
    }, ke = function(t, e, n, i) {
        var r, s, o = e.ease || i || "power1.inOut";
        if (k(e))
            s = n[t] || (n[t] = []),
            e.forEach((function(t, n) {
                return s.push({
                    t: n / (e.length - 1) * 100,
                    v: t,
                    e: o
                })
            }
            ));
        else
            for (r in e)
                s = n[r] || (n[r] = []),
                "ease" === r || s.push({
                    t: parseFloat(t),
                    v: e[r],
                    e: o
                })
    }, Ne = function(t, e, n, i, r) {
        return A(t) ? t.call(e, n, i, r) : E(t) && ~t.indexOf("random(") ? $t(t) : t
    }, ze = it + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", Be = {};
    at(ze + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
        return Be[t] = 1
    }
    ));
    var Fe = function(t) {
        function e(e, i, o, a) {
            var l;
            "number" == typeof i && (o.duration = i,
            i = o,
            o = null);
            var c, h, u, d, p, f, m, v, y = (l = t.call(this, a ? i : _t(i)) || this).vars, _ = y.duration, x = y.delay, b = y.immediateRender, w = y.stagger, M = y.overwrite, S = y.keyframes, T = y.defaults, E = y.scrollTrigger, A = y.yoyoEase, L = i.parent || s, D = (k(e) || O(e) ? R(e[0]) : "length"in i) ? [e] : Xt(e);
            if (l._targets = D.length ? rt(D) : q("GSAP target " + e + " not found. https://greensock.com", !g.nullTargetWarn) || [],
            l._ptLookup = [],
            l._overwrite = M,
            S || w || I(_) || I(x)) {
                if (i = l.vars,
                (c = l.timeline = new Le({
                    data: "nested",
                    defaults: T || {}
                })).kill(),
                c.parent = c._dp = n(l),
                c._start = 0,
                w || I(_) || I(x)) {
                    if (d = D.length,
                    m = w && Yt(w),
                    C(w))
                        for (p in w)
                            ~ze.indexOf(p) && (v || (v = {}),
                            v[p] = w[p]);
                    for (h = 0; h < d; h++)
                        (u = yt(i, Be)).stagger = 0,
                        A && (u.yoyoEase = A),
                        v && gt(u, v),
                        f = D[h],
                        u.duration = +Ne(_, n(l), h, f, D),
                        u.delay = (+Ne(x, n(l), h, f, D) || 0) - l._delay,
                        !w && 1 === d && u.delay && (l._delay = x = u.delay,
                        l._start += x,
                        u.delay = 0),
                        c.to(f, u, m ? m(h, f, D) : 0),
                        c._ease = ge.none;
                    c.duration() ? _ = x = 0 : l.timeline = 0
                } else if (S) {
                    _t(mt(c.vars.defaults, {
                        ease: "none"
                    })),
                    c._ease = we(S.ease || i.ease || "none");
                    var N, z, B, F = 0;
                    if (k(S))
                        S.forEach((function(t) {
                            return c.to(D, t, ">")
                        }
                        ));
                    else {
                        for (p in u = {},
                        S)
                            "ease" === p || "easeEach" === p || ke(p, S[p], u, S.easeEach);
                        for (p in u)
                            for (N = u[p].sort((function(t, e) {
                                return t.t - e.t
                            }
                            )),
                            F = 0,
                            h = 0; h < N.length; h++)
                                (B = {
                                    ease: (z = N[h]).e,
                                    duration: (z.t - (h ? N[h - 1].t : 0)) / 100 * _
                                })[p] = z.v,
                                c.to(D, B, F),
                                F += B.duration;
                        c.duration() < _ && c.to({}, {
                            duration: _ - c.duration()
                        })
                    }
                }
                _ || l.duration(_ = c.duration())
            } else
                l.timeline = 0;
            return !0 !== M || r || (Ce = n(l),
            s.killTweensOf(D),
            Ce = 0),
            Pt(L, n(l), o),
            i.reversed && l.reverse(),
            i.paused && l.paused(!0),
            (b || !_ && !S && l._start === ct(L._time) && P(b) && St(n(l)) && "nested" !== L.data) && (l._tTime = -1e-8,
            l.render(Math.max(0, -x))),
            E && Dt(n(l), E),
            l
        }
        i(e, t);
        var o = e.prototype;
        return o.render = function(t, e, n) {
            var i, r, s, o, a, l, c, h, u, d = this._time, p = this._tDur, f = this._dur, m = t > p - _ && t >= 0 ? p : t < _ ? 0 : t;
            if (f) {
                if (m !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                    if (i = m,
                    h = this.timeline,
                    this._repeat) {
                        if (o = f + this._rDelay,
                        this._repeat < -1 && t < 0)
                            return this.totalTime(100 * o + t, e, n);
                        if (i = ct(m % o),
                        m === p ? (s = this._repeat,
                        i = f) : ((s = ~~(m / o)) && s === m / o && (i = f,
                        s--),
                        i > f && (i = f)),
                        (l = this._yoyo && 1 & s) && (u = this._yEase,
                        i = f - i),
                        a = Et(this._tTime, o),
                        i === d && !n && this._initted)
                            return this;
                        s !== a && (h && this._yEase && be(h, l),
                        !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1,
                        this.render(ct(o * s), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (It(this, t < 0 ? t : i, n, e))
                            return this._tTime = 0,
                            this;
                        if (f !== this._dur)
                            return this.render(t, e, n)
                    }
                    if (this._tTime = m,
                    this._time = i,
                    !this._act && this._ts && (this._act = 1,
                    this._lazy = 0),
                    this.ratio = c = (u || this._ease)(i / f),
                    this._from && (this.ratio = c = 1 - c),
                    i && !d && !e && (ne(this, "onStart"),
                    this._tTime !== m))
                        return this;
                    for (r = this._pt; r; )
                        r.r(c, r.d),
                        r = r._next;
                    h && h.render(t < 0 ? t : !i && l ? -1e-8 : h._dur * h._ease(i / this._dur), e, n) || this._startAt && (this._zTime = t),
                    this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n),
                    ne(this, "onUpdate")),
                    this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && ne(this, "onRepeat"),
                    m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0),
                    (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && bt(this, 1),
                    e || t < 0 && !d || !m && !d || (ne(this, m === p ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                }
            } else
                !function(t, e, n, i) {
                    var r, s, o, a = t.ratio, l = e < 0 || !e && (!t._start && Ot(t) && (t._initted || !kt(t)) || (t._ts < 0 || t._dp._ts < 0) && !kt(t)) ? 0 : 1, c = t._rDelay, h = 0;
                    if (c && t._repeat && (h = Vt(0, t._tDur, e),
                    s = Et(h, c),
                    t._yoyo && 1 & s && (l = 1 - l),
                    s !== Et(t._tTime, c) && (a = 1 - l,
                    t.vars.repeatRefresh && t._initted && t.invalidate())),
                    l !== a || i || t._zTime === _ || !e && t._zTime) {
                        if (!t._initted && It(t, e, i, n))
                            return;
                        for (o = t._zTime,
                        t._zTime = e || (n ? _ : 0),
                        n || (n = e && !o),
                        t.ratio = l,
                        t._from && (l = 1 - l),
                        t._time = 0,
                        t._tTime = h,
                        r = t._pt; r; )
                            r.r(l, r.d),
                            r = r._next;
                        t._startAt && e < 0 && t._startAt.render(e, !0, !0),
                        t._onUpdate && !n && ne(t, "onUpdate"),
                        h && t._repeat && !n && t.parent && ne(t, "onRepeat"),
                        (e >= t._tDur || e < 0) && t.ratio === l && (l && bt(t, 1),
                        n || (ne(t, l ? "onComplete" : "onReverseComplete", !0),
                        t._prom && t._prom()))
                    } else
                        t._zTime || (t._zTime = e)
                }(this, t, e, n);
            return this
        }
        ,
        o.targets = function() {
            return this._targets
        }
        ,
        o.invalidate = function() {
            return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0,
            this._ptLookup = [],
            this.timeline && this.timeline.invalidate(),
            t.prototype.invalidate.call(this)
        }
        ,
        o.kill = function(t, e) {
            if (void 0 === e && (e = "all"),
            !(t || e && "all" !== e))
                return this._lazy = this._pt = 0,
                this.parent ? ie(this) : this;
            if (this.timeline) {
                var n = this.timeline.totalDuration();
                return this.timeline.killTweensOf(t, e, Ce && !0 !== Ce.vars.overwrite)._first || ie(this),
                this.parent && n !== this.timeline.totalDuration() && Nt(this, this._dur * this.timeline._tDur / n, 0, 1),
                this
            }
            var i, r, s, o, a, l, c, h = this._targets, u = t ? Xt(t) : h, d = this._ptLookup, p = this._pt;
            if ((!e || "all" === e) && function(t, e) {
                for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n]; )
                    ;
                return n < 0
            }(h, u))
                return "all" === e && (this._pt = 0),
                ie(this);
            for (i = this._op = this._op || [],
            "all" !== e && (E(e) && (a = {},
            at(e, (function(t) {
                return a[t] = 1
            }
            )),
            e = a),
            e = function(t, e) {
                var n, i, r, s, o = t[0] ? st(t[0]).harness : 0, a = o && o.aliases;
                if (!a)
                    return e;
                for (i in n = gt({}, e),
                a)
                    if (i in n)
                        for (r = (s = a[i].split(",")).length; r--; )
                            n[s[r]] = n[i];
                return n
            }(h, e)),
            c = h.length; c--; )
                if (~u.indexOf(h[c]))
                    for (a in r = d[c],
                    "all" === e ? (i[c] = e,
                    o = r,
                    s = {}) : (s = i[c] = i[c] || {},
                    o = e),
                    o)
                        (l = r && r[a]) && ("kill"in l.d && !0 !== l.d.kill(a) || xt(this, l, "_pt"),
                        delete r[a]),
                        "all" !== s && (s[a] = 1);
            return this._initted && !this._pt && p && ie(this),
            this
        }
        ,
        e.to = function(t, n) {
            return new e(t,n,arguments[2])
        }
        ,
        e.from = function(t, e) {
            return Ut(1, arguments)
        }
        ,
        e.delayedCall = function(t, n, i, r) {
            return new e(n,0,{
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: t,
                onComplete: n,
                onReverseComplete: n,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: r
            })
        }
        ,
        e.fromTo = function(t, e, n) {
            return Ut(2, arguments)
        }
        ,
        e.set = function(t, n) {
            return n.duration = 0,
            n.repeatDelay || (n.repeat = 0),
            new e(t,n)
        }
        ,
        e.killTweensOf = function(t, e, n) {
            return s.killTweensOf(t, e, n)
        }
        ,
        e
    }(Re);
    mt(Fe.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }),
    at("staggerTo,staggerFrom,staggerFromTo", (function(t) {
        Fe[t] = function() {
            var e = new Le
              , n = Wt.call(arguments, 0);
            return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
            e[t].apply(e, n)
        }
    }
    ));
    var Ue = function(t, e, n) {
        return t[e] = n
    }
      , He = function(t, e, n) {
        return t[e](n)
    }
      , Ve = function(t, e, n, i) {
        return t[e](i.fp, n)
    }
      , Ge = function(t, e, n) {
        return t.setAttribute(e, n)
    }
      , We = function(t, e) {
        return A(t[e]) ? He : L(t[e]) && t.setAttribute ? Ge : Ue
    }
      , je = function(t, e) {
        return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
    }
      , Xe = function(t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e)
    }
      , qe = function(t, e) {
        var n = e._pt
          , i = "";
        if (!t && e.b)
            i = e.b;
        else if (1 === t && e.e)
            i = e.e;
        else {
            for (; n; )
                i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i,
                n = n._next;
            i += e.c
        }
        e.set(e.t, e.p, i, e)
    }
      , Ye = function(t, e) {
        for (var n = e._pt; n; )
            n.r(t, n.d),
            n = n._next
    }
      , Ze = function(t, e, n, i) {
        for (var r, s = this._pt; s; )
            r = s._next,
            s.p === i && s.modifier(t, e, n),
            s = r
    }
      , Je = function(t) {
        for (var e, n, i = this._pt; i; )
            n = i._next,
            i.p === t && !i.op || i.op === t ? xt(this, i, "_pt") : i.dep || (e = 1),
            i = n;
        return !e
    }
      , Ke = function(t, e, n, i) {
        i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
    }
      , Qe = function(t) {
        for (var e, n, i, r, s = t._pt; s; ) {
            for (e = s._next,
            n = i; n && n.pr > s.pr; )
                n = n._next;
            (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s,
            (s._next = n) ? n._prev = s : r = s,
            s = e
        }
        t._pt = i
    }
      , $e = function() {
        function t(t, e, n, i, r, s, o, a, l) {
            this.t = e,
            this.s = i,
            this.c = r,
            this.p = n,
            this.r = s || je,
            this.d = o || this,
            this.set = a || Ue,
            this.pr = l || 0,
            this._next = t,
            t && (t._prev = this)
        }
        return t.prototype.modifier = function(t, e, n) {
            this.mSet = this.mSet || this.set,
            this.set = Ke,
            this.m = t,
            this.mt = n,
            this.tween = e
        }
        ,
        t
    }();
    at(it + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
        return J[t] = 1
    }
    )),
    G.TweenMax = G.TweenLite = Fe,
    G.TimelineLite = G.TimelineMax = Le,
    s = new Le({
        sortChildren: !1,
        defaults: v,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }),
    g.stringFilter = pe;
    var tn = {
        registerPlugin: function() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
            e.forEach((function(t) {
                return re(t)
            }
            ))
        },
        timeline: function(t) {
            return new Le(t)
        },
        getTweensOf: function(t, e) {
            return s.getTweensOf(t, e)
        },
        getProperty: function(t, e, n, i) {
            E(t) && (t = Xt(t)[0]);
            var r = st(t || {}).get
              , s = n ? ft : pt;
            return "native" === n && (n = ""),
            t ? e ? s(($[e] && $[e].get || r)(t, e, n, i)) : function(e, n, i) {
                return s(($[e] && $[e].get || r)(t, e, n, i))
            }
            : t
        },
        quickSetter: function(t, e, n) {
            if ((t = Xt(t)).length > 1) {
                var i = t.map((function(t) {
                    return rn.quickSetter(t, e, n)
                }
                ))
                  , r = i.length;
                return function(t) {
                    for (var e = r; e--; )
                        i[e](t)
                }
            }
            t = t[0] || {};
            var s = $[e]
              , o = st(t)
              , a = o.harness && (o.harness.aliases || {})[e] || e
              , l = s ? function(e) {
                var i = new s;
                u._pt = 0,
                i.init(t, n ? e + n : e, u, 0, [t]),
                i.render(1, i),
                u._pt && Ye(1, u)
            }
            : o.set(t, a);
            return s ? l : function(e) {
                return l(t, a, n ? e + n : e, o, 1)
            }
        },
        isTweening: function(t) {
            return s.getTweensOf(t, !0).length > 0
        },
        defaults: function(t) {
            return t && t.ease && (t.ease = we(t.ease, v.ease)),
            vt(v, t || {})
        },
        config: function(t) {
            return vt(g, t || {})
        },
        registerEffect: function(t) {
            var e = t.name
              , n = t.effect
              , i = t.plugins
              , r = t.defaults
              , s = t.extendTimeline;
            (i || "").split(",").forEach((function(t) {
                return t && !$[t] && !G[t] && q(e + " effect requires " + t + " plugin.")
            }
            )),
            tt[e] = function(t, e, i) {
                return n(Xt(t), mt(e || {}, r), i)
            }
            ,
            s && (Le.prototype[e] = function(t, n, i) {
                return this.add(tt[e](t, C(n) ? n : (i = n) && {}, this), i)
            }
            )
        },
        registerEase: function(t, e) {
            ge[t] = we(e)
        },
        parseEase: function(t, e) {
            return arguments.length ? we(t, e) : ge
        },
        getById: function(t) {
            return s.getById(t)
        },
        exportRoot: function(t, e) {
            void 0 === t && (t = {});
            var n, i, r = new Le(t);
            for (r.smoothChildTiming = P(t.smoothChildTiming),
            s.remove(r),
            r._dp = 0,
            r._time = r._tTime = s._time,
            n = s._first; n; )
                i = n._next,
                !e && !n._dur && n instanceof Fe && n.vars.onComplete === n._targets[0] || Pt(r, n, n._start - n._delay),
                n = i;
            return Pt(s, r, 0),
            r
        },
        utils: {
            wrap: function t(e, n, i) {
                var r = n - e;
                return k(e) ? Qt(e, t(0, e.length), n) : Ht(i, (function(t) {
                    return (r + (t - e) % r) % r + e
                }
                ))
            },
            wrapYoyo: function t(e, n, i) {
                var r = n - e
                  , s = 2 * r;
                return k(e) ? Qt(e, t(0, e.length - 1), n) : Ht(i, (function(t) {
                    return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                }
                ))
            },
            distribute: Yt,
            random: Kt,
            snap: Jt,
            normalize: function(t, e, n) {
                return te(t, e, 0, 1, n)
            },
            getUnit: Gt,
            clamp: function(t, e, n) {
                return Ht(n, (function(n) {
                    return Vt(t, e, n)
                }
                ))
            },
            splitColor: le,
            toArray: Xt,
            selector: function(t) {
                return t = Xt(t)[0] || q("Invalid scope") || {},
                function(e) {
                    var n = t.current || t.nativeElement || t;
                    return Xt(e, n.querySelectorAll ? n : n === t ? q("Invalid scope") || l.createElement("div") : t)
                }
            },
            mapRange: te,
            pipe: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                return function(t) {
                    return e.reduce((function(t, e) {
                        return e(t)
                    }
                    ), t)
                }
            },
            unitize: function(t, e) {
                return function(n) {
                    return t(parseFloat(n)) + (e || Gt(n))
                }
            },
            interpolate: function t(e, n, i, r) {
                var s = isNaN(e + n) ? 0 : function(t) {
                    return (1 - t) * e + t * n
                }
                ;
                if (!s) {
                    var o, a, l, c, h, u = E(e), d = {};
                    if (!0 === i && (r = 1) && (i = null),
                    u)
                        e = {
                            p: e
                        },
                        n = {
                            p: n
                        };
                    else if (k(e) && !k(n)) {
                        for (l = [],
                        c = e.length,
                        h = c - 2,
                        a = 1; a < c; a++)
                            l.push(t(e[a - 1], e[a]));
                        c--,
                        s = function(t) {
                            t *= c;
                            var e = Math.min(h, ~~t);
                            return l[e](t - e)
                        }
                        ,
                        i = n
                    } else
                        r || (e = gt(k(e) ? [] : {}, e));
                    if (!l) {
                        for (o in n)
                            De.call(d, e, o, "get", n[o]);
                        s = function(t) {
                            return Ye(t, d) || (u ? e.p : e)
                        }
                    }
                }
                return Ht(i, s)
            },
            shuffle: qt
        },
        install: j,
        effects: tt,
        ticker: fe,
        updateRoot: Le.updateRoot,
        plugins: $,
        globalTimeline: s,
        core: {
            PropTween: $e,
            globals: Y,
            Tween: Fe,
            Timeline: Le,
            Animation: Re,
            getCache: st,
            _removeLinkedListItem: xt,
            suppressOverwrites: function(t) {
                return r = t
            }
        }
    };
    at("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
        return tn[t] = Fe[t]
    }
    )),
    fe.add(Le.updateRoot),
    u = tn.to({}, {
        duration: 0
    });
    var en = function(t, e) {
        for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
            n = n._next;
        return n
    }
      , nn = function(t, e) {
        return {
            name: t,
            rawVars: 1,
            init: function(t, n, i) {
                i._onInit = function(t) {
                    var i, r;
                    if (E(n) && (i = {},
                    at(n, (function(t) {
                        return i[t] = 1
                    }
                    )),
                    n = i),
                    e) {
                        for (r in i = {},
                        n)
                            i[r] = e(n[r]);
                        n = i
                    }
                    !function(t, e) {
                        var n, i, r, s = t._targets;
                        for (n in e)
                            for (i = s.length; i--; )
                                (r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = en(r, n)),
                                r && r.modifier && r.modifier(e[n], t, s[i], n))
                    }(t, n)
                }
            }
        }
    }
      , rn = tn.registerPlugin({
        name: "attr",
        init: function(t, e, n, i, r) {
            var s, o;
            for (s in e)
                (o = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], i, r, 0, 0, s)) && (o.op = s),
                this._props.push(s)
        }
    }, {
        name: "endArray",
        init: function(t, e) {
            for (var n = e.length; n--; )
                this.add(t, n, t[n] || 0, e[n])
        }
    }, nn("roundProps", Zt), nn("modifiers"), nn("snap", Jt)) || tn;
    Fe.version = Le.version = rn.version = "3.9.1",
    c = 1,
    D() && me(),
    ge.Power0,
    ge.Power1,
    ge.Power2,
    ge.Power3,
    ge.Power4,
    ge.Linear,
    ge.Quad,
    ge.Cubic,
    ge.Quart,
    ge.Quint,
    ge.Strong,
    ge.Elastic,
    ge.Back,
    ge.SteppedEase,
    ge.Bounce,
    ge.Sine,
    ge.Expo,
    ge.Circ;
    var sn, on, an, ln, cn, hn, un, dn = {}, pn = 180 / Math.PI, fn = Math.PI / 180, mn = Math.atan2, gn = /([A-Z])/g, vn = /(?:left|right|width|margin|padding|x)/i, yn = /[\s,\(]\S/, _n = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    }, xn = function(t, e) {
        return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, bn = function(t, e) {
        return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, wn = function(t, e) {
        return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
    }, Mn = function(t, e) {
        var n = e.s + e.c * t;
        e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
    }, Sn = function(t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e)
    }, Tn = function(t, e) {
        return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
    }, En = function(t, e, n) {
        return t.style[e] = n
    }, An = function(t, e, n) {
        return t.style.setProperty(e, n)
    }, Rn = function(t, e, n) {
        return t._gsap[e] = n
    }, Ln = function(t, e, n) {
        return t._gsap.scaleX = t._gsap.scaleY = n
    }, Cn = function(t, e, n, i, r) {
        var s = t._gsap;
        s.scaleX = s.scaleY = n,
        s.renderTransform(r, s)
    }, Pn = function(t, e, n, i, r) {
        var s = t._gsap;
        s[e] = n,
        s.renderTransform(r, s)
    }, Dn = "transform", In = Dn + "Origin", On = function(t, e) {
        var n = on.createElementNS ? on.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : on.createElement(t);
        return n.style ? n : on.createElement(t)
    }, kn = function t(e, n, i) {
        var r = getComputedStyle(e);
        return r[n] || r.getPropertyValue(n.replace(gn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, zn(n) || n, 1) || ""
    }, Nn = "O,Moz,ms,Ms,Webkit".split(","), zn = function(t, e, n) {
        var i = (e || cn).style
          , r = 5;
        if (t in i && !n)
            return t;
        for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(Nn[r] + t in i); )
            ;
        return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Nn[r] : "") + t
    }, Bn = function() {
        "undefined" != typeof window && window.document && (sn = window,
        on = sn.document,
        an = on.documentElement,
        cn = On("div") || {
            style: {}
        },
        On("div"),
        Dn = zn(Dn),
        In = Dn + "Origin",
        cn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
        un = !!zn("perspective"),
        ln = 1)
    }, Fn = function t(e) {
        var n, i = On("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, o = this.style.cssText;
        if (an.appendChild(i),
        i.appendChild(this),
        this.style.display = "block",
        e)
            try {
                n = this.getBBox(),
                this._gsapBBox = this.getBBox,
                this.getBBox = t
            } catch (t) {}
        else
            this._gsapBBox && (n = this._gsapBBox());
        return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
        an.removeChild(i),
        this.style.cssText = o,
        n
    }, Un = function(t, e) {
        for (var n = e.length; n--; )
            if (t.hasAttribute(e[n]))
                return t.getAttribute(e[n])
    }, Hn = function(t) {
        var e;
        try {
            e = t.getBBox()
        } catch (n) {
            e = Fn.call(t, !0)
        }
        return e && (e.width || e.height) || t.getBBox === Fn || (e = Fn.call(t, !0)),
        !e || e.width || e.x || e.y ? e : {
            x: +Un(t, ["x", "cx", "x1"]) || 0,
            y: +Un(t, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        }
    }, Vn = function(t) {
        return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Hn(t))
    }, Gn = function(t, e) {
        if (e) {
            var n = t.style;
            e in dn && e !== In && (e = Dn),
            n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
            n.removeProperty(e.replace(gn, "-$1").toLowerCase())) : n.removeAttribute(e)
        }
    }, Wn = function(t, e, n, i, r, s) {
        var o = new $e(t._pt,e,n,0,1,s ? Tn : Sn);
        return t._pt = o,
        o.b = i,
        o.e = r,
        t._props.push(n),
        o
    }, jn = {
        deg: 1,
        rad: 1,
        turn: 1
    }, Xn = function t(e, n, i, r) {
        var s, o, a, l, c = parseFloat(i) || 0, h = (i + "").trim().substr((c + "").length) || "px", u = cn.style, d = vn.test(n), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
        return r === h || !c || jn[r] || jn[h] ? c : ("px" !== h && !g && (c = t(e, n, i, "px")),
        l = e.getCTM && Vn(e),
        !v && "%" !== h || !dn[n] && !~n.indexOf("adius") ? (u[d ? "width" : "height"] = m + (g ? h : r),
        o = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode,
        l && (o = (e.ownerSVGElement || {}).parentNode),
        o && o !== on && o.appendChild || (o = on.body),
        (a = o._gsap) && v && a.width && d && a.time === fe.time ? lt(c / a.width * m) : ((v || "%" === h) && (u.position = kn(e, "position")),
        o === e && (u.position = "static"),
        o.appendChild(cn),
        s = cn[f],
        o.removeChild(cn),
        u.position = "absolute",
        d && v && ((a = st(o)).time = fe.time,
        a.width = o[f]),
        lt(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? e.getBBox()[d ? "width" : "height"] : e[f],
        lt(v ? c / s * m : c / 100 * s)))
    }, qn = function(t, e, n, i) {
        var r;
        return ln || Bn(),
        e in _n && "transform" !== e && ~(e = _n[e]).indexOf(",") && (e = e.split(",")[0]),
        dn[e] && "transform" !== e ? (r = si(t, i),
        r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : oi(kn(t, In)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Qn[e] && Qn[e](t, e, n) || kn(t, e) || ot(t, e) || ("opacity" === e ? 1 : 0)),
        n && !~(r + "").trim().indexOf(" ") ? Xn(t, e, r, n) + n : r
    }, Yn = function(t, e, n, i) {
        if (!n || "none" === n) {
            var r = zn(e, t, 1)
              , s = r && kn(t, r, 1);
            s && s !== n ? (e = r,
            n = s) : "borderColor" === e && (n = kn(t, "borderTopColor"))
        }
        var o, a, l, c, h, u, d, p, f, m, v, y, _ = new $e(this._pt,t.style,e,0,1,qe), x = 0, b = 0;
        if (_.b = n,
        _.e = i,
        n += "",
        "auto" == (i += "") && (t.style[e] = i,
        i = kn(t, e) || i,
        t.style[e] = n),
        pe(o = [n, i]),
        i = o[1],
        l = (n = o[0]).match(B) || [],
        (i.match(B) || []).length) {
            for (; a = B.exec(i); )
                d = a[0],
                f = i.substring(x, a.index),
                h ? h = (h + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (h = 1),
                d !== (u = l[b++] || "") && (c = parseFloat(u) || 0,
                v = u.substr((c + "").length),
                (y = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)),
                p = parseFloat(d),
                m = d.substr((p + "").length),
                x = B.lastIndex - m.length,
                m || (m = m || g.units[e] || v,
                x === i.length && (i += m,
                _.e += m)),
                v !== m && (c = Xn(t, e, u, m) || 0),
                _._pt = {
                    _next: _._pt,
                    p: f || 1 === b ? f : ",",
                    s: c,
                    c: y ? y * p : p - c,
                    m: h && h < 4 || "zIndex" === e ? Math.round : 0
                });
            _.c = x < i.length ? i.substring(x, i.length) : ""
        } else
            _.r = "display" === e && "none" === i ? Tn : Sn;
        return U.test(i) && (_.e = 0),
        this._pt = _,
        _
    }, Zn = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    }, Jn = function(t) {
        var e = t.split(" ")
          , n = e[0]
          , i = e[1] || "50%";
        return "top" !== n && "bottom" !== n && "left" !== i && "right" !== i || (t = n,
        n = i,
        i = t),
        e[0] = Zn[n] || n,
        e[1] = Zn[i] || i,
        e.join(" ")
    }, Kn = function(t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
            var n, i, r, s = e.t, o = s.style, a = e.u, l = s._gsap;
            if ("all" === a || !0 === a)
                o.cssText = "",
                i = 1;
            else
                for (r = (a = a.split(",")).length; --r > -1; )
                    n = a[r],
                    dn[n] && (i = 1,
                    n = "transformOrigin" === n ? In : Dn),
                    Gn(s, n);
            i && (Gn(s, Dn),
            l && (l.svg && s.removeAttribute("transform"),
            si(s, 1),
            l.uncache = 1))
        }
    }, Qn = {
        clearProps: function(t, e, n, i, r) {
            if ("isFromStart" !== r.data) {
                var s = t._pt = new $e(t._pt,e,n,0,0,Kn);
                return s.u = i,
                s.pr = -10,
                s.tween = r,
                t._props.push(n),
                1
            }
        }
    }, $n = [1, 0, 0, 1, 0, 0], ti = {}, ei = function(t) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
    }, ni = function(t) {
        var e = kn(t, Dn);
        return ei(e) ? $n : e.substr(7).match(z).map(lt)
    }, ii = function(t, e) {
        var n, i, r, s, o = t._gsap || st(t), a = t.style, l = ni(t);
        return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? $n : l : (l !== $n || t.offsetParent || t === an || o.svg || (r = a.display,
        a.display = "block",
        (n = t.parentNode) && t.offsetParent || (s = 1,
        i = t.nextSibling,
        an.appendChild(t)),
        l = ni(t),
        r ? a.display = r : Gn(t, "display"),
        s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : an.removeChild(t))),
        e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
    }, ri = function(t, e, n, i, r, s) {
        var o, a, l, c = t._gsap, h = r || ii(t, !0), u = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = h[0], g = h[1], v = h[2], y = h[3], _ = h[4], x = h[5], b = e.split(" "), w = parseFloat(b[0]) || 0, M = parseFloat(b[1]) || 0;
        n ? h !== $n && (a = m * y - g * v) && (l = w * (-g / a) + M * (m / a) - (m * x - g * _) / a,
        w = w * (y / a) + M * (-v / a) + (v * x - y * _) / a,
        M = l) : (w = (o = Hn(t)).x + (~b[0].indexOf("%") ? w / 100 * o.width : w),
        M = o.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * o.height : M)),
        i || !1 !== i && c.smooth ? (_ = w - u,
        x = M - d,
        c.xOffset = p + (_ * m + x * v) - _,
        c.yOffset = f + (_ * g + x * y) - x) : c.xOffset = c.yOffset = 0,
        c.xOrigin = w,
        c.yOrigin = M,
        c.smooth = !!i,
        c.origin = e,
        c.originIsAbsolute = !!n,
        t.style[In] = "0px 0px",
        s && (Wn(s, c, "xOrigin", u, w),
        Wn(s, c, "yOrigin", d, M),
        Wn(s, c, "xOffset", p, c.xOffset),
        Wn(s, c, "yOffset", f, c.yOffset)),
        t.setAttribute("data-svg-origin", w + " " + M)
    }, si = function(t, e) {
        var n = t._gsap || new Ae(t);
        if ("x"in n && !e && !n.uncache)
            return n;
        var i, r, s, o, a, l, c, h, u, d, p, f, m, v, y, _, x, b, w, M, S, T, E, A, R, L, C, P, D, I, O, k, N = t.style, z = n.scaleX < 0, B = "px", F = "deg", U = kn(t, In) || "0";
        return i = r = s = l = c = h = u = d = p = 0,
        o = a = 1,
        n.svg = !(!t.getCTM || !Vn(t)),
        v = ii(t, n.svg),
        n.svg && (A = (!n.uncache || "0px 0px" === U) && !e && t.getAttribute("data-svg-origin"),
        ri(t, A || U, !!A || n.originIsAbsolute, !1 !== n.smooth, v)),
        f = n.xOrigin || 0,
        m = n.yOrigin || 0,
        v !== $n && (b = v[0],
        w = v[1],
        M = v[2],
        S = v[3],
        i = T = v[4],
        r = E = v[5],
        6 === v.length ? (o = Math.sqrt(b * b + w * w),
        a = Math.sqrt(S * S + M * M),
        l = b || w ? mn(w, b) * pn : 0,
        (u = M || S ? mn(M, S) * pn + l : 0) && (a *= Math.abs(Math.cos(u * fn))),
        n.svg && (i -= f - (f * b + m * M),
        r -= m - (f * w + m * S))) : (k = v[6],
        I = v[7],
        C = v[8],
        P = v[9],
        D = v[10],
        O = v[11],
        i = v[12],
        r = v[13],
        s = v[14],
        c = (y = mn(k, D)) * pn,
        y && (A = T * (_ = Math.cos(-y)) + C * (x = Math.sin(-y)),
        R = E * _ + P * x,
        L = k * _ + D * x,
        C = T * -x + C * _,
        P = E * -x + P * _,
        D = k * -x + D * _,
        O = I * -x + O * _,
        T = A,
        E = R,
        k = L),
        h = (y = mn(-M, D)) * pn,
        y && (_ = Math.cos(-y),
        O = S * (x = Math.sin(-y)) + O * _,
        b = A = b * _ - C * x,
        w = R = w * _ - P * x,
        M = L = M * _ - D * x),
        l = (y = mn(w, b)) * pn,
        y && (A = b * (_ = Math.cos(y)) + w * (x = Math.sin(y)),
        R = T * _ + E * x,
        w = w * _ - b * x,
        E = E * _ - T * x,
        b = A,
        T = R),
        c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
        h = 180 - h),
        o = lt(Math.sqrt(b * b + w * w + M * M)),
        a = lt(Math.sqrt(E * E + k * k)),
        y = mn(T, E),
        u = Math.abs(y) > 2e-4 ? y * pn : 0,
        p = O ? 1 / (O < 0 ? -O : O) : 0),
        n.svg && (A = t.getAttribute("transform"),
        n.forceCSS = t.setAttribute("transform", "") || !ei(kn(t, Dn)),
        A && t.setAttribute("transform", A))),
        Math.abs(u) > 90 && Math.abs(u) < 270 && (z ? (o *= -1,
        u += l <= 0 ? 180 : -180,
        l += l <= 0 ? 180 : -180) : (a *= -1,
        u += u <= 0 ? 180 : -180)),
        n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + B,
        n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + B,
        n.z = s + B,
        n.scaleX = lt(o),
        n.scaleY = lt(a),
        n.rotation = lt(l) + F,
        n.rotationX = lt(c) + F,
        n.rotationY = lt(h) + F,
        n.skewX = u + F,
        n.skewY = d + F,
        n.transformPerspective = p + B,
        (n.zOrigin = parseFloat(U.split(" ")[2]) || 0) && (N[In] = oi(U)),
        n.xOffset = n.yOffset = 0,
        n.force3D = g.force3D,
        n.renderTransform = n.svg ? pi : un ? di : li,
        n.uncache = 0,
        n
    }, oi = function(t) {
        return (t = t.split(" "))[0] + " " + t[1]
    }, ai = function(t, e, n) {
        var i = Gt(e);
        return lt(parseFloat(e) + parseFloat(Xn(t, "x", n + "px", i))) + i
    }, li = function(t, e) {
        e.z = "0px",
        e.rotationY = e.rotationX = "0deg",
        e.force3D = 0,
        di(t, e)
    }, ci = "0deg", hi = "0px", ui = ") ", di = function(t, e) {
        var n = e || this
          , i = n.xPercent
          , r = n.yPercent
          , s = n.x
          , o = n.y
          , a = n.z
          , l = n.rotation
          , c = n.rotationY
          , h = n.rotationX
          , u = n.skewX
          , d = n.skewY
          , p = n.scaleX
          , f = n.scaleY
          , m = n.transformPerspective
          , g = n.force3D
          , v = n.target
          , y = n.zOrigin
          , _ = ""
          , x = "auto" === g && t && 1 !== t || !0 === g;
        if (y && (h !== ci || c !== ci)) {
            var b, w = parseFloat(c) * fn, M = Math.sin(w), S = Math.cos(w);
            w = parseFloat(h) * fn,
            b = Math.cos(w),
            s = ai(v, s, M * b * -y),
            o = ai(v, o, -Math.sin(w) * -y),
            a = ai(v, a, S * b * -y + y)
        }
        m !== hi && (_ += "perspective(" + m + ui),
        (i || r) && (_ += "translate(" + i + "%, " + r + "%) "),
        (x || s !== hi || o !== hi || a !== hi) && (_ += a !== hi || x ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ui),
        l !== ci && (_ += "rotate(" + l + ui),
        c !== ci && (_ += "rotateY(" + c + ui),
        h !== ci && (_ += "rotateX(" + h + ui),
        u === ci && d === ci || (_ += "skew(" + u + ", " + d + ui),
        1 === p && 1 === f || (_ += "scale(" + p + ", " + f + ui),
        v.style[Dn] = _ || "translate(0, 0)"
    }, pi = function(t, e) {
        var n, i, r, s, o, a = e || this, l = a.xPercent, c = a.yPercent, h = a.x, u = a.y, d = a.rotation, p = a.skewX, f = a.skewY, m = a.scaleX, g = a.scaleY, v = a.target, y = a.xOrigin, _ = a.yOrigin, x = a.xOffset, b = a.yOffset, w = a.forceCSS, M = parseFloat(h), S = parseFloat(u);
        d = parseFloat(d),
        p = parseFloat(p),
        (f = parseFloat(f)) && (p += f = parseFloat(f),
        d += f),
        d || p ? (d *= fn,
        p *= fn,
        n = Math.cos(d) * m,
        i = Math.sin(d) * m,
        r = Math.sin(d - p) * -g,
        s = Math.cos(d - p) * g,
        p && (f *= fn,
        o = Math.tan(p - f),
        r *= o = Math.sqrt(1 + o * o),
        s *= o,
        f && (o = Math.tan(f),
        n *= o = Math.sqrt(1 + o * o),
        i *= o)),
        n = lt(n),
        i = lt(i),
        r = lt(r),
        s = lt(s)) : (n = m,
        s = g,
        i = r = 0),
        (M && !~(h + "").indexOf("px") || S && !~(u + "").indexOf("px")) && (M = Xn(v, "x", h, "px"),
        S = Xn(v, "y", u, "px")),
        (y || _ || x || b) && (M = lt(M + y - (y * n + _ * r) + x),
        S = lt(S + _ - (y * i + _ * s) + b)),
        (l || c) && (o = v.getBBox(),
        M = lt(M + l / 100 * o.width),
        S = lt(S + c / 100 * o.height)),
        o = "matrix(" + n + "," + i + "," + r + "," + s + "," + M + "," + S + ")",
        v.setAttribute("transform", o),
        w && (v.style[Dn] = o)
    }, fi = function(t, e, n, i, r, s) {
        var o, a, l = 360, c = E(r), h = parseFloat(r) * (c && ~r.indexOf("rad") ? pn : 1), u = s ? h * s : h - i, d = i + u + "deg";
        return c && ("short" === (o = r.split("_")[1]) && (u %= l) != u % 180 && (u += u < 0 ? l : -360),
        "cw" === o && u < 0 ? u = (u + 36e9) % l - ~~(u / l) * l : "ccw" === o && u > 0 && (u = (u - 36e9) % l - ~~(u / l) * l)),
        t._pt = a = new $e(t._pt,e,n,i,u,bn),
        a.e = d,
        a.u = "deg",
        t._props.push(n),
        a
    }, mi = function(t, e) {
        for (var n in e)
            t[n] = e[n];
        return t
    }, gi = function(t, e, n) {
        var i, r, s, o, a, l, c, h = mi({}, n._gsap), u = n.style;
        for (r in h.svg ? (s = n.getAttribute("transform"),
        n.setAttribute("transform", ""),
        u[Dn] = e,
        i = si(n, 1),
        Gn(n, Dn),
        n.setAttribute("transform", s)) : (s = getComputedStyle(n)[Dn],
        u[Dn] = e,
        i = si(n, 1),
        u[Dn] = s),
        dn)
            (s = h[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Gt(s) !== (c = Gt(o)) ? Xn(n, r, s, c) : parseFloat(s),
            l = parseFloat(o),
            t._pt = new $e(t._pt,i,r,a,l - a,xn),
            t._pt.u = c || 0,
            t._props.push(r));
        mi(i, h)
    };
    at("padding,margin,Width,Radius", (function(t, e) {
        var n = "Top"
          , i = "Right"
          , r = "Bottom"
          , s = "Left"
          , o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function(n) {
            return e < 2 ? t + n : "border" + n + t
        }
        ));
        Qn[e > 1 ? "border" + t : t] = function(t, e, n, i, r) {
            var s, a;
            if (arguments.length < 4)
                return s = o.map((function(e) {
                    return qn(t, e, n)
                }
                )),
                5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
            s = (i + "").split(" "),
            a = {},
            o.forEach((function(t, e) {
                return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
            }
            )),
            t.init(e, a, r)
        }
    }
    ));
    var vi, yi, _i = {
        name: "css",
        register: Bn,
        targetTest: function(t) {
            return t.style && t.nodeType
        },
        init: function(t, e, n, i, r) {
            var s, o, a, l, c, h, u, d, p, f, m, v, y, _, x, b = this._props, w = t.style, M = n.vars.startAt;
            for (u in ln || Bn(),
            e)
                if ("autoRound" !== u && (o = e[u],
                !$[u] || !Ie(u, e, n, i, t, r)))
                    if (c = typeof o,
                    h = Qn[u],
                    "function" === c && (c = typeof (o = o.call(n, i, t, r))),
                    "string" === c && ~o.indexOf("random(") && (o = $t(o)),
                    h)
                        h(this, t, u, o, n) && (x = 1);
                    else if ("--" === u.substr(0, 2))
                        s = (getComputedStyle(t).getPropertyValue(u) + "").trim(),
                        o += "",
                        ue.lastIndex = 0,
                        ue.test(s) || (d = Gt(s),
                        p = Gt(o)),
                        p ? d !== p && (s = Xn(t, u, s, p) + p) : d && (o += d),
                        this.add(w, "setProperty", s, o, i, r, 0, 0, u),
                        b.push(u);
                    else if ("undefined" !== c) {
                        if (M && u in M ? (s = "function" == typeof M[u] ? M[u].call(n, i, t, r) : M[u],
                        E(s) && ~s.indexOf("random(") && (s = $t(s)),
                        Gt(s + "") || (s += g.units[u] || Gt(qn(t, u)) || ""),
                        "=" === (s + "").charAt(1) && (s = qn(t, u))) : s = qn(t, u),
                        l = parseFloat(s),
                        (f = "string" === c && "=" === o.charAt(1) ? +(o.charAt(0) + "1") : 0) && (o = o.substr(2)),
                        a = parseFloat(o),
                        u in _n && ("autoAlpha" === u && (1 === l && "hidden" === qn(t, "visibility") && a && (l = 0),
                        Wn(this, w, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)),
                        "scale" !== u && "transform" !== u && ~(u = _n[u]).indexOf(",") && (u = u.split(",")[0])),
                        m = u in dn)
                            if (v || ((y = t._gsap).renderTransform && !e.parseTransform || si(t, e.parseTransform),
                            _ = !1 !== e.smoothOrigin && y.smooth,
                            (v = this._pt = new $e(this._pt,w,Dn,0,1,y.renderTransform,y,0,-1)).dep = 1),
                            "scale" === u)
                                this._pt = new $e(this._pt,y,"scaleY",y.scaleY,(f ? f * a : a - y.scaleY) || 0),
                                b.push("scaleY", u),
                                u += "X";
                            else {
                                if ("transformOrigin" === u) {
                                    o = Jn(o),
                                    y.svg ? ri(t, o, 0, _, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== y.zOrigin && Wn(this, y, "zOrigin", y.zOrigin, p),
                                    Wn(this, w, u, oi(s), oi(o)));
                                    continue
                                }
                                if ("svgOrigin" === u) {
                                    ri(t, o, 1, _, 0, this);
                                    continue
                                }
                                if (u in ti) {
                                    fi(this, y, u, l, o, f);
                                    continue
                                }
                                if ("smoothOrigin" === u) {
                                    Wn(this, y, "smooth", y.smooth, o);
                                    continue
                                }
                                if ("force3D" === u) {
                                    y[u] = o;
                                    continue
                                }
                                if ("transform" === u) {
                                    gi(this, o, t);
                                    continue
                                }
                            }
                        else
                            u in w || (u = zn(u) || u);
                        if (m || (a || 0 === a) && (l || 0 === l) && !yn.test(o) && u in w)
                            a || (a = 0),
                            (d = (s + "").substr((l + "").length)) !== (p = Gt(o) || (u in g.units ? g.units[u] : d)) && (l = Xn(t, u, s, p)),
                            this._pt = new $e(this._pt,m ? y : w,u,l,f ? f * a : a - l,m || "px" !== p && "zIndex" !== u || !1 === e.autoRound ? xn : Mn),
                            this._pt.u = p || 0,
                            d !== p && "%" !== p && (this._pt.b = s,
                            this._pt.r = wn);
                        else if (u in w)
                            Yn.call(this, t, u, s, o);
                        else {
                            if (!(u in t)) {
                                X(u, o);
                                continue
                            }
                            this.add(t, u, s || t[u], o, i, r)
                        }
                        b.push(u)
                    }
            x && Qe(this)
        },
        get: qn,
        aliases: _n,
        getSetter: function(t, e, n) {
            var i = _n[e];
            return i && i.indexOf(",") < 0 && (e = i),
            e in dn && e !== In && (t._gsap.x || qn(t, "x")) ? n && hn === n ? "scale" === e ? Ln : Rn : (hn = n || {}) && ("scale" === e ? Cn : Pn) : t.style && !L(t.style[e]) ? En : ~e.indexOf("-") ? An : We(t, e)
        },
        core: {
            _removeProperty: Gn,
            _getMatrix: ii
        }
    };
    rn.utils.checkPrefix = zn,
    yi = at("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (vi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
        dn[t] = 1
    }
    )),
    at(vi, (function(t) {
        g.units[t] = "deg",
        ti[t] = 1
    }
    )),
    _n[yi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + vi,
    at("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
        var e = t.split(":");
        _n[e[1]] = yi[e[0]]
    }
    )),
    at("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
        g.units[t] = "px"
    }
    )),
    rn.registerPlugin(_i);
    var xi, bi, wi, Mi, Si, Ti, Ei, Ai, Ri, Li, Ci, Pi, Di, Ii, Oi, ki, Ni, zi, Bi, Fi, Ui, Hi, Vi, Gi, Wi, ji, Xi = rn.registerPlugin(_i) || rn, qi = (Xi.core.Tween,
    1), Yi = [], Zi = [], Ji = Date.now, Ki = Ji(), Qi = 0, $i = 1, tr = function(t) {
        return t
    }, er = function(t) {
        return Ri(t)[0] || (ur(t) && !1 !== xi.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
    }, nr = function(t) {
        return Math.round(1e5 * t) / 1e5 || 0
    }, ir = function() {
        return "undefined" != typeof window
    }, rr = function() {
        return xi || ir() && (xi = window.gsap) && xi.registerPlugin && xi
    }, sr = function(t) {
        return !!~Ei.indexOf(t)
    }, or = function(t, e) {
        return ~Yi.indexOf(t) && Yi[Yi.indexOf(t) + 1][e]
    }, ar = function(t, e) {
        var n = e.s
          , i = e.sc
          , r = Zi.indexOf(t)
          , s = i === Cr.sc ? 1 : 2;
        return !~r && (r = Zi.push(t) - 1),
        Zi[r + s] || (Zi[r + s] = or(t, n) || (sr(t) ? i : function(e) {
            return arguments.length ? t[n] = e : t[n]
        }
        ))
    }, lr = function(t) {
        return or(t, "getBoundingClientRect") || (sr(t) ? function() {
            return vs.width = wi.innerWidth,
            vs.height = wi.innerHeight,
            vs
        }
        : function() {
            return Ir(t)
        }
        )
    }, cr = function(t, e) {
        var n = e.s
          , i = e.d2
          , r = e.d
          , s = e.a;
        return (n = "scroll" + i) && (s = or(t, n)) ? s() - lr(t)()[r] : sr(t) ? (Ti[n] || Si[n]) - (wi["inner" + i] || Si["client" + i] || Ti["client" + i]) : t[n] - t["offset" + i]
    }, hr = function(t, e) {
        for (var n = 0; n < Bi.length; n += 3)
            (!e || ~e.indexOf(Bi[n + 1])) && t(Bi[n], Bi[n + 1], Bi[n + 2])
    }, ur = function(t) {
        return "string" == typeof t
    }, dr = function(t) {
        return "function" == typeof t
    }, pr = function(t) {
        return "number" == typeof t
    }, fr = function(t) {
        return "object" == typeof t
    }, mr = function(t) {
        return dr(t) && t()
    }, gr = function(t, e) {
        return function() {
            var n = mr(t)
              , i = mr(e);
            return function() {
                mr(n),
                mr(i)
            }
        }
    }, vr = function(t, e, n) {
        return t && t.progress(e ? 0 : 1) && n && t.pause()
    }, yr = function(t, e) {
        if (t.enabled) {
            var n = e(t);
            n && n.totalTime && (t.callbackAnimation = n)
        }
    }, _r = Math.abs, xr = "left", br = "right", wr = "bottom", Mr = "width", Sr = "height", Tr = "padding", Er = "margin", Ar = "Width", Rr = "px", Lr = {
        s: "scrollLeft",
        p: xr,
        p2: "Left",
        os: br,
        os2: "Right",
        d: Mr,
        d2: Ar,
        a: "x",
        sc: function(t) {
            return arguments.length ? wi.scrollTo(t, Cr.sc()) : wi.pageXOffset || Mi.scrollLeft || Si.scrollLeft || Ti.scrollLeft || 0
        }
    }, Cr = {
        s: "scrollTop",
        p: "top",
        p2: "Top",
        os: wr,
        os2: "Bottom",
        d: Sr,
        d2: "Height",
        a: "y",
        op: Lr,
        sc: function(t) {
            return arguments.length ? wi.scrollTo(Lr.sc(), t) : wi.pageYOffset || Mi.scrollTop || Si.scrollTop || Ti.scrollTop || 0
        }
    }, Pr = function(t) {
        return wi.getComputedStyle(t)
    }, Dr = function(t, e) {
        for (var n in e)
            n in t || (t[n] = e[n]);
        return t
    }, Ir = function(t, e) {
        var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== Pr(t)[Oi] && xi.to(t, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0
        }).progress(1)
          , i = t.getBoundingClientRect();
        return n && n.progress(0).kill(),
        i
    }, Or = function(t, e) {
        var n = e.d2;
        return t["offset" + n] || t["client" + n] || 0
    }, kr = function(t) {
        var e, n = [], i = t.labels, r = t.duration();
        for (e in i)
            n.push(i[e] / r);
        return n
    }, Nr = function(t) {
        var e = xi.utils.snap(t)
          , n = Array.isArray(t) && t.slice(0).sort((function(t, e) {
            return t - e
        }
        ));
        return n ? function(t, i, r) {
            var s;
            if (void 0 === r && (r = .001),
            !i)
                return e(t);
            if (i > 0) {
                for (t -= r,
                s = 0; s < n.length; s++)
                    if (n[s] >= t)
                        return n[s];
                return n[s - 1]
            }
            for (s = n.length,
            t += r; s--; )
                if (n[s] <= t)
                    return n[s];
            return n[0]
        }
        : function(n, i, r) {
            void 0 === r && (r = .001);
            var s = e(n);
            return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : e(i < 0 ? n - t : n + t)
        }
    }, zr = function(t, e, n, i) {
        return n.split(",").forEach((function(n) {
            return t(e, n, i)
        }
        ))
    }, Br = function(t, e, n) {
        return t.addEventListener(e, n, {
            passive: !0
        })
    }, Fr = function(t, e, n) {
        return t.removeEventListener(e, n)
    }, Ur = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
    }, Hr = {
        toggleActions: "play",
        anticipatePin: 0
    }, Vr = {
        top: 0,
        left: 0,
        center: .5,
        bottom: 1,
        right: 1
    }, Gr = function(t, e) {
        if (ur(t)) {
            var n = t.indexOf("=")
              , i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
            ~n && (t.indexOf("%") > n && (i *= e / 100),
            t = t.substr(0, n - 1)),
            t = i + (t in Vr ? Vr[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
        }
        return t
    }, Wr = function(t, e, n, i, r, s, o, a) {
        var l = r.startColor
          , c = r.endColor
          , h = r.fontSize
          , u = r.indent
          , d = r.fontWeight
          , p = Mi.createElement("div")
          , f = sr(n) || "fixed" === or(n, "pinType")
          , m = -1 !== t.indexOf("scroller")
          , g = f ? Ti : n
          , v = -1 !== t.indexOf("start")
          , y = v ? l : c
          , _ = "border-color:" + y + ";font-size:" + h + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return _ += "position:" + ((m || a) && f ? "fixed;" : "absolute;"),
        (m || a || !f) && (_ += (i === Cr ? br : wr) + ":" + (s + parseFloat(u)) + "px;"),
        o && (_ += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"),
        p._isStart = v,
        p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
        p.style.cssText = _,
        p.innerText = e || 0 === e ? t + "-" + e : t,
        g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
        p._offset = p["offset" + i.op.d2],
        jr(p, 0, i, v),
        p
    }, jr = function(t, e, n, i) {
        var r = {
            display: "block"
        }
          , s = n[i ? "os2" : "p2"]
          , o = n[i ? "p2" : "os2"];
        t._isFlipped = i,
        r[n.a + "Percent"] = i ? -100 : 0,
        r[n.a] = i ? "1px" : 0,
        r["border" + s + Ar] = 1,
        r["border" + o + Ar] = 0,
        r[n.p] = e + "px",
        xi.set(t, r)
    }, Xr = [], qr = {}, Yr = function() {
        return Ji() - Qi > 34 && hs()
    }, Zr = function() {
        hs(),
        Qi || ns("scrollStart"),
        Qi = Ji()
    }, Jr = function() {
        return !Di && !Hi && !Mi.fullscreenElement && Ai.restart(!0)
    }, Kr = {}, Qr = [], $r = [], ts = function(t) {
        var e, n = xi.ticker.frame, i = [], r = 0;
        if (Wi !== n || qi) {
            for (ss(); r < $r.length; r += 4)
                (e = wi.matchMedia($r[r]).matches) !== $r[r + 3] && ($r[r + 3] = e,
                e ? i.push(r) : ss(1, $r[r]) || dr($r[r + 2]) && $r[r + 2]());
            for (rs(),
            r = 0; r < i.length; r++)
                e = i[r],
                Gi = $r[e],
                $r[e + 2] = $r[e + 1](t);
            Gi = 0,
            bi && as(0, 1),
            Wi = n,
            ns("matchMedia")
        }
    }, es = function t() {
        return Fr(ws, "scrollEnd", t) || as(!0)
    }, ns = function(t) {
        return Kr[t] && Kr[t].map((function(t) {
            return t()
        }
        )) || Qr
    }, is = [], rs = function(t) {
        for (var e = 0; e < is.length; e += 5)
            t && is[e + 4] !== t || (is[e].style.cssText = is[e + 1],
            is[e].getBBox && is[e].setAttribute("transform", is[e + 2] || ""),
            is[e + 3].uncache = 1)
    }, ss = function(t, e) {
        var n;
        for (ki = 0; ki < Xr.length; ki++)
            n = Xr[ki],
            e && n.media !== e || (t ? n.kill(1) : n.revert());
        e && rs(e),
        e || ns("revert")
    }, os = function() {
        return Zi.forEach((function(t) {
            return "function" == typeof t && (t.rec = 0)
        }
        ))
    }, as = function(t, e) {
        if (!Qi || t) {
            ji = !0;
            var n = ns("refreshInit");
            Fi && ws.sort(),
            e || ss(),
            Xr.forEach((function(t) {
                return t.refresh()
            }
            )),
            Xr.forEach((function(t) {
                return "max" === t.vars.end && t.setPositions(t.start, cr(t.scroller, t._dir))
            }
            )),
            n.forEach((function(t) {
                return t && t.render && t.render(-1)
            }
            )),
            os(),
            Ai.pause(),
            ji = !1,
            ns("refresh")
        } else
            Br(ws, "scrollEnd", es)
    }, ls = 0, cs = 1, hs = function() {
        if (!ji) {
            var t = Xr.length
              , e = Ji()
              , n = e - Ki >= 50
              , i = t && Xr[0].scroll();
            if (cs = ls > i ? -1 : 1,
            ls = i,
            n && (Qi && !Ii && e - Qi > 200 && (Qi = 0,
            ns("scrollEnd")),
            Ci = Ki,
            Ki = e),
            cs < 0) {
                for (ki = t; ki-- > 0; )
                    Xr[ki] && Xr[ki].update(0, n);
                cs = 1
            } else
                for (ki = 0; ki < t; ki++)
                    Xr[ki] && Xr[ki].update(0, n)
        }
    }, us = [xr, "top", wr, br, "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], ds = us.concat([Mr, Sr, "boxSizing", "maxWidth", "maxHeight", "position", Er, Tr, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]), ps = function(t, e, n, i) {
        if (t.parentNode !== e) {
            for (var r, s = us.length, o = e.style, a = t.style; s--; )
                o[r = us[s]] = n[r];
            o.position = "absolute" === n.position ? "absolute" : "relative",
            "inline" === n.display && (o.display = "inline-block"),
            a.bottom = a.right = o.flexBasis = "auto",
            o.overflow = "visible",
            o.boxSizing = "border-box",
            o.width = Or(t, Lr) + Rr,
            o.height = Or(t, Cr) + Rr,
            o.padding = a.margin = a.top = a.left = "0",
            ms(i),
            a.width = a.maxWidth = n.width,
            a.height = a.maxHeight = n.height,
            a.padding = n.padding,
            t.parentNode.insertBefore(e, t),
            e.appendChild(t)
        }
    }, fs = /([A-Z])/g, ms = function(t) {
        if (t) {
            var e, n, i = t.t.style, r = t.length, s = 0;
            for ((t.t._gsap || xi.core.getCache(t.t)).uncache = 1; s < r; s += 2)
                n = t[s + 1],
                e = t[s],
                n ? i[e] = n : i[e] && i.removeProperty(e.replace(fs, "-$1").toLowerCase())
        }
    }, gs = function(t) {
        for (var e = ds.length, n = t.style, i = [], r = 0; r < e; r++)
            i.push(ds[r], n[ds[r]]);
        return i.t = t,
        i
    }, vs = {
        left: 0,
        top: 0
    }, ys = function(t, e, n, i, r, s, o, a, l, c, h, u, d) {
        dr(t) && (t = t(a)),
        ur(t) && "max" === t.substr(0, 3) && (t = u + ("=" === t.charAt(4) ? Gr("0" + t.substr(3), n) : 0));
        var p, f, m, g = d ? d.time() : 0;
        if (d && d.seek(0),
        pr(t))
            o && jr(o, n, i, !0);
        else {
            dr(e) && (e = e(a));
            var v, y, _, x, b = t.split(" ");
            m = er(e) || Ti,
            (v = Ir(m) || {}) && (v.left || v.top) || "none" !== Pr(m).display || (x = m.style.display,
            m.style.display = "block",
            v = Ir(m),
            x ? m.style.display = x : m.style.removeProperty("display")),
            y = Gr(b[0], v[i.d]),
            _ = Gr(b[1] || "0", n),
            t = v[i.p] - l[i.p] - c + y + r - _,
            o && jr(o, _, i, n - _ < 20 || o._isStart && _ > 20),
            n -= n - _
        }
        if (s) {
            var w = t + n
              , M = s._isStart;
            p = "scroll" + i.d2,
            jr(s, w, i, M && w > 20 || !M && (h ? Math.max(Ti[p], Si[p]) : s.parentNode[p]) <= w + 1),
            h && (l = Ir(o),
            h && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + Rr))
        }
        return d && m && (p = Ir(m),
        d.seek(u),
        f = Ir(m),
        d._caScrollDist = p[i.p] - f[i.p],
        t = t / d._caScrollDist * u),
        d && d.seek(g),
        d ? t : Math.round(t)
    }, _s = /(?:webkit|moz|length|cssText|inset)/i, xs = function(t, e, n, i) {
        if (t.parentNode !== e) {
            var r, s, o = t.style;
            if (e === Ti) {
                for (r in t._stOrig = o.cssText,
                s = Pr(t))
                    +r || _s.test(r) || !s[r] || "string" != typeof o[r] || "0" === r || (o[r] = s[r]);
                o.top = n,
                o.left = i
            } else
                o.cssText = t._stOrig;
            xi.core.getCache(t).uncache = 1,
            e.appendChild(t)
        }
    }, bs = function(t, e) {
        var n, i, r = ar(t, e), s = "_scroll" + e.p2, o = function e(o, a, l, c, h) {
            var u = e.tween
              , d = a.onComplete
              , p = {};
            return u && u.kill(),
            n = Math.round(l),
            a[s] = o,
            a.modifiers = p,
            p[s] = function(t) {
                return (t = nr(r())) !== n && t !== i && Math.abs(t - n) > 2 && Math.abs(t - i) > 2 ? (u.kill(),
                e.tween = 0) : t = l + c * u.ratio + h * u.ratio * u.ratio,
                i = n,
                n = nr(t)
            }
            ,
            a.onComplete = function() {
                e.tween = 0,
                d && d.call(u)
            }
            ,
            u = e.tween = xi.to(t, a)
        };
        return t[s] = r,
        Br(t, "wheel", (function() {
            return o.tween && o.tween.kill() && (o.tween = 0)
        }
        )),
        o
    };
    Lr.op = Cr;
    var ws = function() {
        function t(e, n) {
            bi || t.register(xi) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
            this.init(e, n)
        }
        return t.prototype.init = function(e, n) {
            if (this.progress = this.start = 0,
            this.vars && this.kill(1),
            $i) {
                var i, r, s, o, a, l, c, h, u, d, p, f, m, g, v, y, _, x, b, w, M, S, T, E, A, R, L, C, P, D, I, O, k, N, z, B, F, U, H, V, G = e = Dr(ur(e) || pr(e) || e.nodeType ? {
                    trigger: e
                } : e, Hr), W = G.onUpdate, j = G.toggleClass, X = G.id, q = G.onToggle, Y = G.onRefresh, Z = G.scrub, J = G.trigger, K = G.pin, Q = G.pinSpacing, $ = G.invalidateOnRefresh, tt = G.anticipatePin, et = G.onScrubComplete, nt = G.onSnapComplete, it = G.once, rt = G.snap, st = G.pinReparent, ot = G.pinSpacer, at = G.containerAnimation, lt = G.fastScrollEnd, ct = G.preventOverlaps, ht = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? Lr : Cr, ut = !Z && 0 !== Z, dt = er(e.scroller || wi), pt = xi.core.getCache(dt), ft = sr(dt), mt = "fixed" === ("pinType"in e ? e.pinType : or(dt, "pinType") || ft && "fixed"), gt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], vt = ut && e.toggleActions.split(" "), yt = "markers"in e ? e.markers : Hr.markers, _t = ft ? 0 : parseFloat(Pr(dt)["border" + ht.p2 + Ar]) || 0, xt = this, bt = e.onRefreshInit && function() {
                    return e.onRefreshInit(xt)
                }
                , wt = function(t, e, n) {
                    var i = n.d
                      , r = n.d2
                      , s = n.a;
                    return (s = or(t, "getBoundingClientRect")) ? function() {
                        return s()[i]
                    }
                    : function() {
                        return (e ? wi["inner" + r] : t["client" + r]) || 0
                    }
                }(dt, ft, ht), Mt = function(t, e) {
                    return !e || ~Yi.indexOf(t) ? lr(t) : function() {
                        return vs
                    }
                }(dt, ft), St = 0, Tt = ar(dt, ht);
                if (xt.media = Gi,
                xt._dir = ht,
                tt *= 45,
                xt.scroller = dt,
                xt.scroll = at ? at.time.bind(at) : Tt,
                o = Tt(),
                xt.vars = e,
                n = n || e.animation,
                "refreshPriority"in e && (Fi = 1),
                pt.tweenScroll = pt.tweenScroll || {
                    top: bs(dt, Cr),
                    left: bs(dt, Lr)
                },
                xt.tweenTo = i = pt.tweenScroll[ht.p],
                n && (n.vars.lazy = !1,
                n._initted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.render(0, !0, !0),
                xt.animation = n.pause(),
                n.scrollTrigger = xt,
                (I = pr(Z) && Z) && (D = xi.to(n, {
                    ease: "power3",
                    duration: I,
                    onComplete: function() {
                        return et && et(xt)
                    }
                })),
                C = 0,
                X || (X = n.vars.id)),
                Xr.push(xt),
                rt && (fr(rt) && !rt.push || (rt = {
                    snapTo: rt
                }),
                "scrollBehavior"in Ti.style && xi.set(ft ? [Ti, Si] : dt, {
                    scrollBehavior: "auto"
                }),
                s = dr(rt.snapTo) ? rt.snapTo : "labels" === rt.snapTo ? function(t) {
                    return function(e) {
                        return xi.utils.snap(kr(t), e)
                    }
                }(n) : "labelsDirectional" === rt.snapTo ? (U = n,
                function(t, e) {
                    return Nr(kr(U))(t, e.direction)
                }
                ) : !1 !== rt.directional ? function(t, e) {
                    return Nr(rt.snapTo)(t, e.direction)
                }
                : xi.utils.snap(rt.snapTo),
                O = rt.duration || {
                    min: .1,
                    max: 2
                },
                O = fr(O) ? Li(O.min, O.max) : Li(O, O),
                k = xi.delayedCall(rt.delay || I / 2 || .1, (function() {
                    if (Math.abs(xt.getVelocity()) < 10 && !Ii && St !== Tt()) {
                        var t = n && !ut ? n.totalProgress() : xt.progress
                          , e = (t - P) / (Ji() - Ci) * 1e3 || 0
                          , r = xi.utils.clamp(-xt.progress, 1 - xt.progress, _r(e / 2) * e / .185)
                          , o = xt.progress + (!1 === rt.inertia ? 0 : r)
                          , a = Li(0, 1, s(o, xt))
                          , h = Tt()
                          , u = Math.round(l + a * m)
                          , d = rt
                          , p = d.onStart
                          , f = d.onInterrupt
                          , g = d.onComplete
                          , v = i.tween;
                        if (h <= c && h >= l && u !== h) {
                            if (v && !v._initted && v.data <= _r(u - h))
                                return;
                            !1 === rt.inertia && (r = a - xt.progress),
                            i(u, {
                                duration: O(_r(.185 * Math.max(_r(o - t), _r(a - t)) / e / .05 || 0)),
                                ease: rt.ease || "power3",
                                data: _r(u - h),
                                onInterrupt: function() {
                                    return k.restart(!0) && f && f(xt)
                                },
                                onComplete: function() {
                                    xt.update(),
                                    St = Tt(),
                                    C = P = n && !ut ? n.totalProgress() : xt.progress,
                                    nt && nt(xt),
                                    g && g(xt)
                                }
                            }, h, r * m, u - h - r * m),
                            p && p(xt, i.tween)
                        }
                    } else
                        xt.isActive && k.restart(!0)
                }
                )).pause()),
                X && (qr[X] = xt),
                J = xt.trigger = er(J || K),
                K = !0 === K ? J : er(K),
                ur(j) && (j = {
                    targets: J,
                    className: j
                }),
                K && (!1 === Q || Q === Er || (Q = !(!Q && "flex" === Pr(K.parentNode).display) && Tr),
                xt.pin = K,
                !1 !== e.force3D && xi.set(K, {
                    force3D: !0
                }),
                (r = xi.core.getCache(K)).spacer ? g = r.pinState : (ot && ((ot = er(ot)) && !ot.nodeType && (ot = ot.current || ot.nativeElement),
                r.spacerIsNative = !!ot,
                ot && (r.spacerState = gs(ot))),
                r.spacer = _ = ot || Mi.createElement("div"),
                _.classList.add("pin-spacer"),
                X && _.classList.add("pin-spacer-" + X),
                r.pinState = g = gs(K)),
                xt.spacer = _ = r.spacer,
                L = Pr(K),
                T = L[Q + ht.os2],
                b = xi.getProperty(K),
                w = xi.quickSetter(K, ht.a, Rr),
                ps(K, _, L),
                y = gs(K)),
                yt && (f = fr(yt) ? Dr(yt, Ur) : Ur,
                d = Wr("scroller-start", X, dt, ht, f, 0),
                p = Wr("scroller-end", X, dt, ht, f, 0, d),
                x = d["offset" + ht.op.d2],
                h = Wr("start", X, dt, ht, f, x, 0, at),
                u = Wr("end", X, dt, ht, f, x, 0, at),
                at && (F = xi.quickSetter([h, u], ht.a, Rr)),
                mt || Yi.length && !0 === or(dt, "fixedMarkers") || (V = Pr(H = ft ? Ti : dt).position,
                H.style.position = "absolute" === V || "fixed" === V ? V : "relative",
                xi.set([d, p], {
                    force3D: !0
                }),
                A = xi.quickSetter(d, ht.a, Rr),
                R = xi.quickSetter(p, ht.a, Rr))),
                at) {
                    var Et = at.vars.onUpdate
                      , At = at.vars.onUpdateParams;
                    at.eventCallback("onUpdate", (function() {
                        xt.update(0, 0, 1),
                        Et && Et.apply(At || [])
                    }
                    ))
                }
                xt.previous = function() {
                    return Xr[Xr.indexOf(xt) - 1]
                }
                ,
                xt.next = function() {
                    return Xr[Xr.indexOf(xt) + 1]
                }
                ,
                xt.revert = function(t) {
                    var e = !1 !== t || !xt.enabled
                      , i = Di;
                    e !== xt.isReverted && (e && (xt.scroll.rec || (xt.scroll.rec = Tt()),
                    z = Math.max(Tt(), xt.scroll.rec || 0),
                    N = xt.progress,
                    B = n && n.progress()),
                    h && [h, u, d, p].forEach((function(t) {
                        return t.style.display = e ? "none" : "block"
                    }
                    )),
                    e && (Di = 1),
                    xt.update(e),
                    Di = i,
                    K && (e ? function(t, e, n) {
                        ms(n);
                        var i = t._gsap;
                        if (i.spacerIsNative)
                            ms(i.spacerState);
                        else if (t.parentNode === e) {
                            var r = e.parentNode;
                            r && (r.insertBefore(t, e),
                            r.removeChild(e))
                        }
                    }(K, _, g) : (!st || !xt.isActive) && ps(K, _, Pr(K), E)),
                    xt.isReverted = e)
                }
                ,
                xt.refresh = function(i, r) {
                    if (!Di && xt.enabled || r)
                        if (K && i && Qi)
                            Br(t, "scrollEnd", es);
                        else {
                            Di = 1,
                            D && D.pause(),
                            $ && n && n.time(-.01, !0).invalidate(),
                            xt.isReverted || xt.revert();
                            for (var s, f, x, w, T, A, R, L, C, P, I = wt(), O = Mt(), k = at ? at.duration() : cr(dt, ht), F = 0, U = 0, H = e.end, V = e.endTrigger || J, G = e.start || (0 !== e.start && J ? K ? "0 0" : "0 100%" : 0), W = e.pinnedContainer && er(e.pinnedContainer), j = J && Math.max(0, Xr.indexOf(xt)) || 0, X = j; X--; )
                                (A = Xr[X]).end || A.refresh(0, 1) || (Di = 1),
                                !(R = A.pin) || R !== J && R !== K || A.isReverted || (P || (P = []),
                                P.unshift(A),
                                A.revert());
                            for (dr(G) && (G = G(xt)),
                            l = ys(G, J, I, ht, Tt(), h, d, xt, O, _t, mt, k, at) || (K ? -.001 : 0),
                            dr(H) && (H = H(xt)),
                            ur(H) && !H.indexOf("+=") && (~H.indexOf(" ") ? H = (ur(G) ? G.split(" ")[0] : "") + H : (F = Gr(H.substr(2), I),
                            H = ur(G) ? G : l + F,
                            V = J)),
                            c = Math.max(l, ys(H || (V ? "100% 0" : k), V, I, ht, Tt() + F, u, p, xt, O, _t, mt, k, at)) || -.001,
                            m = c - l || (l -= .01) && .001,
                            F = 0,
                            X = j; X--; )
                                (R = (A = Xr[X]).pin) && A.start - A._pinPush < l && !at && (s = A.end - A.start,
                                R !== J && R !== W || pr(G) || (F += s * (1 - A.progress)),
                                R === K && (U += s));
                            if (l += F,
                            c += F,
                            xt._pinPush = U,
                            h && F && ((s = {})[ht.a] = "+=" + F,
                            W && (s[ht.p] = "-=" + Tt()),
                            xi.set([h, u], s)),
                            K)
                                s = Pr(K),
                                w = ht === Cr,
                                x = Tt(),
                                M = parseFloat(b(ht.a)) + U,
                                !k && c > 1 && ((ft ? Ti : dt).style["overflow-" + ht.a] = "scroll"),
                                ps(K, _, s),
                                y = gs(K),
                                f = Ir(K, !0),
                                L = mt && ar(dt, w ? Lr : Cr)(),
                                Q && ((E = [Q + ht.os2, m + U + Rr]).t = _,
                                (X = Q === Tr ? Or(K, ht) + m + U : 0) && E.push(ht.d, X + Rr),
                                ms(E),
                                mt && Tt(z)),
                                mt && ((T = {
                                    top: f.top + (w ? x - l : L) + Rr,
                                    left: f.left + (w ? L : x - l) + Rr,
                                    boxSizing: "border-box",
                                    position: "fixed"
                                }).width = T.maxWidth = Math.ceil(f.width) + Rr,
                                T.height = T.maxHeight = Math.ceil(f.height) + Rr,
                                T.margin = T.marginTop = T.marginRight = T.marginBottom = T.marginLeft = "0",
                                T.padding = s.padding,
                                T.paddingTop = s.paddingTop,
                                T.paddingRight = s.paddingRight,
                                T.paddingBottom = s.paddingBottom,
                                T.paddingLeft = s.paddingLeft,
                                v = function(t, e, n) {
                                    for (var i, r = [], s = t.length, o = n ? 8 : 0; o < s; o += 2)
                                        i = t[o],
                                        r.push(i, i in e ? e[i] : t[o + 1]);
                                    return r.t = t.t,
                                    r
                                }(g, T, st)),
                                n ? (C = n._initted,
                                Ui(1),
                                n.render(n.duration(), !0, !0),
                                S = b(ht.a) - M + m + U,
                                m !== S && v.splice(v.length - 2, 2),
                                n.render(0, !0, !0),
                                C || n.invalidate(),
                                Ui(0)) : S = m;
                            else if (J && Tt() && !at)
                                for (f = J.parentNode; f && f !== Ti; )
                                    f._pinOffset && (l -= f._pinOffset,
                                    c -= f._pinOffset),
                                    f = f.parentNode;
                            P && P.forEach((function(t) {
                                return t.revert(!1)
                            }
                            )),
                            xt.start = l,
                            xt.end = c,
                            o = a = Tt(),
                            at || (o < z && Tt(z),
                            xt.scroll.rec = 0),
                            xt.revert(!1),
                            Di = 0,
                            n && ut && n._initted && n.progress() !== B && n.progress(B, !0).render(n.time(), !0, !0),
                            (N !== xt.progress || at) && (n && !ut && n.totalProgress(N, !0),
                            xt.progress = N,
                            xt.update(0, 0, 1)),
                            K && Q && (_._pinOffset = Math.round(xt.progress * S)),
                            Y && Y(xt)
                        }
                }
                ,
                xt.getVelocity = function() {
                    return (Tt() - a) / (Ji() - Ci) * 1e3 || 0
                }
                ,
                xt.endAnimation = function() {
                    vr(xt.callbackAnimation),
                    n && (D ? D.progress(1) : n.paused() ? ut || vr(n, xt.direction < 0, 1) : vr(n, n.reversed()))
                }
                ,
                xt.labelToScroll = function(t) {
                    return n && n.labels && (l || xt.refresh() || l) + n.labels[t] / n.duration() * m || 0
                }
                ,
                xt.getTrailing = function(t) {
                    var e = Xr.indexOf(xt)
                      , n = xt.direction > 0 ? Xr.slice(0, e).reverse() : Xr.slice(e + 1);
                    return ur(t) ? n.filter((function(e) {
                        return e.vars.preventOverlaps === t
                    }
                    )) : n
                }
                ,
                xt.update = function(t, e, r) {
                    if (!at || r || t) {
                        var s, h, u, p, f, g, x, b = xt.scroll(), E = t ? 0 : (b - l) / m, L = E < 0 ? 0 : E > 1 ? 1 : E || 0, I = xt.progress;
                        if (e && (a = o,
                        o = at ? Tt() : b,
                        rt && (P = C,
                        C = n && !ut ? n.totalProgress() : L)),
                        tt && !L && K && !Di && !qi && Qi && l < b + (b - a) / (Ji() - Ci) * tt && (L = 1e-4),
                        L !== I && xt.enabled) {
                            if (p = (f = (s = xt.isActive = !!L && L < 1) != (!!I && I < 1)) || !!L != !!I,
                            xt.direction = L > I ? 1 : -1,
                            xt.progress = L,
                            p && !Di && (h = L && !I ? 0 : 1 === L ? 1 : 1 === I ? 2 : 3,
                            ut && (u = !f && "none" !== vt[h + 1] && vt[h + 1] || vt[h],
                            x = n && ("complete" === u || "reset" === u || u in n))),
                            ct && f && (x || Z || !n) && (dr(ct) ? ct(xt) : xt.getTrailing(ct).forEach((function(t) {
                                return t.endAnimation()
                            }
                            ))),
                            ut || (!D || Di || qi ? n && n.totalProgress(L, !!Di) : (D.vars.totalProgress = L,
                            D.invalidate().restart())),
                            K)
                                if (t && Q && (_.style[Q + ht.os2] = T),
                                mt) {
                                    if (p) {
                                        if (g = !t && L > I && c + 1 > b && b + 1 >= cr(dt, ht),
                                        st)
                                            if (t || !s && !g)
                                                xs(K, _);
                                            else {
                                                var O = Ir(K, !0)
                                                  , N = b - l;
                                                xs(K, Ti, O.top + (ht === Cr ? N : 0) + Rr, O.left + (ht === Cr ? 0 : N) + Rr)
                                            }
                                        ms(s || g ? v : y),
                                        S !== m && L < 1 && s || w(M + (1 !== L || g ? 0 : S))
                                    }
                                } else
                                    w(M + S * L);
                            rt && !i.tween && !Di && !qi && k.restart(!0),
                            j && (f || it && L && (L < 1 || !Vi)) && Ri(j.targets).forEach((function(t) {
                                return t.classList[s || it ? "add" : "remove"](j.className)
                            }
                            )),
                            W && !ut && !t && W(xt),
                            p && !Di ? (ut && (x && ("complete" === u ? n.pause().totalProgress(1) : "reset" === u ? n.restart(!0).pause() : "restart" === u ? n.restart(!0) : n[u]()),
                            W && W(xt)),
                            !f && Vi || (q && f && yr(xt, q),
                            gt[h] && yr(xt, gt[h]),
                            it && (1 === L ? xt.kill(!1, 1) : gt[h] = 0),
                            f || gt[h = 1 === L ? 1 : 3] && yr(xt, gt[h])),
                            lt && !s && Math.abs(xt.getVelocity()) > (pr(lt) ? lt : 2500) && (vr(xt.callbackAnimation),
                            D ? D.progress(1) : vr(n, !L, 1))) : ut && W && !Di && W(xt)
                        }
                        if (R) {
                            var z = at ? b / at.duration() * (at._caScrollDist || 0) : b;
                            A(z + (d._isFlipped ? 1 : 0)),
                            R(z)
                        }
                        F && F(-b / at.duration() * (at._caScrollDist || 0))
                    }
                }
                ,
                xt.enable = function(e, n) {
                    xt.enabled || (xt.enabled = !0,
                    Br(dt, "resize", Jr),
                    Br(dt, "scroll", Zr),
                    bt && Br(t, "refreshInit", bt),
                    !1 !== e && (xt.progress = N = 0,
                    o = a = St = Tt()),
                    !1 !== n && xt.refresh())
                }
                ,
                xt.getTween = function(t) {
                    return t && i ? i.tween : D
                }
                ,
                xt.setPositions = function(t, e) {
                    K && (M += t - l,
                    S += e - t - m),
                    xt.start = l = t,
                    xt.end = c = e,
                    m = e - t,
                    xt.update()
                }
                ,
                xt.disable = function(e, n) {
                    if (xt.enabled && (!1 !== e && xt.revert(),
                    xt.enabled = xt.isActive = !1,
                    n || D && D.pause(),
                    z = 0,
                    r && (r.uncache = 1),
                    bt && Fr(t, "refreshInit", bt),
                    k && (k.pause(),
                    i.tween && i.tween.kill() && (i.tween = 0)),
                    !ft)) {
                        for (var s = Xr.length; s--; )
                            if (Xr[s].scroller === dt && Xr[s] !== xt)
                                return;
                        Fr(dt, "resize", Jr),
                        Fr(dt, "scroll", Zr)
                    }
                }
                ,
                xt.kill = function(t, e) {
                    xt.disable(t, e),
                    D && D.kill(),
                    X && delete qr[X];
                    var i = Xr.indexOf(xt);
                    i >= 0 && Xr.splice(i, 1),
                    i === ki && cs > 0 && ki--,
                    i = 0,
                    Xr.forEach((function(t) {
                        return t.scroller === xt.scroller && (i = 1)
                    }
                    )),
                    i || (xt.scroll.rec = 0),
                    n && (n.scrollTrigger = null,
                    t && n.render(-1),
                    e || n.kill()),
                    h && [h, u, d, p].forEach((function(t) {
                        return t.parentNode && t.parentNode.removeChild(t)
                    }
                    )),
                    K && (r && (r.uncache = 1),
                    i = 0,
                    Xr.forEach((function(t) {
                        return t.pin === K && i++
                    }
                    )),
                    i || (r.spacer = 0))
                }
                ,
                xt.enable(!1, !1),
                n && n.add && !m ? xi.delayedCall(.01, (function() {
                    return l || c || xt.refresh()
                }
                )) && (m = .01) && (l = c = 0) : xt.refresh()
            } else
                this.update = this.refresh = this.kill = tr
        }
        ,
        t.register = function(e) {
            if (!bi && (xi = e || rr(),
            ir() && window.document && (wi = window,
            Mi = document,
            Si = Mi.documentElement,
            Ti = Mi.body),
            xi && (Ri = xi.utils.toArray,
            Li = xi.utils.clamp,
            Ui = xi.core.suppressOverwrites || tr,
            xi.core.globals("ScrollTrigger", t),
            Ti))) {
                Br(wi, "wheel", Zr),
                Ei = [wi, Mi, Si, Ti],
                Br(Mi, "scroll", Zr);
                var n, i = Ti.style, r = i.borderTopStyle;
                i.borderTopStyle = "solid",
                n = Ir(Ti),
                Cr.m = Math.round(n.top + Cr.sc()) || 0,
                Lr.m = Math.round(n.left + Lr.sc()) || 0,
                r ? i.borderTopStyle = r : i.removeProperty("border-top-style"),
                Pi = setInterval(Yr, 200),
                xi.delayedCall(.5, (function() {
                    return qi = 0
                }
                )),
                Br(Mi, "touchcancel", tr),
                Br(Ti, "touchstart", tr),
                zr(Br, Mi, "pointerdown,touchstart,mousedown", (function() {
                    return Ii = 1
                }
                )),
                zr(Br, Mi, "pointerup,touchend,mouseup", (function() {
                    return Ii = 0
                }
                )),
                Oi = xi.utils.checkPrefix("transform"),
                ds.push(Oi),
                bi = Ji(),
                Ai = xi.delayedCall(.2, as).pause(),
                Bi = [Mi, "visibilitychange", function() {
                    var t = wi.innerWidth
                      , e = wi.innerHeight;
                    Mi.hidden ? (Ni = t,
                    zi = e) : Ni === t && zi === e || Jr()
                }
                , Mi, "DOMContentLoaded", as, wi, "load", function() {
                    return Qi || as()
                }
                , wi, "resize", Jr],
                hr(Br)
            }
            return bi
        }
        ,
        t.defaults = function(t) {
            if (t)
                for (var e in t)
                    Hr[e] = t[e];
            return Hr
        }
        ,
        t.kill = function() {
            $i = 0,
            Xr.slice(0).forEach((function(t) {
                return t.kill(1)
            }
            ))
        }
        ,
        t.config = function(t) {
            "limitCallbacks"in t && (Vi = !!t.limitCallbacks);
            var e = t.syncInterval;
            e && clearInterval(Pi) || (Pi = e) && setInterval(Yr, e),
            "autoRefreshEvents"in t && (hr(Fr) || hr(Br, t.autoRefreshEvents || "none"),
            Hi = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
        }
        ,
        t.scrollerProxy = function(t, e) {
            var n = er(t)
              , i = Zi.indexOf(n)
              , r = sr(n);
            ~i && Zi.splice(i, r ? 6 : 2),
            e && (r ? Yi.unshift(wi, e, Ti, e, Si, e) : Yi.unshift(n, e))
        }
        ,
        t.matchMedia = function(t) {
            var e, n, i, r, s;
            for (n in t)
                i = $r.indexOf(n),
                r = t[n],
                Gi = n,
                "all" === n ? r() : (e = wi.matchMedia(n)) && (e.matches && (s = r()),
                ~i ? ($r[i + 1] = gr($r[i + 1], r),
                $r[i + 2] = gr($r[i + 2], s)) : (i = $r.length,
                $r.push(n, r, s),
                e.addListener ? e.addListener(ts) : e.addEventListener("change", ts)),
                $r[i + 3] = e.matches),
                Gi = 0;
            return $r
        }
        ,
        t.clearMatchMedia = function(t) {
            t || ($r.length = 0),
            (t = $r.indexOf(t)) >= 0 && $r.splice(t, 4)
        }
        ,
        t.isInViewport = function(t, e, n) {
            var i = (ur(t) ? er(t) : t).getBoundingClientRect()
              , r = i[n ? Mr : Sr] * e || 0;
            return n ? i.right - r > 0 && i.left + r < wi.innerWidth : i.bottom - r > 0 && i.top + r < wi.innerHeight
        }
        ,
        t.positionInViewport = function(t, e, n) {
            ur(t) && (t = er(t));
            var i = t.getBoundingClientRect()
              , r = i[n ? Mr : Sr]
              , s = null == e ? r / 2 : e in Vr ? Vr[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
            return n ? (i.left + s) / wi.innerWidth : (i.top + s) / wi.innerHeight
        }
        ,
        t
    }();
    function Ms(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function Ss(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function Ts(t, e, n) {
        return e && Ss(t.prototype, e),
        n && Ss(t, n),
        t
    }
    function Es(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n,
        t
    }
    function As(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter((function(e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable
            }
            ))),
            n.push.apply(n, i)
        }
        return n
    }
    function Rs(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2 ? As(Object(n), !0).forEach((function(e) {
                Es(t, e, n[e])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : As(Object(n)).forEach((function(e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
            }
            ))
        }
        return t
    }
    function Ls(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: !0,
                configurable: !0
            }
        }),
        e && Ps(t, e)
    }
    function Cs(t) {
        return Cs = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        ,
        Cs(t)
    }
    function Ps(t, e) {
        return Ps = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        ,
        Ps(t, e)
    }
    function Ds(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function Is(t, e) {
        return !e || "object" != typeof e && "function" != typeof e ? Ds(t) : e
    }
    function Os(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Cs(t);
            if (e) {
                var r = Cs(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else
                n = i.apply(this, arguments);
            return Is(this, n)
        }
    }
    function ks(t, e, n) {
        return ks = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var i = function(t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Cs(t)); )
                    ;
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        }
        ,
        ks(t, e, n || t)
    }
    function Ns(t, e) {
        return function(t) {
            if (Array.isArray(t))
                return t
        }(t) || function(t, e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) {
                var n = []
                  , i = !0
                  , r = !1
                  , s = void 0;
                try {
                    for (var o, a = t[Symbol.iterator](); !(i = (o = a.next()).done) && (n.push(o.value),
                    !e || n.length !== e); i = !0)
                        ;
                } catch (t) {
                    r = !0,
                    s = t
                } finally {
                    try {
                        i || null == a.return || a.return()
                    } finally {
                        if (r)
                            throw s
                    }
                }
                return n
            }
        }(t, e) || Bs(t, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function zs(t) {
        return function(t) {
            if (Array.isArray(t))
                return Fs(t)
        }(t) || function(t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t))
                return Array.from(t)
        }(t) || Bs(t) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function Bs(t, e) {
        if (t) {
            if ("string" == typeof t)
                return Fs(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            return "Object" === n && t.constructor && (n = t.constructor.name),
            "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Fs(t, e) : void 0
        }
    }
    function Fs(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++)
            i[n] = t[n];
        return i
    }
    ws.version = "3.9.1",
    ws.saveStyles = function(t) {
        return t ? Ri(t).forEach((function(t) {
            if (t && t.style) {
                var e = is.indexOf(t);
                e >= 0 && is.splice(e, 5),
                is.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), xi.core.getCache(t), Gi)
            }
        }
        )) : is
    }
    ,
    ws.revert = function(t, e) {
        return ss(!t, e)
    }
    ,
    ws.create = function(t, e) {
        return new ws(t,e)
    }
    ,
    ws.refresh = function(t) {
        return t ? Jr() : (bi || ws.register()) && as(!0)
    }
    ,
    ws.update = hs,
    ws.clearScrollMemory = os,
    ws.maxScroll = function(t, e) {
        return cr(t, e ? Lr : Cr)
    }
    ,
    ws.getScrollFunc = function(t, e) {
        return ar(er(t), e ? Lr : Cr)
    }
    ,
    ws.getById = function(t) {
        return qr[t]
    }
    ,
    ws.getAll = function() {
        return Xr.slice(0)
    }
    ,
    ws.isScrolling = function() {
        return !!Qi
    }
    ,
    ws.snapDirectional = Nr,
    ws.addEventListener = function(t, e) {
        var n = Kr[t] || (Kr[t] = []);
        ~n.indexOf(e) || n.push(e)
    }
    ,
    ws.removeEventListener = function(t, e) {
        var n = Kr[t]
          , i = n && n.indexOf(e);
        i >= 0 && n.splice(i, 1)
    }
    ,
    ws.batch = function(t, e) {
        var n, i = [], r = {}, s = e.interval || .016, o = e.batchMax || 1e9, a = function(t, e) {
            var n = []
              , i = []
              , r = xi.delayedCall(s, (function() {
                e(n, i),
                n = [],
                i = []
            }
            )).pause();
            return function(t) {
                n.length || r.restart(!0),
                n.push(t.trigger),
                i.push(t),
                o <= n.length && r.progress(1)
            }
        };
        for (n in e)
            r[n] = "on" === n.substr(0, 2) && dr(e[n]) && "onRefreshInit" !== n ? a(0, e[n]) : e[n];
        return dr(o) && (o = o(),
        Br(ws, "refresh", (function() {
            return o = e.batchMax()
        }
        ))),
        Ri(t).forEach((function(t) {
            var e = {};
            for (n in r)
                e[n] = r[n];
            e.trigger = t,
            i.push(ws.create(e))
        }
        )),
        i
    }
    ,
    ws.sort = function(t) {
        return Xr.sort(t || function(t, e) {
            return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
        }
        )
    }
    ,
    rr() && xi.registerPlugin(ws);
    var Us = {
        el: document,
        name: "scroll",
        offset: [0, 0],
        repeat: !1,
        smooth: !1,
        initPosition: {
            x: 0,
            y: 0
        },
        direction: "vertical",
        gestureDirection: "vertical",
        reloadOnContextChange: !1,
        lerp: .1,
        class: "is-inview",
        scrollbarContainer: !1,
        scrollbarClass: "c-scrollbar",
        scrollingClass: "has-scroll-scrolling",
        draggingClass: "has-scroll-dragging",
        smoothClass: "has-scroll-smooth",
        initClass: "has-scroll-init",
        getSpeed: !1,
        getDirection: !1,
        scrollFromAnywhere: !1,
        multiplier: 1,
        firefoxMultiplier: 50,
        touchMultiplier: 2,
        resetNativeScroll: !0,
        tablet: {
            smooth: !1,
            direction: "vertical",
            gestureDirection: "vertical",
            breakpoint: 1024
        },
        smartphone: {
            smooth: !1,
            direction: "vertical",
            gestureDirection: "vertical"
        }
    }
      , Hs = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            Ms(this, t),
            Object.assign(this, Us, e),
            this.smartphone = Us.smartphone,
            e.smartphone && Object.assign(this.smartphone, e.smartphone),
            this.tablet = Us.tablet,
            e.tablet && Object.assign(this.tablet, e.tablet),
            this.namespace = "locomotive",
            this.html = document.documentElement,
            this.windowHeight = window.innerHeight,
            this.windowWidth = window.innerWidth,
            this.windowMiddle = {
                x: this.windowWidth / 2,
                y: this.windowHeight / 2
            },
            this.els = {},
            this.currentElements = {},
            this.listeners = {},
            this.hasScrollTicking = !1,
            this.hasCallEventSet = !1,
            this.checkScroll = this.checkScroll.bind(this),
            this.checkResize = this.checkResize.bind(this),
            this.checkEvent = this.checkEvent.bind(this),
            this.instance = {
                scroll: {
                    x: 0,
                    y: 0
                },
                limit: {
                    x: this.html.offsetWidth,
                    y: this.html.offsetHeight
                },
                currentElements: this.currentElements
            },
            this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop",
            this.isMobile && (this.direction = this[this.context].direction),
            "horizontal" === this.direction ? this.directionAxis = "x" : this.directionAxis = "y",
            this.getDirection && (this.instance.direction = null),
            this.getDirection && (this.instance.speed = 0),
            this.html.classList.add(this.initClass),
            window.addEventListener("resize", this.checkResize, !1)
        }
        return Ts(t, [{
            key: "init",
            value: function() {
                this.initEvents()
            }
        }, {
            key: "checkScroll",
            value: function() {
                this.dispatchScroll()
            }
        }, {
            key: "checkResize",
            value: function() {
                var t = this;
                this.resizeTick || (this.resizeTick = !0,
                requestAnimationFrame((function() {
                    t.resize(),
                    t.resizeTick = !1
                }
                )))
            }
        }, {
            key: "resize",
            value: function() {}
        }, {
            key: "checkContext",
            value: function() {
                if (this.reloadOnContextChange) {
                    this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint,
                    this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
                    var t = this.context;
                    this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop",
                    t != this.context && ("desktop" == t ? this.smooth : this[t].smooth) != ("desktop" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload()
                }
            }
        }, {
            key: "initEvents",
            value: function() {
                var t = this;
                this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]")),
                this.setScrollTo = this.setScrollTo.bind(this),
                this.scrollToEls.forEach((function(e) {
                    e.addEventListener("click", t.setScrollTo, !1)
                }
                ))
            }
        }, {
            key: "setScrollTo",
            value: function(t) {
                t.preventDefault(),
                this.scrollTo(t.currentTarget.getAttribute("data-".concat(this.name, "-href")) || t.currentTarget.getAttribute("href"), {
                    offset: t.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
                })
            }
        }, {
            key: "addElements",
            value: function() {}
        }, {
            key: "detectElements",
            value: function(t) {
                var e = this
                  , n = this.instance.scroll.y
                  , i = n + this.windowHeight
                  , r = this.instance.scroll.x
                  , s = r + this.windowWidth;
                Object.entries(this.els).forEach((function(o) {
                    var a = Ns(o, 2)
                      , l = a[0]
                      , c = a[1];
                    if (!c || c.inView && !t || ("horizontal" === e.direction ? s >= c.left && r < c.right && e.setInView(c, l) : i >= c.top && n < c.bottom && e.setInView(c, l)),
                    c && c.inView)
                        if ("horizontal" === e.direction) {
                            var h = c.right - c.left;
                            c.progress = (e.instance.scroll.x - (c.left - e.windowWidth)) / (h + e.windowWidth),
                            (s < c.left || r > c.right) && e.setOutOfView(c, l)
                        } else {
                            var u = c.bottom - c.top;
                            c.progress = (e.instance.scroll.y - (c.top - e.windowHeight)) / (u + e.windowHeight),
                            (i < c.top || n > c.bottom) && e.setOutOfView(c, l)
                        }
                }
                )),
                this.hasScrollTicking = !1
            }
        }, {
            key: "setInView",
            value: function(t, e) {
                this.els[e].inView = !0,
                t.el.classList.add(t.class),
                this.currentElements[e] = t,
                t.call && this.hasCallEventSet && (this.dispatchCall(t, "enter"),
                t.repeat || (this.els[e].call = !1))
            }
        }, {
            key: "setOutOfView",
            value: function(t, e) {
                var n = this;
                this.els[e].inView = !1,
                Object.keys(this.currentElements).forEach((function(t) {
                    t === e && delete n.currentElements[t]
                }
                )),
                t.call && this.hasCallEventSet && this.dispatchCall(t, "exit"),
                t.repeat && t.el.classList.remove(t.class)
            }
        }, {
            key: "dispatchCall",
            value: function(t, e) {
                this.callWay = e,
                this.callValue = t.call.split(",").map((function(t) {
                    return t.trim()
                }
                )),
                this.callObj = t,
                1 == this.callValue.length && (this.callValue = this.callValue[0]);
                var n = new Event(this.namespace + "call");
                this.el.dispatchEvent(n)
            }
        }, {
            key: "dispatchScroll",
            value: function() {
                var t = new Event(this.namespace + "scroll");
                this.el.dispatchEvent(t)
            }
        }, {
            key: "setEvents",
            value: function(t, e) {
                this.listeners[t] || (this.listeners[t] = []);
                var n = this.listeners[t];
                n.push(e),
                1 === n.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1),
                "call" === t && (this.hasCallEventSet = !0,
                this.detectElements(!0))
            }
        }, {
            key: "unsetEvents",
            value: function(t, e) {
                if (this.listeners[t]) {
                    var n = this.listeners[t]
                      , i = n.indexOf(e);
                    i < 0 || (n.splice(i, 1),
                    0 === n.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1))
                }
            }
        }, {
            key: "checkEvent",
            value: function(t) {
                var e = this
                  , n = t.type.replace(this.namespace, "")
                  , i = this.listeners[n];
                i && 0 !== i.length && i.forEach((function(t) {
                    switch (n) {
                    case "scroll":
                        return t(e.instance);
                    case "call":
                        return t(e.callValue, e.callWay, e.callObj);
                    default:
                        return t()
                    }
                }
                ))
            }
        }, {
            key: "startScroll",
            value: function() {}
        }, {
            key: "stopScroll",
            value: function() {}
        }, {
            key: "setScroll",
            value: function(t, e) {
                this.instance.scroll = {
                    x: 0,
                    y: 0
                }
            }
        }, {
            key: "destroy",
            value: function() {
                var t = this;
                window.removeEventListener("resize", this.checkResize, !1),
                Object.keys(this.listeners).forEach((function(e) {
                    t.el.removeEventListener(t.namespace + e, t.checkEvent, !1)
                }
                )),
                this.listeners = {},
                this.scrollToEls.forEach((function(e) {
                    e.removeEventListener("click", t.setScrollTo, !1)
                }
                )),
                this.html.classList.remove(this.initClass)
            }
        }]),
        t
    }()
      , Vs = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t.g ? t.g : "undefined" != typeof self ? self : {};
    function Gs(t, e) {
        return t(e = {
            exports: {}
        }, e.exports),
        e.exports
    }
    var Ws = Gs((function(t, e) {
        t.exports = {
            polyfill: function() {
                var t = window
                  , e = document;
                if (!("scrollBehavior"in e.documentElement.style) || !0 === t.__forceSmoothScrollPolyfill__) {
                    var n, i = t.HTMLElement || t.Element, r = {
                        scroll: t.scroll || t.scrollTo,
                        scrollBy: t.scrollBy,
                        elementScroll: i.prototype.scroll || a,
                        scrollIntoView: i.prototype.scrollIntoView
                    }, s = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now, o = (n = t.navigator.userAgent,
                    new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(n) ? 1 : 0);
                    t.scroll = t.scrollTo = function() {
                        void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? f.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : r.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset))
                    }
                    ,
                    t.scrollBy = function() {
                        void 0 !== arguments[0] && (l(arguments[0]) ? r.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : f.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset)))
                    }
                    ,
                    i.prototype.scroll = i.prototype.scrollTo = function() {
                        if (void 0 !== arguments[0])
                            if (!0 !== l(arguments[0])) {
                                var t = arguments[0].left
                                  , e = arguments[0].top;
                                f.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e)
                            } else {
                                if ("number" == typeof arguments[0] && void 0 === arguments[1])
                                    throw new SyntaxError("Value could not be converted");
                                r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop)
                            }
                    }
                    ,
                    i.prototype.scrollBy = function() {
                        void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? this.scroll({
                            left: ~~arguments[0].left + this.scrollLeft,
                            top: ~~arguments[0].top + this.scrollTop,
                            behavior: arguments[0].behavior
                        }) : r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop))
                    }
                    ,
                    i.prototype.scrollIntoView = function() {
                        if (!0 !== l(arguments[0])) {
                            var n = d(this)
                              , i = n.getBoundingClientRect()
                              , s = this.getBoundingClientRect();
                            n !== e.body ? (f.call(this, n, n.scrollLeft + s.left - i.left, n.scrollTop + s.top - i.top),
                            "fixed" !== t.getComputedStyle(n).position && t.scrollBy({
                                left: i.left,
                                top: i.top,
                                behavior: "smooth"
                            })) : t.scrollBy({
                                left: s.left,
                                top: s.top,
                                behavior: "smooth"
                            })
                        } else
                            r.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0])
                    }
                }
                function a(t, e) {
                    this.scrollLeft = t,
                    this.scrollTop = e
                }
                function l(t) {
                    if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior)
                        return !0;
                    if ("object" == typeof t && "smooth" === t.behavior)
                        return !1;
                    throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.")
                }
                function c(t, e) {
                    return "Y" === e ? t.clientHeight + o < t.scrollHeight : "X" === e ? t.clientWidth + o < t.scrollWidth : void 0
                }
                function h(e, n) {
                    var i = t.getComputedStyle(e, null)["overflow" + n];
                    return "auto" === i || "scroll" === i
                }
                function u(t) {
                    var e = c(t, "Y") && h(t, "Y")
                      , n = c(t, "X") && h(t, "X");
                    return e || n
                }
                function d(t) {
                    for (; t !== e.body && !1 === u(t); )
                        t = t.parentNode || t.host;
                    return t
                }
                function p(e) {
                    var n, i, r, o, a = (s() - e.startTime) / 468;
                    o = a = a > 1 ? 1 : a,
                    n = .5 * (1 - Math.cos(Math.PI * o)),
                    i = e.startX + (e.x - e.startX) * n,
                    r = e.startY + (e.y - e.startY) * n,
                    e.method.call(e.scrollable, i, r),
                    i === e.x && r === e.y || t.requestAnimationFrame(p.bind(t, e))
                }
                function f(n, i, o) {
                    var l, c, h, u, d = s();
                    n === e.body ? (l = t,
                    c = t.scrollX || t.pageXOffset,
                    h = t.scrollY || t.pageYOffset,
                    u = r.scroll) : (l = n,
                    c = n.scrollLeft,
                    h = n.scrollTop,
                    u = a),
                    p({
                        scrollable: l,
                        method: u,
                        startTime: d,
                        startX: c,
                        startY: h,
                        x: i,
                        y: o
                    })
                }
            }
        }
    }
    ))
      , js = (Ws.polyfill,
    function(t) {
        Ls(n, t);
        var e = Os(n);
        function n() {
            var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return Ms(this, n),
            (t = e.call(this, i)).resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = "manual"),
            window.scrollTo(0, 0)),
            window.addEventListener("scroll", t.checkScroll, !1),
            void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = Ws,
            window.smoothscrollPolyfill.polyfill()),
            t
        }
        return Ts(n, [{
            key: "init",
            value: function() {
                this.instance.scroll.y = window.pageYOffset,
                this.addElements(),
                this.detectElements(),
                ks(Cs(n.prototype), "init", this).call(this)
            }
        }, {
            key: "checkScroll",
            value: function() {
                var t = this;
                ks(Cs(n.prototype), "checkScroll", this).call(this),
                this.getDirection && this.addDirection(),
                this.getSpeed && (this.addSpeed(),
                this.speedTs = Date.now()),
                this.instance.scroll.y = window.pageYOffset,
                Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame((function() {
                    t.detectElements()
                }
                )),
                this.hasScrollTicking = !0))
            }
        }, {
            key: "addDirection",
            value: function() {
                window.pageYOffset > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : window.pageYOffset < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up")
            }
        }, {
            key: "addSpeed",
            value: function() {
                window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
            }
        }, {
            key: "resize",
            value: function() {
                Object.entries(this.els).length && (this.windowHeight = window.innerHeight,
                this.updateElements())
            }
        }, {
            key: "addElements",
            value: function() {
                var t = this;
                this.els = {},
                this.el.querySelectorAll("[data-" + this.name + "]").forEach((function(e, n) {
                    e.getBoundingClientRect();
                    var i, r, s, o = e.dataset[t.name + "Class"] || t.class, a = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : n, l = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset, c = e.dataset[t.name + "Repeat"], h = e.dataset[t.name + "Call"], u = e.dataset[t.name + "Target"], d = (s = void 0 !== u ? document.querySelector("".concat(u)) : e).getBoundingClientRect();
                    i = d.top + t.instance.scroll.y,
                    r = d.left + t.instance.scroll.x;
                    var p = i + s.offsetHeight
                      , f = r + s.offsetWidth;
                    c = "false" != c && (null != c || t.repeat);
                    var m = t.getRelativeOffset(l)
                      , g = {
                        el: e,
                        targetEl: s,
                        id: a,
                        class: o,
                        top: i += m[0],
                        bottom: p -= m[1],
                        left: r,
                        right: f,
                        offset: l,
                        progress: 0,
                        repeat: c,
                        inView: !1,
                        call: h
                    };
                    t.els[a] = g,
                    e.classList.contains(o) && t.setInView(t.els[a], a)
                }
                ))
            }
        }, {
            key: "updateElements",
            value: function() {
                var t = this;
                Object.entries(this.els).forEach((function(e) {
                    var n = Ns(e, 2)
                      , i = n[0]
                      , r = n[1]
                      , s = r.targetEl.getBoundingClientRect().top + t.instance.scroll.y
                      , o = s + r.targetEl.offsetHeight
                      , a = t.getRelativeOffset(r.offset);
                    t.els[i].top = s + a[0],
                    t.els[i].bottom = o - a[1]
                }
                )),
                this.hasScrollTicking = !1
            }
        }, {
            key: "getRelativeOffset",
            value: function(t) {
                var e = [0, 0];
                if (t)
                    for (var n = 0; n < t.length; n++)
                        "string" == typeof t[n] ? t[n].includes("%") ? e[n] = parseInt(t[n].replace("%", "") * this.windowHeight / 100) : e[n] = parseInt(t[n]) : e[n] = t[n];
                return e
            }
        }, {
            key: "scrollTo",
            value: function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , n = parseInt(e.offset) || 0
                  , i = !!e.callback && e.callback;
                if ("string" == typeof t) {
                    if ("top" === t)
                        t = this.html;
                    else if ("bottom" === t)
                        t = this.html.offsetHeight - window.innerHeight;
                    else if (!(t = document.querySelector(t)))
                        return
                } else if ("number" == typeof t)
                    t = parseInt(t);
                else if (!t || !t.tagName)
                    return void console.warn("`target` parameter is not valid");
                n = "number" != typeof t ? t.getBoundingClientRect().top + n + this.instance.scroll.y : t + n;
                var r = function() {
                    return parseInt(window.pageYOffset) === parseInt(n)
                };
                if (i) {
                    if (r())
                        return void i();
                    var s = function t() {
                        r() && (window.removeEventListener("scroll", t),
                        i())
                    };
                    window.addEventListener("scroll", s)
                }
                window.scrollTo({
                    top: n,
                    behavior: 0 === e.duration ? "auto" : "smooth"
                })
            }
        }, {
            key: "update",
            value: function() {
                this.addElements(),
                this.detectElements()
            }
        }, {
            key: "destroy",
            value: function() {
                ks(Cs(n.prototype), "destroy", this).call(this),
                window.removeEventListener("scroll", this.checkScroll, !1)
            }
        }]),
        n
    }(Hs))
      , Xs = Object.getOwnPropertySymbols
      , qs = Object.prototype.hasOwnProperty
      , Ys = Object.prototype.propertyIsEnumerable;
    function Zs(t) {
        if (null == t)
            throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(t)
    }
    var Js = function() {
        try {
            if (!Object.assign)
                return !1;
            var t = new String("abc");
            if (t[5] = "de",
            "5" === Object.getOwnPropertyNames(t)[0])
                return !1;
            for (var e = {}, n = 0; n < 10; n++)
                e["_" + String.fromCharCode(n)] = n;
            if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                return e[t]
            }
            )).join(""))
                return !1;
            var i = {};
            return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                i[t] = t
            }
            )),
            "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("")
        } catch (t) {
            return !1
        }
    }() ? Object.assign : function(t, e) {
        for (var n, i, r = Zs(t), s = 1; s < arguments.length; s++) {
            for (var o in n = Object(arguments[s]))
                qs.call(n, o) && (r[o] = n[o]);
            if (Xs) {
                i = Xs(n);
                for (var a = 0; a < i.length; a++)
                    Ys.call(n, i[a]) && (r[i[a]] = n[i[a]])
            }
        }
        return r
    }
    ;
    function Ks() {}
    Ks.prototype = {
        on: function(t, e, n) {
            var i = this.e || (this.e = {});
            return (i[t] || (i[t] = [])).push({
                fn: e,
                ctx: n
            }),
            this
        },
        once: function(t, e, n) {
            var i = this;
            function r() {
                i.off(t, r),
                e.apply(n, arguments)
            }
            return r._ = e,
            this.on(t, r, n)
        },
        emit: function(t) {
            for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++)
                n[i].fn.apply(n[i].ctx, e);
            return this
        },
        off: function(t, e) {
            var n = this.e || (this.e = {})
              , i = n[t]
              , r = [];
            if (i && e)
                for (var s = 0, o = i.length; s < o; s++)
                    i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
            return r.length ? n[t] = r : delete n[t],
            this
        }
    };
    var Qs = Ks
      , $s = Gs((function(t, e) {
        (function() {
            (null !== e ? e : this).Lethargy = function() {
                function t(t, e, n, i) {
                    this.stability = null != t ? Math.abs(t) : 8,
                    this.sensitivity = null != e ? 1 + Math.abs(e) : 100,
                    this.tolerance = null != n ? 1 + Math.abs(n) : 1.1,
                    this.delay = null != i ? i : 150,
                    this.lastUpDeltas = function() {
                        var t, e, n;
                        for (n = [],
                        t = 1,
                        e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)
                            n.push(null);
                        return n
                    }
                    .call(this),
                    this.lastDownDeltas = function() {
                        var t, e, n;
                        for (n = [],
                        t = 1,
                        e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)
                            n.push(null);
                        return n
                    }
                    .call(this),
                    this.deltasTimestamp = function() {
                        var t, e, n;
                        for (n = [],
                        t = 1,
                        e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)
                            n.push(null);
                        return n
                    }
                    .call(this)
                }
                return t.prototype.check = function(t) {
                    var e;
                    return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail),
                    this.deltasTimestamp.push(Date.now()),
                    this.deltasTimestamp.shift(),
                    e > 0 ? (this.lastUpDeltas.push(e),
                    this.lastUpDeltas.shift(),
                    this.isInertia(1)) : (this.lastDownDeltas.push(e),
                    this.lastDownDeltas.shift(),
                    this.isInertia(-1))
                }
                ,
                t.prototype.isInertia = function(t) {
                    var e, n, i, r, s, o, a;
                    return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (i = e.slice(0, this.stability),
                    n = e.slice(this.stability, 2 * this.stability),
                    a = i.reduce((function(t, e) {
                        return t + e
                    }
                    )),
                    s = n.reduce((function(t, e) {
                        return t + e
                    }
                    )),
                    o = a / i.length,
                    r = s / n.length,
                    Math.abs(o) < Math.abs(r * this.tolerance) && this.sensitivity < Math.abs(r) && t)
                }
                ,
                t.prototype.showLastUpDeltas = function() {
                    return this.lastUpDeltas
                }
                ,
                t.prototype.showLastDownDeltas = function() {
                    return this.lastDownDeltas
                }
                ,
                t
            }()
        }
        ).call(Vs)
    }
    ))
      , to = "onwheel"in document
      , eo = "onmousewheel"in document
      , no = "ontouchstart"in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch
      , io = navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1
      , ro = !!window.navigator.msPointerEnabled
      , so = "onkeydown"in document
      , oo = navigator.userAgent.indexOf("Firefox") > -1
      , ao = Object.prototype.toString
      , lo = Object.prototype.hasOwnProperty;
    function co(t, e) {
        return function() {
            return t.apply(e, arguments)
        }
    }
    var ho = $s.Lethargy
      , uo = "virtualscroll"
      , po = fo;
    function fo(t) {
        !function(t) {
            if (!t)
                return console.warn("bindAll requires at least one argument.");
            var e = Array.prototype.slice.call(arguments, 1);
            if (0 === e.length)
                for (var n in t)
                    lo.call(t, n) && "function" == typeof t[n] && "[object Function]" == ao.call(t[n]) && e.push(n);
            for (var i = 0; i < e.length; i++) {
                var r = e[i];
                t[r] = co(t[r], t)
            }
        }(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"),
        this.el = window,
        t && t.el && (this.el = t.el,
        delete t.el),
        this.options = Js({
            mouseMultiplier: 1,
            touchMultiplier: 2,
            firefoxMultiplier: 15,
            keyStep: 120,
            preventTouch: !1,
            unpreventTouchClass: "vs-touchmove-allowed",
            limitInertia: !1,
            useKeyboard: !0,
            useTouch: !0
        }, t),
        this.options.limitInertia && (this._lethargy = new ho),
        this._emitter = new Qs,
        this._event = {
            y: 0,
            x: 0,
            deltaX: 0,
            deltaY: 0
        },
        this.touchStartX = null,
        this.touchStartY = null,
        this.bodyTouchAction = null,
        void 0 !== this.options.passive && (this.listenerOptions = {
            passive: this.options.passive
        })
    }
    function mo(t, e, n) {
        return (1 - n) * t + n * e
    }
    function go(t) {
        var e = {};
        if (window.getComputedStyle) {
            var n = getComputedStyle(t)
              , i = n.transform || n.webkitTransform || n.mozTransform
              , r = i.match(/^matrix3d\((.+)\)$/);
            return r ? (e.x = r ? parseFloat(r[1].split(", ")[12]) : 0,
            e.y = r ? parseFloat(r[1].split(", ")[13]) : 0) : (r = i.match(/^matrix\((.+)\)$/),
            e.x = r ? parseFloat(r[1].split(", ")[4]) : 0,
            e.y = r ? parseFloat(r[1].split(", ")[5]) : 0),
            e
        }
    }
    function vo(t) {
        for (var e = []; t && t !== document; t = t.parentNode)
            e.push(t);
        return e
    }
    fo.prototype._notify = function(t) {
        var e = this._event;
        e.x += e.deltaX,
        e.y += e.deltaY,
        this._emitter.emit(uo, {
            x: e.x,
            y: e.y,
            deltaX: e.deltaX,
            deltaY: e.deltaY,
            originalEvent: t
        })
    }
    ,
    fo.prototype._onWheel = function(t) {
        var e = this.options;
        if (!this._lethargy || !1 !== this._lethargy.check(t)) {
            var n = this._event;
            n.deltaX = t.wheelDeltaX || -1 * t.deltaX,
            n.deltaY = t.wheelDeltaY || -1 * t.deltaY,
            oo && 1 == t.deltaMode && (n.deltaX *= e.firefoxMultiplier,
            n.deltaY *= e.firefoxMultiplier),
            n.deltaX *= e.mouseMultiplier,
            n.deltaY *= e.mouseMultiplier,
            this._notify(t)
        }
    }
    ,
    fo.prototype._onMouseWheel = function(t) {
        if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {
            var e = this._event;
            e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0,
            e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta,
            this._notify(t)
        }
    }
    ,
    fo.prototype._onTouchStart = function(t) {
        var e = t.targetTouches ? t.targetTouches[0] : t;
        this.touchStartX = e.pageX,
        this.touchStartY = e.pageY
    }
    ,
    fo.prototype._onTouchMove = function(t) {
        var e = this.options;
        e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();
        var n = this._event
          , i = t.targetTouches ? t.targetTouches[0] : t;
        n.deltaX = (i.pageX - this.touchStartX) * e.touchMultiplier,
        n.deltaY = (i.pageY - this.touchStartY) * e.touchMultiplier,
        this.touchStartX = i.pageX,
        this.touchStartY = i.pageY,
        this._notify(t)
    }
    ,
    fo.prototype._onKeyDown = function(t) {
        var e = this._event;
        e.deltaX = e.deltaY = 0;
        var n = window.innerHeight - 40;
        switch (t.keyCode) {
        case 37:
        case 38:
            e.deltaY = this.options.keyStep;
            break;
        case 39:
        case 40:
            e.deltaY = -this.options.keyStep;
            break;
        case t.shiftKey:
            e.deltaY = n;
            break;
        case 32:
            e.deltaY = -n;
            break;
        default:
            return
        }
        this._notify(t)
    }
    ,
    fo.prototype._bind = function() {
        to && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions),
        eo && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions),
        no && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions),
        this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)),
        ro && io && (this.bodyTouchAction = document.body.style.msTouchAction,
        document.body.style.msTouchAction = "none",
        this.el.addEventListener("MSPointerDown", this._onTouchStart, !0),
        this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)),
        so && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown)
    }
    ,
    fo.prototype._unbind = function() {
        to && this.el.removeEventListener("wheel", this._onWheel),
        eo && this.el.removeEventListener("mousewheel", this._onMouseWheel),
        no && (this.el.removeEventListener("touchstart", this._onTouchStart),
        this.el.removeEventListener("touchmove", this._onTouchMove)),
        ro && io && (document.body.style.msTouchAction = this.bodyTouchAction,
        this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0),
        this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)),
        so && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
    }
    ,
    fo.prototype.on = function(t, e) {
        this._emitter.on(uo, t, e);
        var n = this._emitter.e;
        n && n[uo] && 1 === n[uo].length && this._bind()
    }
    ,
    fo.prototype.off = function(t, e) {
        this._emitter.off(uo, t, e);
        var n = this._emitter.e;
        (!n[uo] || n[uo].length <= 0) && this._unbind()
    }
    ,
    fo.prototype.reset = function() {
        var t = this._event;
        t.x = 0,
        t.y = 0
    }
    ,
    fo.prototype.destroy = function() {
        this._emitter.off(),
        this._unbind()
    }
    ;
    var yo = .1
      , _o = "function" == typeof Float32Array;
    function xo(t, e) {
        return 1 - 3 * e + 3 * t
    }
    function bo(t, e) {
        return 3 * e - 6 * t
    }
    function wo(t) {
        return 3 * t
    }
    function Mo(t, e, n) {
        return ((xo(e, n) * t + bo(e, n)) * t + wo(e)) * t
    }
    function So(t, e, n) {
        return 3 * xo(e, n) * t * t + 2 * bo(e, n) * t + wo(e)
    }
    function To(t) {
        return t
    }
    var Eo = function(t, e, n, i) {
        if (!(0 <= t && t <= 1 && 0 <= n && n <= 1))
            throw new Error("bezier x values must be in [0, 1] range");
        if (t === e && n === i)
            return To;
        for (var r = _o ? new Float32Array(11) : new Array(11), s = 0; s < 11; ++s)
            r[s] = Mo(s * yo, t, n);
        return function(s) {
            return 0 === s ? 0 : 1 === s ? 1 : Mo(function(e) {
                for (var i = 0, s = 1; 10 !== s && r[s] <= e; ++s)
                    i += yo;
                --s;
                var o = i + (e - r[s]) / (r[s + 1] - r[s]) * yo
                  , a = So(o, t, n);
                return a >= .001 ? function(t, e, n, i) {
                    for (var r = 0; r < 4; ++r) {
                        var s = So(e, n, i);
                        if (0 === s)
                            return e;
                        e -= (Mo(e, n, i) - t) / s
                    }
                    return e
                }(e, o, t, n) : 0 === a ? o : function(t, e, n, i, r) {
                    var s, o, a = 0;
                    do {
                        (s = Mo(o = e + (n - e) / 2, i, r) - t) > 0 ? n = o : e = o
                    } while (Math.abs(s) > 1e-7 && ++a < 10);
                    return o
                }(e, i, i + yo, t, n)
            }(s), e, i)
        }
    }
      , Ao = function(t) {
        Ls(n, t);
        var e = Os(n);
        function n() {
            var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return Ms(this, n),
            history.scrollRestoration && (history.scrollRestoration = "manual"),
            window.scrollTo(0, 0),
            (t = e.call(this, i)).inertia && (t.lerp = .1 * t.inertia),
            t.isScrolling = !1,
            t.isDraggingScrollbar = !1,
            t.isTicking = !1,
            t.hasScrollTicking = !1,
            t.parallaxElements = {},
            t.stop = !1,
            t.scrollbarContainer = i.scrollbarContainer,
            t.checkKey = t.checkKey.bind(Ds(t)),
            window.addEventListener("keydown", t.checkKey, !1),
            t
        }
        return Ts(n, [{
            key: "init",
            value: function() {
                var t = this;
                this.html.classList.add(this.smoothClass),
                this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction),
                this.instance = Rs({
                    delta: {
                        x: this.initPosition.x,
                        y: this.initPosition.y
                    },
                    scroll: {
                        x: this.initPosition.x,
                        y: this.initPosition.y
                    }
                }, this.instance),
                this.vs = new po({
                    el: this.scrollFromAnywhere ? document : this.el,
                    mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4,
                    firefoxMultiplier: this.firefoxMultiplier,
                    touchMultiplier: this.touchMultiplier,
                    useKeyboard: !1,
                    passive: !0
                }),
                this.vs.on((function(e) {
                    t.stop || t.isDraggingScrollbar || requestAnimationFrame((function() {
                        t.updateDelta(e),
                        t.isScrolling || t.startScrolling()
                    }
                    ))
                }
                )),
                this.setScrollLimit(),
                this.initScrollBar(),
                this.addSections(),
                this.addElements(),
                this.checkScroll(!0),
                this.transformElements(!0, !0),
                ks(Cs(n.prototype), "init", this).call(this)
            }
        }, {
            key: "setScrollLimit",
            value: function() {
                if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight,
                "horizontal" === this.direction) {
                    for (var t = 0, e = this.el.children, n = 0; n < e.length; n++)
                        t += e[n].offsetWidth;
                    this.instance.limit.x = t - this.windowWidth
                }
            }
        }, {
            key: "startScrolling",
            value: function() {
                this.startScrollTs = Date.now(),
                this.isScrolling = !0,
                this.checkScroll(),
                this.html.classList.add(this.scrollingClass)
            }
        }, {
            key: "stopScrolling",
            value: function() {
                cancelAnimationFrame(this.checkScrollRaf),
                this.startScrollTs = void 0,
                this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf),
                this.scrollToRaf = null),
                this.isScrolling = !1,
                this.instance.scroll.y = Math.round(this.instance.scroll.y),
                this.html.classList.remove(this.scrollingClass)
            }
        }, {
            key: "checkKey",
            value: function(t) {
                var e = this;
                if (this.stop)
                    9 == t.keyCode && requestAnimationFrame((function() {
                        e.html.scrollTop = 0,
                        document.body.scrollTop = 0,
                        e.html.scrollLeft = 0,
                        document.body.scrollLeft = 0
                    }
                    ));
                else {
                    switch (t.keyCode) {
                    case 9:
                        requestAnimationFrame((function() {
                            e.html.scrollTop = 0,
                            document.body.scrollTop = 0,
                            e.html.scrollLeft = 0,
                            document.body.scrollLeft = 0,
                            e.scrollTo(document.activeElement, {
                                offset: -window.innerHeight / 2
                            })
                        }
                        ));
                        break;
                    case 38:
                        this.isActiveElementScrollSensitive() && (this.instance.delta[this.directionAxis] -= 240);
                        break;
                    case 40:
                        this.isActiveElementScrollSensitive() && (this.instance.delta[this.directionAxis] += 240);
                        break;
                    case 33:
                        this.instance.delta[this.directionAxis] -= window.innerHeight;
                        break;
                    case 34:
                        this.instance.delta[this.directionAxis] += window.innerHeight;
                        break;
                    case 36:
                        this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
                        break;
                    case 35:
                        this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
                        break;
                    case 32:
                        this.isActiveElementScrollSensitive() && (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight);
                        break;
                    default:
                        return
                    }
                    this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0),
                    this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]),
                    this.stopScrolling(),
                    this.isScrolling = !0,
                    this.checkScroll(),
                    this.html.classList.add(this.scrollingClass)
                }
            }
        }, {
            key: "isActiveElementScrollSensitive",
            value: function() {
                return !(document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || document.activeElement instanceof HTMLButtonElement || document.activeElement instanceof HTMLSelectElement)
            }
        }, {
            key: "checkScroll",
            value: function() {
                var t = this
                  , e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                if (e || this.isScrolling || this.isDraggingScrollbar) {
                    this.hasScrollTicking || (this.checkScrollRaf = requestAnimationFrame((function() {
                        return t.checkScroll()
                    }
                    )),
                    this.hasScrollTicking = !0),
                    this.updateScroll();
                    var i = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis])
                      , r = Date.now() - this.startScrollTs;
                    if (!this.animatingScroll && r > 100 && (i < .5 && 0 != this.instance.delta[this.directionAxis] || i < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(),
                    Object.entries(this.sections).forEach((function(n) {
                        var i = Ns(n, 2)
                          , r = (i[0],
                        i[1]);
                        r.persistent || t.instance.scroll[t.directionAxis] > r.offset[t.directionAxis] && t.instance.scroll[t.directionAxis] < r.limit[t.directionAxis] ? ("horizontal" === t.direction ? t.transform(r.el, -t.instance.scroll[t.directionAxis], 0) : t.transform(r.el, 0, -t.instance.scroll[t.directionAxis]),
                        r.inView || (r.inView = !0,
                        r.el.style.opacity = 1,
                        r.el.style.pointerEvents = "all",
                        r.el.setAttribute("data-".concat(t.name, "-section-inview"), ""))) : ((r.inView || e) && (r.inView = !1,
                        r.el.style.opacity = 0,
                        r.el.style.pointerEvents = "none",
                        r.el.removeAttribute("data-".concat(t.name, "-section-inview"))),
                        t.transform(r.el, 0, 0))
                    }
                    )),
                    this.getDirection && this.addDirection(),
                    this.getSpeed && (this.addSpeed(),
                    this.speedTs = Date.now()),
                    this.detectElements(),
                    this.transformElements(),
                    this.hasScrollbar) {
                        var s = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
                        "horizontal" === this.direction ? this.transform(this.scrollbarThumb, s, 0) : this.transform(this.scrollbarThumb, 0, s)
                    }
                    ks(Cs(n.prototype), "checkScroll", this).call(this),
                    this.hasScrollTicking = !1
                }
            }
        }, {
            key: "resize",
            value: function() {
                this.windowHeight = window.innerHeight,
                this.windowWidth = window.innerWidth,
                this.checkContext(),
                this.windowMiddle = {
                    x: this.windowWidth / 2,
                    y: this.windowHeight / 2
                },
                this.update()
            }
        }, {
            key: "updateDelta",
            value: function(t) {
                var e, n = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
                e = "both" === n ? t.deltaX + t.deltaY : "vertical" === n ? t.deltaY : "horizontal" === n ? t.deltaX : t.deltaY,
                this.instance.delta[this.directionAxis] -= e * this.multiplier,
                this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0),
                this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis])
            }
        }, {
            key: "updateScroll",
            value: function(t) {
                this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = mo(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis])
            }
        }, {
            key: "addDirection",
            value: function() {
                this.instance.delta.y > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : this.instance.delta.y < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up"),
                this.instance.delta.x > this.instance.scroll.x ? "right" !== this.instance.direction && (this.instance.direction = "right") : this.instance.delta.x < this.instance.scroll.x && "left" !== this.instance.direction && (this.instance.direction = "left")
            }
        }, {
            key: "addSpeed",
            value: function() {
                this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
            }
        }, {
            key: "initScrollBar",
            value: function() {
                if (this.scrollbar = document.createElement("span"),
                this.scrollbarThumb = document.createElement("span"),
                this.scrollbar.classList.add("".concat(this.scrollbarClass)),
                this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb")),
                this.scrollbar.append(this.scrollbarThumb),
                this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar),
                this.getScrollBar = this.getScrollBar.bind(this),
                this.releaseScrollBar = this.releaseScrollBar.bind(this),
                this.moveScrollBar = this.moveScrollBar.bind(this),
                this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar),
                window.addEventListener("mouseup", this.releaseScrollBar),
                window.addEventListener("mousemove", this.moveScrollBar),
                this.hasScrollbar = !1,
                "horizontal" == this.direction) {
                    if (this.instance.limit.x + this.windowWidth <= this.windowWidth)
                        return
                } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight)
                    return;
                this.hasScrollbar = !0,
                this.scrollbarBCR = this.scrollbar.getBoundingClientRect(),
                this.scrollbarHeight = this.scrollbarBCR.height,
                this.scrollbarWidth = this.scrollbarBCR.width,
                "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"),
                this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(),
                this.scrollBarLimit = {
                    x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                    y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                }
            }
        }, {
            key: "reinitScrollBar",
            value: function() {
                if (this.hasScrollbar = !1,
                "horizontal" == this.direction) {
                    if (this.instance.limit.x + this.windowWidth <= this.windowWidth)
                        return
                } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight)
                    return;
                this.hasScrollbar = !0,
                this.scrollbarBCR = this.scrollbar.getBoundingClientRect(),
                this.scrollbarHeight = this.scrollbarBCR.height,
                this.scrollbarWidth = this.scrollbarBCR.width,
                "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"),
                this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(),
                this.scrollBarLimit = {
                    x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                    y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                }
            }
        }, {
            key: "destroyScrollBar",
            value: function() {
                this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar),
                window.removeEventListener("mouseup", this.releaseScrollBar),
                window.removeEventListener("mousemove", this.moveScrollBar),
                this.scrollbar.remove()
            }
        }, {
            key: "getScrollBar",
            value: function(t) {
                this.isDraggingScrollbar = !0,
                this.checkScroll(),
                this.html.classList.remove(this.scrollingClass),
                this.html.classList.add(this.draggingClass)
            }
        }, {
            key: "releaseScrollBar",
            value: function(t) {
                this.isDraggingScrollbar = !1,
                this.isScrolling && this.html.classList.add(this.scrollingClass),
                this.html.classList.remove(this.draggingClass)
            }
        }, {
            key: "moveScrollBar",
            value: function(t) {
                var e = this;
                this.isDraggingScrollbar && requestAnimationFrame((function() {
                    var n = 100 * (t.clientX - e.scrollbarBCR.left) / e.scrollbarWidth * e.instance.limit.x / 100
                      , i = 100 * (t.clientY - e.scrollbarBCR.top) / e.scrollbarHeight * e.instance.limit.y / 100;
                    i > 0 && i < e.instance.limit.y && (e.instance.delta.y = i),
                    n > 0 && n < e.instance.limit.x && (e.instance.delta.x = n)
                }
                ))
            }
        }, {
            key: "addElements",
            value: function() {
                var t = this;
                this.els = {},
                this.parallaxElements = {},
                this.el.querySelectorAll("[data-".concat(this.name, "]")).forEach((function(e, n) {
                    var i, r, s, o = vo(e), a = Object.entries(t.sections).map((function(t) {
                        var e = Ns(t, 2);
                        return e[0],
                        e[1]
                    }
                    )).find((function(t) {
                        return o.includes(t.el)
                    }
                    )), l = e.dataset[t.name + "Class"] || t.class, c = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "el" + n, h = e.dataset[t.name + "Repeat"], u = e.dataset[t.name + "Call"], d = e.dataset[t.name + "Position"], p = e.dataset[t.name + "Delay"], f = e.dataset[t.name + "Direction"], m = "string" == typeof e.dataset[t.name + "Sticky"], g = !!e.dataset[t.name + "Speed"] && parseFloat(e.dataset[t.name + "Speed"]) / 10, v = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset, y = e.dataset[t.name + "Target"], _ = (s = void 0 !== y ? document.querySelector("".concat(y)) : e).getBoundingClientRect();
                    null === a || a.inView ? (i = _.top + t.instance.scroll.y - go(s).y,
                    r = _.left + t.instance.scroll.x - go(s).x) : (i = _.top - go(a.el).y - go(s).y,
                    r = _.left - go(a.el).x - go(s).x);
                    var x = i + s.offsetHeight
                      , b = r + s.offsetWidth
                      , w = {
                        x: (b - r) / 2 + r,
                        y: (x - i) / 2 + i
                    };
                    if (m) {
                        var M = e.getBoundingClientRect()
                          , S = M.top
                          , T = M.left
                          , E = {
                            x: T - r,
                            y: S - i
                        };
                        i += window.innerHeight,
                        r += window.innerWidth,
                        x = S + s.offsetHeight - e.offsetHeight - E[t.directionAxis],
                        w = {
                            x: ((b = T + s.offsetWidth - e.offsetWidth - E[t.directionAxis]) - r) / 2 + r,
                            y: (x - i) / 2 + i
                        }
                    }
                    h = "false" != h && (null != h || t.repeat);
                    var A = [0, 0];
                    if (v)
                        if ("horizontal" === t.direction) {
                            for (var R = 0; R < v.length; R++)
                                "string" == typeof v[R] ? v[R].includes("%") ? A[R] = parseInt(v[R].replace("%", "") * t.windowWidth / 100) : A[R] = parseInt(v[R]) : A[R] = v[R];
                            r += A[0],
                            b -= A[1]
                        } else {
                            for (R = 0; R < v.length; R++)
                                "string" == typeof v[R] ? v[R].includes("%") ? A[R] = parseInt(v[R].replace("%", "") * t.windowHeight / 100) : A[R] = parseInt(v[R]) : A[R] = v[R];
                            i += A[0],
                            x -= A[1]
                        }
                    var L = {
                        el: e,
                        id: c,
                        class: l,
                        section: a,
                        top: i,
                        middle: w,
                        bottom: x,
                        left: r,
                        right: b,
                        offset: v,
                        progress: 0,
                        repeat: h,
                        inView: !1,
                        call: u,
                        speed: g,
                        delay: p,
                        position: d,
                        target: s,
                        direction: f,
                        sticky: m
                    };
                    t.els[c] = L,
                    e.classList.contains(l) && t.setInView(t.els[c], c),
                    (!1 !== g || m) && (t.parallaxElements[c] = L)
                }
                ))
            }
        }, {
            key: "addSections",
            value: function() {
                var t = this;
                this.sections = {};
                var e = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
                0 === e.length && (e = [this.el]),
                e.forEach((function(e, n) {
                    var i = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "section" + n
                      , r = e.getBoundingClientRect()
                      , s = {
                        x: r.left - 1.5 * window.innerWidth - go(e).x,
                        y: r.top - 1.5 * window.innerHeight - go(e).y
                    }
                      , o = {
                        x: s.x + r.width + 2 * window.innerWidth,
                        y: s.y + r.height + 2 * window.innerHeight
                    }
                      , a = "string" == typeof e.dataset[t.name + "Persistent"];
                    e.setAttribute("data-scroll-section-id", i);
                    var l = {
                        el: e,
                        offset: s,
                        limit: o,
                        inView: !1,
                        persistent: a,
                        id: i
                    };
                    t.sections[i] = l
                }
                ))
            }
        }, {
            key: "transform",
            value: function(t, e, n, i) {
                var r;
                if (i) {
                    var s = go(t)
                      , o = mo(s.x, e, i)
                      , a = mo(s.y, n, i);
                    r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(o, ",").concat(a, ",0,1)")
                } else
                    r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(e, ",").concat(n, ",0,1)");
                t.style.webkitTransform = r,
                t.style.msTransform = r,
                t.style.transform = r
            }
        }, {
            key: "transformElements",
            value: function(t) {
                var e = this
                  , n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , i = this.instance.scroll.x + this.windowWidth
                  , r = this.instance.scroll.y + this.windowHeight
                  , s = {
                    x: this.instance.scroll.x + this.windowMiddle.x,
                    y: this.instance.scroll.y + this.windowMiddle.y
                };
                Object.entries(this.parallaxElements).forEach((function(o) {
                    var a = Ns(o, 2)
                      , l = (a[0],
                    a[1])
                      , c = !1;
                    if (t && (c = 0),
                    l.inView || n)
                        switch (l.position) {
                        case "top":
                        case "left":
                            c = e.instance.scroll[e.directionAxis] * -l.speed;
                            break;
                        case "elementTop":
                            c = (r - l.top) * -l.speed;
                            break;
                        case "bottom":
                            c = (e.instance.limit[e.directionAxis] - r + e.windowHeight) * l.speed;
                            break;
                        case "elementLeft":
                            c = (i - l.left) * -l.speed;
                            break;
                        case "right":
                            c = (e.instance.limit[e.directionAxis] - i + e.windowHeight) * l.speed;
                            break;
                        default:
                            c = (s[e.directionAxis] - l.middle[e.directionAxis]) * -l.speed
                        }
                    l.sticky && (c = l.inView ? "horizontal" === e.direction ? e.instance.scroll.x - l.left + window.innerWidth : e.instance.scroll.y - l.top + window.innerHeight : "horizontal" === e.direction ? e.instance.scroll.x < l.left - window.innerWidth && e.instance.scroll.x < l.left - window.innerWidth / 2 ? 0 : e.instance.scroll.x > l.right && e.instance.scroll.x > l.right + 100 && l.right - l.left + window.innerWidth : e.instance.scroll.y < l.top - window.innerHeight && e.instance.scroll.y < l.top - window.innerHeight / 2 ? 0 : e.instance.scroll.y > l.bottom && e.instance.scroll.y > l.bottom + 100 && l.bottom - l.top + window.innerHeight),
                    !1 !== c && ("horizontal" === l.direction || "horizontal" === e.direction && "vertical" !== l.direction ? e.transform(l.el, c, 0, !t && l.delay) : e.transform(l.el, 0, c, !t && l.delay))
                }
                ))
            }
        }, {
            key: "scrollTo",
            value: function(t) {
                var e = this
                  , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , i = parseInt(n.offset) || 0
                  , r = isNaN(parseInt(n.duration)) ? 1e3 : parseInt(n.duration)
                  , s = n.easing || [.25, 0, .35, 1]
                  , o = !!n.disableLerp
                  , a = !!n.callback && n.callback;
                if (s = Eo.apply(void 0, zs(s)),
                "string" == typeof t) {
                    if ("top" === t)
                        t = 0;
                    else if ("bottom" === t)
                        t = this.instance.limit.y;
                    else if ("left" === t)
                        t = 0;
                    else if ("right" === t)
                        t = this.instance.limit.x;
                    else if (!(t = document.querySelector(t)))
                        return
                } else if ("number" == typeof t)
                    t = parseInt(t);
                else if (!t || !t.tagName)
                    return void console.warn("`target` parameter is not valid");
                if ("number" != typeof t) {
                    var l = vo(t).includes(this.el);
                    if (!l)
                        return;
                    var c = t.getBoundingClientRect()
                      , h = c.top
                      , u = c.left
                      , d = vo(t)
                      , p = d.find((function(t) {
                        return Object.entries(e.sections).map((function(t) {
                            var e = Ns(t, 2);
                            return e[0],
                            e[1]
                        }
                        )).find((function(e) {
                            return e.el == t
                        }
                        ))
                    }
                    ))
                      , f = 0;
                    f = p ? go(p)[this.directionAxis] : -this.instance.scroll[this.directionAxis],
                    i = "horizontal" === this.direction ? u + i - f : h + i - f
                } else
                    i = t + i;
                var m = parseFloat(this.instance.delta[this.directionAxis])
                  , g = Math.max(0, Math.min(i, this.instance.limit[this.directionAxis]))
                  , v = g - m
                  , y = function(t) {
                    o ? "horizontal" === e.direction ? e.setScroll(m + v * t, e.instance.delta.y) : e.setScroll(e.instance.delta.x, m + v * t) : e.instance.delta[e.directionAxis] = m + v * t
                };
                this.animatingScroll = !0,
                this.stopScrolling(),
                this.startScrolling();
                var _ = Date.now()
                  , x = function t() {
                    var n = (Date.now() - _) / r;
                    n > 1 ? (y(1),
                    e.animatingScroll = !1,
                    0 == r && e.update(),
                    a && a()) : (e.scrollToRaf = requestAnimationFrame(t),
                    y(s(n)))
                };
                x()
            }
        }, {
            key: "update",
            value: function() {
                this.setScrollLimit(),
                this.addSections(),
                this.addElements(),
                this.detectElements(),
                this.updateScroll(),
                this.transformElements(!0),
                this.reinitScrollBar(),
                this.checkScroll(!0)
            }
        }, {
            key: "startScroll",
            value: function() {
                this.stop = !1
            }
        }, {
            key: "stopScroll",
            value: function() {
                this.stop = !0
            }
        }, {
            key: "setScroll",
            value: function(t, e) {
                this.instance = Rs(Rs({}, this.instance), {}, {
                    scroll: {
                        x: t,
                        y: e
                    },
                    delta: {
                        x: t,
                        y: e
                    },
                    speed: 0
                })
            }
        }, {
            key: "destroy",
            value: function() {
                ks(Cs(n.prototype), "destroy", this).call(this),
                this.stopScrolling(),
                this.html.classList.remove(this.smoothClass),
                this.vs.destroy(),
                this.destroyScrollBar(),
                window.removeEventListener("keydown", this.checkKey, !1)
            }
        }]),
        n
    }(Hs)
      , Ro = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            Ms(this, t),
            this.options = e,
            Object.assign(this, Us, e),
            this.smartphone = Us.smartphone,
            e.smartphone && Object.assign(this.smartphone, e.smartphone),
            this.tablet = Us.tablet,
            e.tablet && Object.assign(this.tablet, e.tablet),
            this.smooth || "horizontal" != this.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible"),
            this.tablet.smooth || "horizontal" != this.tablet.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (tablet)"),
            this.smartphone.smooth || "horizontal" != this.smartphone.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"),
            this.init()
        }
        return Ts(t, [{
            key: "init",
            value: function() {
                if (this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint,
                this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint,
                this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new Ao(this.options) : this.scroll = new js(this.options),
                this.scroll.init(),
                window.location.hash) {
                    var t = window.location.hash.slice(1, window.location.hash.length)
                      , e = document.getElementById(t);
                    e && this.scroll.scrollTo(e)
                }
            }
        }, {
            key: "update",
            value: function() {
                this.scroll.update()
            }
        }, {
            key: "start",
            value: function() {
                this.scroll.startScroll()
            }
        }, {
            key: "stop",
            value: function() {
                this.scroll.stopScroll()
            }
        }, {
            key: "scrollTo",
            value: function(t, e) {
                this.scroll.scrollTo(t, e)
            }
        }, {
            key: "setScroll",
            value: function(t, e) {
                this.scroll.setScroll(t, e)
            }
        }, {
            key: "on",
            value: function(t, e) {
                this.scroll.setEvents(t, e)
            }
        }, {
            key: "off",
            value: function(t, e) {
                this.scroll.unsetEvents(t, e)
            }
        }, {
            key: "destroy",
            value: function() {
                this.scroll.destroy()
            }
        }]),
        t
    }();
    const Lo = Ro
      , Co = 100
      , Po = 301
      , Do = 302
      , Io = 306
      , Oo = 1e3
      , ko = 1001
      , No = 1002
      , zo = 1003
      , Bo = 1004
      , Fo = 1005
      , Uo = 1006
      , Ho = 1008
      , Vo = 1009
      , Go = 1012
      , Wo = 1014
      , jo = 1015
      , Xo = 1016
      , qo = 1020
      , Yo = 1022
      , Zo = 1023
      , Jo = 1026
      , Ko = 1027
      , Qo = 2300
      , $o = 2301
      , ta = 2302
      , ea = 2400
      , na = 2401
      , ia = 2402
      , ra = 3e3
      , sa = 3001
      , oa = 3007
      , aa = 3002
      , la = 7680
      , ca = 35044
      , ha = 35048
      , ua = "300 es";
    class da {
        addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e)
        }
        hasEventListener(t, e) {
            if (void 0 === this._listeners)
                return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        }
        removeEventListener(t, e) {
            if (void 0 === this._listeners)
                return;
            const n = this._listeners[t];
            if (void 0 !== n) {
                const t = n.indexOf(e);
                -1 !== t && n.splice(t, 1)
            }
        }
        dispatchEvent(t) {
            if (void 0 === this._listeners)
                return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
                t.target = this;
                const n = e.slice(0);
                for (let e = 0, i = n.length; e < i; e++)
                    n[e].call(this, t);
                t.target = null
            }
        }
    }
    let pa = 1234567;
    const fa = Math.PI / 180
      , ma = 180 / Math.PI
      , ga = [];
    for (let t = 0; t < 256; t++)
        ga[t] = (t < 16 ? "0" : "") + t.toString(16);
    const va = "undefined" != typeof crypto && "randomUUID"in crypto;
    function ya() {
        if (va)
            return crypto.randomUUID().toUpperCase();
        const t = 4294967295 * Math.random() | 0
          , e = 4294967295 * Math.random() | 0
          , n = 4294967295 * Math.random() | 0
          , i = 4294967295 * Math.random() | 0;
        return (ga[255 & t] + ga[t >> 8 & 255] + ga[t >> 16 & 255] + ga[t >> 24 & 255] + "-" + ga[255 & e] + ga[e >> 8 & 255] + "-" + ga[e >> 16 & 15 | 64] + ga[e >> 24 & 255] + "-" + ga[63 & n | 128] + ga[n >> 8 & 255] + "-" + ga[n >> 16 & 255] + ga[n >> 24 & 255] + ga[255 & i] + ga[i >> 8 & 255] + ga[i >> 16 & 255] + ga[i >> 24 & 255]).toUpperCase()
    }
    function _a(t, e, n) {
        return Math.max(e, Math.min(n, t))
    }
    function xa(t, e) {
        return (t % e + e) % e
    }
    function ba(t, e, n) {
        return (1 - n) * t + n * e
    }
    function wa(t) {
        return 0 == (t & t - 1) && 0 !== t
    }
    function Ma(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
    }
    function Sa(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
    }
    var Ta = Object.freeze({
        __proto__: null,
        DEG2RAD: fa,
        RAD2DEG: ma,
        generateUUID: ya,
        clamp: _a,
        euclideanModulo: xa,
        mapLinear: function(t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        inverseLerp: function(t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0
        },
        lerp: ba,
        damp: function(t, e, n, i) {
            return ba(t, e, 1 - Math.exp(-n * i))
        },
        pingpong: function(t, e=1) {
            return e - Math.abs(xa(t, 2 * e) - e)
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        seededRandom: function(t) {
            return void 0 !== t && (pa = t % 2147483647),
            pa = 16807 * pa % 2147483647,
            (pa - 1) / 2147483646
        },
        degToRad: function(t) {
            return t * fa
        },
        radToDeg: function(t) {
            return t * ma
        },
        isPowerOfTwo: wa,
        ceilPowerOfTwo: Ma,
        floorPowerOfTwo: Sa,
        setQuaternionFromProperEuler: function(t, e, n, i, r) {
            const s = Math.cos
              , o = Math.sin
              , a = s(n / 2)
              , l = o(n / 2)
              , c = s((e + i) / 2)
              , h = o((e + i) / 2)
              , u = s((e - i) / 2)
              , d = o((e - i) / 2)
              , p = s((i - e) / 2)
              , f = o((i - e) / 2);
            switch (r) {
            case "XYX":
                t.set(a * h, l * u, l * d, a * c);
                break;
            case "YZY":
                t.set(l * d, a * h, l * u, a * c);
                break;
            case "ZXZ":
                t.set(l * u, l * d, a * h, a * c);
                break;
            case "XZX":
                t.set(a * h, l * f, l * p, a * c);
                break;
            case "YXY":
                t.set(l * p, a * h, l * f, a * c);
                break;
            case "ZYZ":
                t.set(l * f, l * p, a * h, a * c);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    });
    class Ea {
        constructor(t=0, e=0) {
            this.x = t,
            this.y = e
        }
        get width() {
            return this.x
        }
        set width(t) {
            this.x = t
        }
        get height() {
            return this.y
        }
        set height(t) {
            this.y = t
        }
        set(t, e) {
            return this.x = t,
            this.y = e,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        }
        multiply(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this
        }
        divide(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
            const e = this.x
              , n = this.y
              , i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6],
            this.y = i[1] * e + i[4] * n + i[7],
            this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y
        }
        cross(t) {
            return this.x * t.y - this.y * t.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x
              , n = this.y - t.y;
            return e * e + n * n
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n,
            this.y = t.y + (e.y - t.y) * n,
            this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t
        }
        fromBufferAttribute(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this
        }
        rotateAround(t, e) {
            const n = Math.cos(e)
              , i = Math.sin(e)
              , r = this.x - t.x
              , s = this.y - t.y;
            return this.x = r * n - s * i + t.x,
            this.y = r * i + s * n + t.y,
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
        *[Symbol.iterator]() {
            yield this.x,
            yield this.y
        }
    }
    Ea.prototype.isVector2 = !0;
    class Aa {
        constructor() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        set(t, e, n, i, r, s, o, a, l) {
            const c = this.elements;
            return c[0] = t,
            c[1] = i,
            c[2] = o,
            c[3] = e,
            c[4] = r,
            c[5] = a,
            c[6] = n,
            c[7] = s,
            c[8] = l,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        }
        copy(t) {
            const e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        }
        setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        }
        multiply(t) {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements
              , i = e.elements
              , r = this.elements
              , s = n[0]
              , o = n[3]
              , a = n[6]
              , l = n[1]
              , c = n[4]
              , h = n[7]
              , u = n[2]
              , d = n[5]
              , p = n[8]
              , f = i[0]
              , m = i[3]
              , g = i[6]
              , v = i[1]
              , y = i[4]
              , _ = i[7]
              , x = i[2]
              , b = i[5]
              , w = i[8];
            return r[0] = s * f + o * v + a * x,
            r[3] = s * m + o * y + a * b,
            r[6] = s * g + o * _ + a * w,
            r[1] = l * f + c * v + h * x,
            r[4] = l * m + c * y + h * b,
            r[7] = l * g + c * _ + h * w,
            r[2] = u * f + d * v + p * x,
            r[5] = u * m + d * y + p * b,
            r[8] = u * g + d * _ + p * w,
            this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        }
        determinant() {
            const t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , s = t[4]
              , o = t[5]
              , a = t[6]
              , l = t[7]
              , c = t[8];
            return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
        }
        invert() {
            const t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , s = t[4]
              , o = t[5]
              , a = t[6]
              , l = t[7]
              , c = t[8]
              , h = c * s - o * l
              , u = o * a - c * r
              , d = l * r - s * a
              , p = e * h + n * u + i * d;
            if (0 === p)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return t[0] = h * f,
            t[1] = (i * l - c * n) * f,
            t[2] = (o * n - i * s) * f,
            t[3] = u * f,
            t[4] = (c * e - i * a) * f,
            t[5] = (i * r - o * e) * f,
            t[6] = d * f,
            t[7] = (n * a - l * e) * f,
            t[8] = (s * e - n * r) * f,
            this
        }
        transpose() {
            let t;
            const e = this.elements;
            return t = e[1],
            e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        }
        getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose()
        }
        transposeIntoArray(t) {
            const e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        }
        setUvTransform(t, e, n, i, r, s, o) {
            const a = Math.cos(r)
              , l = Math.sin(r);
            return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1),
            this
        }
        scale(t, e) {
            const n = this.elements;
            return n[0] *= t,
            n[3] *= t,
            n[6] *= t,
            n[1] *= e,
            n[4] *= e,
            n[7] *= e,
            this
        }
        rotate(t) {
            const e = Math.cos(t)
              , n = Math.sin(t)
              , i = this.elements
              , r = i[0]
              , s = i[3]
              , o = i[6]
              , a = i[1]
              , l = i[4]
              , c = i[7];
            return i[0] = e * r + n * a,
            i[3] = e * s + n * l,
            i[6] = e * o + n * c,
            i[1] = -n * r + e * a,
            i[4] = -n * s + e * l,
            i[7] = -n * o + e * c,
            this
        }
        translate(t, e) {
            const n = this.elements;
            return n[0] += t * n[2],
            n[3] += t * n[5],
            n[6] += t * n[8],
            n[1] += e * n[2],
            n[4] += e * n[5],
            n[7] += e * n[8],
            this
        }
        equals(t) {
            const e = this.elements
              , n = t.elements;
            for (let t = 0; t < 9; t++)
                if (e[t] !== n[t])
                    return !1;
            return !0
        }
        fromArray(t, e=0) {
            for (let n = 0; n < 9; n++)
                this.elements[n] = t[n + e];
            return this
        }
        toArray(t=[], e=0) {
            const n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }
    function Ra(t) {
        if (0 === t.length)
            return -1 / 0;
        let e = t[0];
        for (let n = 1, i = t.length; n < i; ++n)
            t[n] > e && (e = t[n]);
        return e
    }
    function La(t) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", t)
    }
    function Ca(t, e=0) {
        let n = 3735928559 ^ e
          , i = 1103547991 ^ e;
        for (let e, r = 0; r < t.length; r++)
            e = t.charCodeAt(r),
            n = Math.imul(n ^ e, 2654435761),
            i = Math.imul(i ^ e, 1597334677);
        return n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(i ^ i >>> 13, 3266489909),
        i = Math.imul(i ^ i >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909),
        4294967296 * (2097151 & i) + (n >>> 0)
    }
    let Pa;
    Aa.prototype.isMatrix3 = !0,
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array;
    class Da {
        static getDataURL(t) {
            if (/^data:/i.test(t.src))
                return t.src;
            if ("undefined" == typeof HTMLCanvasElement)
                return t.src;
            let e;
            if (t instanceof HTMLCanvasElement)
                e = t;
            else {
                void 0 === Pa && (Pa = La("canvas")),
                Pa.width = t.width,
                Pa.height = t.height;
                const n = Pa.getContext("2d");
                t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                e = Pa
            }
            return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
            e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
        }
    }
    let Ia = 0;
    class Oa extends da {
        constructor(t=Oa.DEFAULT_IMAGE, e=Oa.DEFAULT_MAPPING, n=1001, i=1001, r=1006, s=1008, o=1023, a=1009, l=1, c=3e3) {
            super(),
            Object.defineProperty(this, "id", {
                value: Ia++
            }),
            this.uuid = ya(),
            this.name = "",
            this.image = t,
            this.mipmaps = [],
            this.mapping = e,
            this.wrapS = n,
            this.wrapT = i,
            this.magFilter = r,
            this.minFilter = s,
            this.anisotropy = l,
            this.format = o,
            this.internalFormat = null,
            this.type = a,
            this.offset = new Ea(0,0),
            this.repeat = new Ea(1,1),
            this.center = new Ea(0,0),
            this.rotation = 0,
            this.matrixAutoUpdate = !0,
            this.matrix = new Aa,
            this.generateMipmaps = !0,
            this.premultiplyAlpha = !1,
            this.flipY = !0,
            this.unpackAlignment = 4,
            this.encoding = c,
            this.userData = {},
            this.version = 0,
            this.onUpdate = null,
            this.isRenderTargetTexture = !1
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.internalFormat = t.internalFormat,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const i = this.image;
                if (void 0 === i.uuid && (i.uuid = ya()),
                !e && void 0 === t.images[i.uuid]) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++)
                            i[t].isDataTexture ? e.push(ka(i[t].image)) : e.push(ka(i[t]))
                    } else
                        e = ka(i);
                    t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: e
                    }
                }
                n.image = i.uuid
            }
            return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            e || (t.textures[this.uuid] = n),
            n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(t) {
            if (300 !== this.mapping)
                return t;
            if (t.applyMatrix3(this.matrix),
            t.x < 0 || t.x > 1)
                switch (this.wrapS) {
                case Oo:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case ko:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case No:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
            if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                case Oo:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case ko:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case No:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
            return this.flipY && (t.y = 1 - t.y),
            t
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
    }
    function ka(t) {
        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Da.getDataURL(t) : t.data ? {
            data: Array.prototype.slice.call(t.data),
            width: t.width,
            height: t.height,
            type: t.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."),
        {})
    }
    Oa.DEFAULT_IMAGE = void 0,
    Oa.DEFAULT_MAPPING = 300,
    Oa.prototype.isTexture = !0;
    class Na {
        constructor(t=0, e=0, n=0, i=1) {
            this.x = t,
            this.y = e,
            this.z = n,
            this.w = i
        }
        get width() {
            return this.z
        }
        set width(t) {
            this.z = t
        }
        get height() {
            return this.w
        }
        set height(t) {
            this.w = t
        }
        set(t, e, n, i) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this.w = i,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this.w = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setZ(t) {
            return this.z = t,
            this
        }
        setW(t) {
            return this.w = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        }
        multiply(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this.w *= t.w,
            this
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        }
        applyMatrix4(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = this.w
              , s = t.elements;
            return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r,
            this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r,
            this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r,
            this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        }
        setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const s = .01
              , o = .1
              , a = t.elements
              , l = a[0]
              , c = a[4]
              , h = a[8]
              , u = a[1]
              , d = a[5]
              , p = a[9]
              , f = a[2]
              , m = a[6]
              , g = a[10];
            if (Math.abs(c - u) < s && Math.abs(h - f) < s && Math.abs(p - m) < s) {
                if (Math.abs(c + u) < o && Math.abs(h + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o)
                    return this.set(1, 0, 0, 0),
                    this;
                e = Math.PI;
                const t = (l + 1) / 2
                  , a = (d + 1) / 2
                  , v = (g + 1) / 2
                  , y = (c + u) / 4
                  , _ = (h + f) / 4
                  , x = (p + m) / 4;
                return t > a && t > v ? t < s ? (n = 0,
                i = .707106781,
                r = .707106781) : (n = Math.sqrt(t),
                i = y / n,
                r = _ / n) : a > v ? a < s ? (n = .707106781,
                i = 0,
                r = .707106781) : (i = Math.sqrt(a),
                n = y / i,
                r = x / i) : v < s ? (n = .707106781,
                i = .707106781,
                r = 0) : (r = Math.sqrt(v),
                n = _ / r,
                i = x / r),
                this.set(n, i, r, e),
                this
            }
            let v = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c));
            return Math.abs(v) < .001 && (v = 1),
            this.x = (m - p) / v,
            this.y = (h - f) / v,
            this.z = (u - c) / v,
            this.w = Math.acos((l + d + g - 1) / 2),
            this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this.w = Math.max(t, Math.min(e, this.w)),
            this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n,
            this.y = t.y + (e.y - t.y) * n,
            this.z = t.z + (e.z - t.z) * n,
            this.w = t.w + (e.w - t.w) * n,
            this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        }
        fromBufferAttribute(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
        *[Symbol.iterator]() {
            yield this.x,
            yield this.y,
            yield this.z,
            yield this.w
        }
    }
    Na.prototype.isVector4 = !0;
    class za extends da {
        constructor(t, e, n={}) {
            super(),
            this.width = t,
            this.height = e,
            this.depth = 1,
            this.scissor = new Na(0,0,t,e),
            this.scissorTest = !1,
            this.viewport = new Na(0,0,t,e),
            this.texture = new Oa(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
            this.texture.isRenderTargetTexture = !0,
            this.texture.image = {
                width: t,
                height: e,
                depth: 1
            },
            this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
            this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null,
            this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Uo,
            this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
            this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
            this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }
        setTexture(t) {
            t.image = {
                width: this.width,
                height: this.height,
                depth: this.depth
            },
            this.texture = t
        }
        setSize(t, e, n=1) {
            this.width === t && this.height === e && this.depth === n || (this.width = t,
            this.height = e,
            this.depth = n,
            this.texture.image.width = t,
            this.texture.image.height = e,
            this.texture.image.depth = n,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.width = t.width,
            this.height = t.height,
            this.depth = t.depth,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.texture.image = {
                ...this.texture.image
            },
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    za.prototype.isWebGLRenderTarget = !0,
    class extends za {
        constructor(t, e, n) {
            super(t, e);
            const i = this.texture;
            this.texture = [];
            for (let t = 0; t < n; t++)
                this.texture[t] = i.clone()
        }
        setSize(t, e, n=1) {
            if (this.width !== t || this.height !== e || this.depth !== n) {
                this.width = t,
                this.height = e,
                this.depth = n;
                for (let i = 0, r = this.texture.length; i < r; i++)
                    this.texture[i].image.width = t,
                    this.texture[i].image.height = e,
                    this.texture[i].image.depth = n;
                this.dispose()
            }
            return this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e),
            this
        }
        copy(t) {
            this.dispose(),
            this.width = t.width,
            this.height = t.height,
            this.depth = t.depth,
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this.texture.length = 0;
            for (let e = 0, n = t.texture.length; e < n; e++)
                this.texture[e] = t.texture[e].clone();
            return this
        }
    }
    .prototype.isWebGLMultipleRenderTargets = !0;
    class Ba extends za {
        constructor(t, e, n) {
            super(t, e, n),
            this.samples = 4
        }
        copy(t) {
            return super.copy.call(this, t),
            this.samples = t.samples,
            this
        }
    }
    Ba.prototype.isWebGLMultisampleRenderTarget = !0;
    class Fa {
        constructor(t=0, e=0, n=0, i=1) {
            this._x = t,
            this._y = e,
            this._z = n,
            this._w = i
        }
        static slerp(t, e, n, i) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
            n.slerpQuaternions(t, e, i)
        }
        static slerpFlat(t, e, n, i, r, s, o) {
            let a = n[i + 0]
              , l = n[i + 1]
              , c = n[i + 2]
              , h = n[i + 3];
            const u = r[s + 0]
              , d = r[s + 1]
              , p = r[s + 2]
              , f = r[s + 3];
            if (0 === o)
                return t[e + 0] = a,
                t[e + 1] = l,
                t[e + 2] = c,
                void (t[e + 3] = h);
            if (1 === o)
                return t[e + 0] = u,
                t[e + 1] = d,
                t[e + 2] = p,
                void (t[e + 3] = f);
            if (h !== f || a !== u || l !== d || c !== p) {
                let t = 1 - o;
                const e = a * u + l * d + c * p + h * f
                  , n = e >= 0 ? 1 : -1
                  , i = 1 - e * e;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i)
                      , s = Math.atan2(r, e * n);
                    t = Math.sin(t * s) / r,
                    o = Math.sin(o * s) / r
                }
                const r = o * n;
                if (a = a * t + u * r,
                l = l * t + d * r,
                c = c * t + p * r,
                h = h * t + f * r,
                t === 1 - o) {
                    const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                    a *= t,
                    l *= t,
                    c *= t,
                    h *= t
                }
            }
            t[e] = a,
            t[e + 1] = l,
            t[e + 2] = c,
            t[e + 3] = h
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const o = n[i]
              , a = n[i + 1]
              , l = n[i + 2]
              , c = n[i + 3]
              , h = r[s]
              , u = r[s + 1]
              , d = r[s + 2]
              , p = r[s + 3];
            return t[e] = o * p + c * h + a * d - l * u,
            t[e + 1] = a * p + c * u + l * h - o * d,
            t[e + 2] = l * p + c * d + o * u - a * h,
            t[e + 3] = c * p - o * h - a * u - l * d,
            t
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t,
            this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(t) {
            this._w = t,
            this._onChangeCallback()
        }
        set(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._w = i,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        }
        copy(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this._onChangeCallback(),
            this
        }
        setFromEuler(t, e) {
            if (!t || !t.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const n = t._x
              , i = t._y
              , r = t._z
              , s = t._order
              , o = Math.cos
              , a = Math.sin
              , l = o(n / 2)
              , c = o(i / 2)
              , h = o(r / 2)
              , u = a(n / 2)
              , d = a(i / 2)
              , p = a(r / 2);
            switch (s) {
            case "XYZ":
                this._x = u * c * h + l * d * p,
                this._y = l * d * h - u * c * p,
                this._z = l * c * p + u * d * h,
                this._w = l * c * h - u * d * p;
                break;
            case "YXZ":
                this._x = u * c * h + l * d * p,
                this._y = l * d * h - u * c * p,
                this._z = l * c * p - u * d * h,
                this._w = l * c * h + u * d * p;
                break;
            case "ZXY":
                this._x = u * c * h - l * d * p,
                this._y = l * d * h + u * c * p,
                this._z = l * c * p + u * d * h,
                this._w = l * c * h - u * d * p;
                break;
            case "ZYX":
                this._x = u * c * h - l * d * p,
                this._y = l * d * h + u * c * p,
                this._z = l * c * p - u * d * h,
                this._w = l * c * h + u * d * p;
                break;
            case "YZX":
                this._x = u * c * h + l * d * p,
                this._y = l * d * h + u * c * p,
                this._z = l * c * p - u * d * h,
                this._w = l * c * h - u * d * p;
                break;
            case "XZY":
                this._x = u * c * h - l * d * p,
                this._y = l * d * h - u * c * p,
                this._z = l * c * p + u * d * h,
                this._w = l * c * h + u * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
            }
            return !1 !== e && this._onChangeCallback(),
            this
        }
        setFromAxisAngle(t, e) {
            const n = e / 2
              , i = Math.sin(n);
            return this._x = t.x * i,
            this._y = t.y * i,
            this._z = t.z * i,
            this._w = Math.cos(n),
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(t) {
            const e = t.elements
              , n = e[0]
              , i = e[4]
              , r = e[8]
              , s = e[1]
              , o = e[5]
              , a = e[9]
              , l = e[2]
              , c = e[6]
              , h = e[10]
              , u = n + o + h;
            if (u > 0) {
                const t = .5 / Math.sqrt(u + 1);
                this._w = .25 / t,
                this._x = (c - a) * t,
                this._y = (r - l) * t,
                this._z = (s - i) * t
            } else if (n > o && n > h) {
                const t = 2 * Math.sqrt(1 + n - o - h);
                this._w = (c - a) / t,
                this._x = .25 * t,
                this._y = (i + s) / t,
                this._z = (r + l) / t
            } else if (o > h) {
                const t = 2 * Math.sqrt(1 + o - n - h);
                this._w = (r - l) / t,
                this._x = (i + s) / t,
                this._y = .25 * t,
                this._z = (a + c) / t
            } else {
                const t = 2 * Math.sqrt(1 + h - n - o);
                this._w = (s - i) / t,
                this._x = (r + l) / t,
                this._y = (a + c) / t,
                this._z = .25 * t
            }
            return this._onChangeCallback(),
            this
        }
        setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return n < Number.EPSILON ? (n = 0,
            Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
            this._y = t.x,
            this._z = 0,
            this._w = n) : (this._x = 0,
            this._y = -t.z,
            this._z = t.y,
            this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
            this._y = t.z * e.x - t.x * e.z,
            this._z = t.x * e.y - t.y * e.x,
            this._w = n),
            this.normalize()
        }
        angleTo(t) {
            return 2 * Math.acos(Math.abs(_a(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n)
                return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i),
            this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let t = this.length();
            return 0 === t ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (t = 1 / t,
            this._x = this._x * t,
            this._y = this._y * t,
            this._z = this._z * t,
            this._w = this._w * t),
            this._onChangeCallback(),
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
            return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
            const n = t._x
              , i = t._y
              , r = t._z
              , s = t._w
              , o = e._x
              , a = e._y
              , l = e._z
              , c = e._w;
            return this._x = n * c + s * o + i * l - r * a,
            this._y = i * c + s * a + r * o - n * l,
            this._z = r * c + s * l + n * a - i * o,
            this._w = s * c - n * o - i * a - r * l,
            this._onChangeCallback(),
            this
        }
        slerp(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            const n = this._x
              , i = this._y
              , r = this._z
              , s = this._w;
            let o = s * t._w + n * t._x + i * t._y + r * t._z;
            if (o < 0 ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            o = -o) : this.copy(t),
            o >= 1)
                return this._w = s,
                this._x = n,
                this._y = i,
                this._z = r,
                this;
            const a = 1 - o * o;
            if (a <= Number.EPSILON) {
                const t = 1 - e;
                return this._w = t * s + e * this._w,
                this._x = t * n + e * this._x,
                this._y = t * i + e * this._y,
                this._z = t * r + e * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            const l = Math.sqrt(a)
              , c = Math.atan2(l, o)
              , h = Math.sin((1 - e) * c) / l
              , u = Math.sin(e * c) / l;
            return this._w = s * h + this._w * u,
            this._x = n * h + this._x * u,
            this._y = i * h + this._y * u,
            this._z = r * h + this._z * u,
            this._onChangeCallback(),
            this
        }
        slerpQuaternions(t, e, n) {
            this.copy(t).slerp(e, n)
        }
        random() {
            const t = Math.random()
              , e = Math.sqrt(1 - t)
              , n = Math.sqrt(t)
              , i = 2 * Math.PI * Math.random()
              , r = 2 * Math.PI * Math.random();
            return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e=0) {
            return this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this._onChangeCallback(),
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        }
        fromBufferAttribute(t, e) {
            return this._x = t.getX(e),
            this._y = t.getY(e),
            this._z = t.getZ(e),
            this._w = t.getW(e),
            this
        }
        _onChange(t) {
            return this._onChangeCallback = t,
            this
        }
        _onChangeCallback() {}
    }
    Fa.prototype.isQuaternion = !0;
    class Ua {
        constructor(t=0, e=0, n=0) {
            this.x = t,
            this.y = e,
            this.z = n
        }
        set(t, e, n) {
            return void 0 === n && (n = this.z),
            this.x = t,
            this.y = e,
            this.z = n,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setZ(t) {
            return this.z = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(t, e)) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        }
        multiplyVectors(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        }
        applyEuler(t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(Va.setFromEuler(t))
        }
        applyAxisAngle(t, e) {
            return this.applyQuaternion(Va.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i,
            this.y = r[1] * e + r[4] * n + r[7] * i,
            this.z = r[2] * e + r[5] * n + r[8] * i,
            this
        }
        applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements
              , s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s,
            this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s,
            this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s,
            this
        }
        applyQuaternion(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.x
              , s = t.y
              , o = t.z
              , a = t.w
              , l = a * e + s * i - o * n
              , c = a * n + o * e - r * i
              , h = a * i + r * n - s * e
              , u = -r * e - s * n - o * i;
            return this.x = l * a + u * -r + c * -o - h * -s,
            this.y = c * a + u * -s + h * -r - l * -o,
            this.z = h * a + u * -o + l * -s - c * -r,
            this
        }
        project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i,
            this.y = r[1] * e + r[5] * n + r[9] * i,
            this.z = r[2] * e + r[6] * n + r[10] * i,
            this.normalize()
        }
        divide(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n,
            this.y = t.y + (e.y - t.y) * n,
            this.z = t.z + (e.z - t.z) * n,
            this
        }
        cross(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(t, e)) : this.crossVectors(this, t)
        }
        crossVectors(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z
              , s = e.x
              , o = e.y
              , a = e.z;
            return this.x = i * a - r * o,
            this.y = r * s - n * a,
            this.z = n * o - i * s,
            this
        }
        projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e)
                return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        }
        projectOnPlane(t) {
            return Ha.copy(this).projectOnVector(t),
            this.sub(Ha)
        }
        reflect(t) {
            return this.sub(Ha.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e)
                return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(_a(n, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x
              , n = this.y - t.y
              , i = this.z - t.z;
            return e * e + n * n + i * i
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return this.x = i * Math.sin(n),
            this.y = Math.cos(e) * t,
            this.z = i * Math.cos(n),
            this
        }
        setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, n) {
            return this.x = t * Math.sin(e),
            this.y = n,
            this.z = t * Math.cos(e),
            this
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        }
        setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length()
              , n = this.setFromMatrixColumn(t, 1).length()
              , i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e,
            this.y = n,
            this.z = i,
            this
        }
        setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e)
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        }
        fromBufferAttribute(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
        randomDirection() {
            const t = 2 * (Math.random() - .5)
              , e = Math.random() * Math.PI * 2
              , n = Math.sqrt(1 - t ** 2);
            return this.x = n * Math.cos(e),
            this.y = n * Math.sin(e),
            this.z = t,
            this
        }
        *[Symbol.iterator]() {
            yield this.x,
            yield this.y,
            yield this.z
        }
    }
    Ua.prototype.isVector3 = !0;
    const Ha = new Ua
      , Va = new Fa;
    class Ga {
        constructor(t=new Ua(1 / 0,1 / 0,1 / 0), e=new Ua(-1 / 0,-1 / 0,-1 / 0)) {
            this.min = t,
            this.max = e
        }
        set(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        }
        setFromArray(t) {
            let e = 1 / 0
              , n = 1 / 0
              , i = 1 / 0
              , r = -1 / 0
              , s = -1 / 0
              , o = -1 / 0;
            for (let a = 0, l = t.length; a < l; a += 3) {
                const l = t[a]
                  , c = t[a + 1]
                  , h = t[a + 2];
                l < e && (e = l),
                c < n && (n = c),
                h < i && (i = h),
                l > r && (r = l),
                c > s && (s = c),
                h > o && (o = h)
            }
            return this.min.set(e, n, i),
            this.max.set(r, s, o),
            this
        }
        setFromBufferAttribute(t) {
            let e = 1 / 0
              , n = 1 / 0
              , i = 1 / 0
              , r = -1 / 0
              , s = -1 / 0
              , o = -1 / 0;
            for (let a = 0, l = t.count; a < l; a++) {
                const l = t.getX(a)
                  , c = t.getY(a)
                  , h = t.getZ(a);
                l < e && (e = l),
                c < n && (n = c),
                h < i && (i = h),
                l > r && (r = l),
                c > s && (s = c),
                h > o && (o = h)
            }
            return this.min.set(e, n, i),
            this.max.set(r, s, o),
            this
        }
        setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        }
        setFromCenterAndSize(t, e) {
            const n = ja.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n),
            this.max.copy(t).add(n),
            this
        }
        setFromObject(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        }
        expandByVector(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        }
        expandByScalar(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        }
        expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
            Xa.copy(e.boundingBox),
            Xa.applyMatrix4(t.matrixWorld),
            this.union(Xa));
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++)
                this.expandByObject(n[t]);
            return this
        }
        containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        }
        getParameter(t, e) {
            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        }
        intersectsSphere(t) {
            return this.clampPoint(t.center, ja),
            ja.distanceToSquared(t.center) <= t.radius * t.radius
        }
        intersectsPlane(t) {
            let e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
            n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
            n = t.normal.x * this.min.x),
            t.normal.y > 0 ? (e += t.normal.y * this.min.y,
            n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            n += t.normal.y * this.min.y),
            t.normal.z > 0 ? (e += t.normal.z * this.min.z,
            n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            n += t.normal.z * this.min.z),
            e <= -t.constant && n >= -t.constant
        }
        intersectsTriangle(t) {
            if (this.isEmpty())
                return !1;
            this.getCenter($a),
            tl.subVectors(this.max, $a),
            qa.subVectors(t.a, $a),
            Ya.subVectors(t.b, $a),
            Za.subVectors(t.c, $a),
            Ja.subVectors(Ya, qa),
            Ka.subVectors(Za, Ya),
            Qa.subVectors(qa, Za);
            let e = [0, -Ja.z, Ja.y, 0, -Ka.z, Ka.y, 0, -Qa.z, Qa.y, Ja.z, 0, -Ja.x, Ka.z, 0, -Ka.x, Qa.z, 0, -Qa.x, -Ja.y, Ja.x, 0, -Ka.y, Ka.x, 0, -Qa.y, Qa.x, 0];
            return !!il(e, qa, Ya, Za, tl) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            !!il(e, qa, Ya, Za, tl) && (el.crossVectors(Ja, Ka),
            e = [el.x, el.y, el.z],
            il(e, qa, Ya, Za, tl)))
        }
        clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
            return ja.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        getBoundingSphere(t) {
            return this.getCenter(t.center),
            t.radius = .5 * this.getSize(ja).length(),
            t
        }
        intersect(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
        union(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        }
        applyMatrix4(t) {
            return this.isEmpty() || (Wa[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            Wa[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            Wa[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            Wa[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            Wa[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            Wa[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            Wa[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            Wa[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(Wa)),
            this
        }
        translate(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }
    Ga.prototype.isBox3 = !0;
    const Wa = [new Ua, new Ua, new Ua, new Ua, new Ua, new Ua, new Ua, new Ua]
      , ja = new Ua
      , Xa = new Ga
      , qa = new Ua
      , Ya = new Ua
      , Za = new Ua
      , Ja = new Ua
      , Ka = new Ua
      , Qa = new Ua
      , $a = new Ua
      , tl = new Ua
      , el = new Ua
      , nl = new Ua;
    function il(t, e, n, i, r) {
        for (let s = 0, o = t.length - 3; s <= o; s += 3) {
            nl.fromArray(t, s);
            const o = r.x * Math.abs(nl.x) + r.y * Math.abs(nl.y) + r.z * Math.abs(nl.z)
              , a = e.dot(nl)
              , l = n.dot(nl)
              , c = i.dot(nl);
            if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o)
                return !1
        }
        return !0
    }
    const rl = new Ga
      , sl = new Ua
      , ol = new Ua
      , al = new Ua;
    class ll {
        constructor(t=new Ua, e=-1) {
            this.center = t,
            this.radius = e
        }
        set(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        }
        setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : rl.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++)
                i = Math.max(i, n.distanceToSquared(t[e]));
            return this.radius = Math.sqrt(i),
            this
        }
        copy(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        }
        containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius
        }
        intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        }
        intersectsBox(t) {
            return t.intersectsSphere(this)
        }
        intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return e.copy(t),
            n > this.radius * this.radius && (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
            e
        }
        getBoundingBox(t) {
            return this.isEmpty() ? (t.makeEmpty(),
            t) : (t.set(this.center, this.center),
            t.expandByScalar(this.radius),
            t)
        }
        applyMatrix4(t) {
            return this.center.applyMatrix4(t),
            this.radius = this.radius * t.getMaxScaleOnAxis(),
            this
        }
        translate(t) {
            return this.center.add(t),
            this
        }
        expandByPoint(t) {
            al.subVectors(t, this.center);
            const e = al.lengthSq();
            if (e > this.radius * this.radius) {
                const t = Math.sqrt(e)
                  , n = .5 * (t - this.radius);
                this.center.add(al.multiplyScalar(n / t)),
                this.radius += n
            }
            return this
        }
        union(t) {
            return ol.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
            this.expandByPoint(sl.copy(t.center).add(ol)),
            this.expandByPoint(sl.copy(t.center).sub(ol)),
            this
        }
        equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const cl = new Ua
      , hl = new Ua
      , ul = new Ua
      , dl = new Ua
      , pl = new Ua
      , fl = new Ua
      , ml = new Ua;
    class gl {
        constructor(t=new Ua, e=new Ua(0,0,-1)) {
            this.origin = t,
            this.direction = e
        }
        set(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        }
        copy(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        }
        at(t, e) {
            return e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }
        lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        }
        recast(t) {
            return this.origin.copy(this.at(t, cl)),
            this
        }
        closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        }
        distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        }
        distanceSqToPoint(t) {
            const e = cl.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (cl.copy(this.direction).multiplyScalar(e).add(this.origin),
            cl.distanceToSquared(t))
        }
        distanceSqToSegment(t, e, n, i) {
            hl.copy(t).add(e).multiplyScalar(.5),
            ul.copy(e).sub(t).normalize(),
            dl.copy(this.origin).sub(hl);
            const r = .5 * t.distanceTo(e)
              , s = -this.direction.dot(ul)
              , o = dl.dot(this.direction)
              , a = -dl.dot(ul)
              , l = dl.lengthSq()
              , c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0)
                if (h = s * a - o,
                u = s * o - a,
                p = r * c,
                h >= 0)
                    if (u >= -p)
                        if (u <= p) {
                            const t = 1 / c;
                            h *= t,
                            u *= t,
                            d = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + l
                        } else
                            u = r,
                            h = Math.max(0, -(s * u + o)),
                            d = -h * h + u * (u + 2 * a) + l;
                    else
                        u = -r,
                        h = Math.max(0, -(s * u + o)),
                        d = -h * h + u * (u + 2 * a) + l;
                else
                    u <= -p ? (h = Math.max(0, -(-s * r + o)),
                    u = h > 0 ? -r : Math.min(Math.max(-r, -a), r),
                    d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0,
                    u = Math.min(Math.max(-r, -a), r),
                    d = u * (u + 2 * a) + l) : (h = Math.max(0, -(s * r + o)),
                    u = h > 0 ? r : Math.min(Math.max(-r, -a), r),
                    d = -h * h + u * (u + 2 * a) + l);
            else
                u = s > 0 ? -r : r,
                h = Math.max(0, -(s * u + o)),
                d = -h * h + u * (u + 2 * a) + l;
            return n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
            i && i.copy(ul).multiplyScalar(u).add(hl),
            d
        }
        intersectSphere(t, e) {
            cl.subVectors(t.center, this.origin);
            const n = cl.dot(this.direction)
              , i = cl.dot(cl) - n * n
              , r = t.radius * t.radius;
            if (i > r)
                return null;
            const s = Math.sqrt(r - i)
              , o = n - s
              , a = n + s;
            return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
        }
        intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }
        distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e)
                return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        }
        intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        }
        intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        }
        intersectBox(t, e) {
            let n, i, r, s, o, a;
            const l = 1 / this.direction.x
              , c = 1 / this.direction.y
              , h = 1 / this.direction.z
              , u = this.origin;
            return l >= 0 ? (n = (t.min.x - u.x) * l,
            i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l,
            i = (t.min.x - u.x) * l),
            c >= 0 ? (r = (t.min.y - u.y) * c,
            s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c,
            s = (t.min.y - u.y) * c),
            n > s || r > i ? null : ((r > n || n != n) && (n = r),
            (s < i || i != i) && (i = s),
            h >= 0 ? (o = (t.min.z - u.z) * h,
            a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h,
            a = (t.min.z - u.z) * h),
            n > a || o > i ? null : ((o > n || n != n) && (n = o),
            (a < i || i != i) && (i = a),
            i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        }
        intersectsBox(t) {
            return null !== this.intersectBox(t, cl)
        }
        intersectTriangle(t, e, n, i, r) {
            pl.subVectors(e, t),
            fl.subVectors(n, t),
            ml.crossVectors(pl, fl);
            let s, o = this.direction.dot(ml);
            if (o > 0) {
                if (i)
                    return null;
                s = 1
            } else {
                if (!(o < 0))
                    return null;
                s = -1,
                o = -o
            }
            dl.subVectors(this.origin, t);
            const a = s * this.direction.dot(fl.crossVectors(dl, fl));
            if (a < 0)
                return null;
            const l = s * this.direction.dot(pl.cross(dl));
            if (l < 0)
                return null;
            if (a + l > o)
                return null;
            const c = -s * dl.dot(ml);
            return c < 0 ? null : this.at(c / o, r)
        }
        applyMatrix4(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        }
        equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class vl {
        constructor() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        set(t, e, n, i, r, s, o, a, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = n,
            g[12] = i,
            g[1] = r,
            g[5] = s,
            g[9] = o,
            g[13] = a,
            g[2] = l,
            g[6] = c,
            g[10] = h,
            g[14] = u,
            g[3] = d,
            g[7] = p,
            g[11] = f,
            g[15] = m,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        clone() {
            return (new vl).fromArray(this.elements)
        }
        copy(t) {
            const e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            e[9] = n[9],
            e[10] = n[10],
            e[11] = n[11],
            e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            e[15] = n[15],
            this
        }
        copyPosition(t) {
            const e = this.elements
              , n = t.elements;
            return e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            this
        }
        setFromMatrix3(t) {
            const e = t.elements;
            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
            this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        }
        makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
            this
        }
        extractRotation(t) {
            const e = this.elements
              , n = t.elements
              , i = 1 / yl.setFromMatrixColumn(t, 0).length()
              , r = 1 / yl.setFromMatrixColumn(t, 1).length()
              , s = 1 / yl.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i,
            e[1] = n[1] * i,
            e[2] = n[2] * i,
            e[3] = 0,
            e[4] = n[4] * r,
            e[5] = n[5] * r,
            e[6] = n[6] * r,
            e[7] = 0,
            e[8] = n[8] * s,
            e[9] = n[9] * s,
            e[10] = n[10] * s,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        }
        makeRotationFromEuler(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const e = this.elements
              , n = t.x
              , i = t.y
              , r = t.z
              , s = Math.cos(n)
              , o = Math.sin(n)
              , a = Math.cos(i)
              , l = Math.sin(i)
              , c = Math.cos(r)
              , h = Math.sin(r);
            if ("XYZ" === t.order) {
                const t = s * c
                  , n = s * h
                  , i = o * c
                  , r = o * h;
                e[0] = a * c,
                e[4] = -a * h,
                e[8] = l,
                e[1] = n + i * l,
                e[5] = t - r * l,
                e[9] = -o * a,
                e[2] = r - t * l,
                e[6] = i + n * l,
                e[10] = s * a
            } else if ("YXZ" === t.order) {
                const t = a * c
                  , n = a * h
                  , i = l * c
                  , r = l * h;
                e[0] = t + r * o,
                e[4] = i * o - n,
                e[8] = s * l,
                e[1] = s * h,
                e[5] = s * c,
                e[9] = -o,
                e[2] = n * o - i,
                e[6] = r + t * o,
                e[10] = s * a
            } else if ("ZXY" === t.order) {
                const t = a * c
                  , n = a * h
                  , i = l * c
                  , r = l * h;
                e[0] = t - r * o,
                e[4] = -s * h,
                e[8] = i + n * o,
                e[1] = n + i * o,
                e[5] = s * c,
                e[9] = r - t * o,
                e[2] = -s * l,
                e[6] = o,
                e[10] = s * a
            } else if ("ZYX" === t.order) {
                const t = s * c
                  , n = s * h
                  , i = o * c
                  , r = o * h;
                e[0] = a * c,
                e[4] = i * l - n,
                e[8] = t * l + r,
                e[1] = a * h,
                e[5] = r * l + t,
                e[9] = n * l - i,
                e[2] = -l,
                e[6] = o * a,
                e[10] = s * a
            } else if ("YZX" === t.order) {
                const t = s * a
                  , n = s * l
                  , i = o * a
                  , r = o * l;
                e[0] = a * c,
                e[4] = r - t * h,
                e[8] = i * h + n,
                e[1] = h,
                e[5] = s * c,
                e[9] = -o * c,
                e[2] = -l * c,
                e[6] = n * h + i,
                e[10] = t - r * h
            } else if ("XZY" === t.order) {
                const t = s * a
                  , n = s * l
                  , i = o * a
                  , r = o * l;
                e[0] = a * c,
                e[4] = -h,
                e[8] = l * c,
                e[1] = t * h + r,
                e[5] = s * c,
                e[9] = n * h - i,
                e[2] = i * h - n,
                e[6] = o * c,
                e[10] = r * h + t
            }
            return e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        }
        makeRotationFromQuaternion(t) {
            return this.compose(xl, t, bl)
        }
        lookAt(t, e, n) {
            const i = this.elements;
            return Sl.subVectors(t, e),
            0 === Sl.lengthSq() && (Sl.z = 1),
            Sl.normalize(),
            wl.crossVectors(n, Sl),
            0 === wl.lengthSq() && (1 === Math.abs(n.z) ? Sl.x += 1e-4 : Sl.z += 1e-4,
            Sl.normalize(),
            wl.crossVectors(n, Sl)),
            wl.normalize(),
            Ml.crossVectors(Sl, wl),
            i[0] = wl.x,
            i[4] = Ml.x,
            i[8] = Sl.x,
            i[1] = wl.y,
            i[5] = Ml.y,
            i[9] = Sl.y,
            i[2] = wl.z,
            i[6] = Ml.z,
            i[10] = Sl.z,
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements
              , i = e.elements
              , r = this.elements
              , s = n[0]
              , o = n[4]
              , a = n[8]
              , l = n[12]
              , c = n[1]
              , h = n[5]
              , u = n[9]
              , d = n[13]
              , p = n[2]
              , f = n[6]
              , m = n[10]
              , g = n[14]
              , v = n[3]
              , y = n[7]
              , _ = n[11]
              , x = n[15]
              , b = i[0]
              , w = i[4]
              , M = i[8]
              , S = i[12]
              , T = i[1]
              , E = i[5]
              , A = i[9]
              , R = i[13]
              , L = i[2]
              , C = i[6]
              , P = i[10]
              , D = i[14]
              , I = i[3]
              , O = i[7]
              , k = i[11]
              , N = i[15];
            return r[0] = s * b + o * T + a * L + l * I,
            r[4] = s * w + o * E + a * C + l * O,
            r[8] = s * M + o * A + a * P + l * k,
            r[12] = s * S + o * R + a * D + l * N,
            r[1] = c * b + h * T + u * L + d * I,
            r[5] = c * w + h * E + u * C + d * O,
            r[9] = c * M + h * A + u * P + d * k,
            r[13] = c * S + h * R + u * D + d * N,
            r[2] = p * b + f * T + m * L + g * I,
            r[6] = p * w + f * E + m * C + g * O,
            r[10] = p * M + f * A + m * P + g * k,
            r[14] = p * S + f * R + m * D + g * N,
            r[3] = v * b + y * T + _ * L + x * I,
            r[7] = v * w + y * E + _ * C + x * O,
            r[11] = v * M + y * A + _ * P + x * k,
            r[15] = v * S + y * R + _ * D + x * N,
            this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        }
        determinant() {
            const t = this.elements
              , e = t[0]
              , n = t[4]
              , i = t[8]
              , r = t[12]
              , s = t[1]
              , o = t[5]
              , a = t[9]
              , l = t[13]
              , c = t[2]
              , h = t[6]
              , u = t[10]
              , d = t[14];
            return t[3] * (+r * a * h - i * l * h - r * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * h - e * o * d - r * s * h + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * h + e * o * u + i * s * h - n * s * u + n * a * c)
        }
        transpose() {
            const t = this.elements;
            let e;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        }
        setPosition(t, e, n) {
            const i = this.elements;
            return t.isVector3 ? (i[12] = t.x,
            i[13] = t.y,
            i[14] = t.z) : (i[12] = t,
            i[13] = e,
            i[14] = n),
            this
        }
        invert() {
            const t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , s = t[4]
              , o = t[5]
              , a = t[6]
              , l = t[7]
              , c = t[8]
              , h = t[9]
              , u = t[10]
              , d = t[11]
              , p = t[12]
              , f = t[13]
              , m = t[14]
              , g = t[15]
              , v = h * m * l - f * u * l + f * a * d - o * m * d - h * a * g + o * u * g
              , y = p * u * l - c * m * l - p * a * d + s * m * d + c * a * g - s * u * g
              , _ = c * f * l - p * h * l + p * o * d - s * f * d - c * o * g + s * h * g
              , x = p * h * a - c * f * a - p * o * u + s * f * u + c * o * m - s * h * m
              , b = e * v + n * y + i * _ + r * x;
            if (0 === b)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / b;
            return t[0] = v * w,
            t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * w,
            t[2] = (o * m * r - f * a * r + f * i * l - n * m * l - o * i * g + n * a * g) * w,
            t[3] = (h * a * r - o * u * r - h * i * l + n * u * l + o * i * d - n * a * d) * w,
            t[4] = y * w,
            t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * w,
            t[6] = (p * a * r - s * m * r - p * i * l + e * m * l + s * i * g - e * a * g) * w,
            t[7] = (s * u * r - c * a * r + c * i * l - e * u * l - s * i * d + e * a * d) * w,
            t[8] = _ * w,
            t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * w,
            t[10] = (s * f * r - p * o * r + p * n * l - e * f * l - s * n * g + e * o * g) * w,
            t[11] = (c * o * r - s * h * r - c * n * l + e * h * l + s * n * d - e * o * d) * w,
            t[12] = x * w,
            t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * w,
            t[14] = (p * o * i - s * f * i - p * n * a + e * f * a + s * n * m - e * o * m) * w,
            t[15] = (s * h * i - c * o * i + c * n * a - e * h * a - s * n * u + e * o * u) * w,
            this
        }
        scale(t) {
            const e = this.elements
              , n = t.x
              , i = t.y
              , r = t.z;
            return e[0] *= n,
            e[4] *= i,
            e[8] *= r,
            e[1] *= n,
            e[5] *= i,
            e[9] *= r,
            e[2] *= n,
            e[6] *= i,
            e[10] *= r,
            e[3] *= n,
            e[7] *= i,
            e[11] *= r,
            this
        }
        getMaxScaleOnAxis() {
            const t = this.elements
              , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
              , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
              , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        }
        makeTranslation(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
        }
        makeRotationX(t) {
            const e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
            this
        }
        makeRotationY(t) {
            const e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
            this
        }
        makeRotationZ(t) {
            const e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        makeRotationAxis(t, e) {
            const n = Math.cos(e)
              , i = Math.sin(e)
              , r = 1 - n
              , s = t.x
              , o = t.y
              , a = t.z
              , l = r * s
              , c = r * o;
            return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1),
            this
        }
        makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        }
        makeShear(t, e, n, i, r, s) {
            return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1),
            this
        }
        compose(t, e, n) {
            const i = this.elements
              , r = e._x
              , s = e._y
              , o = e._z
              , a = e._w
              , l = r + r
              , c = s + s
              , h = o + o
              , u = r * l
              , d = r * c
              , p = r * h
              , f = s * c
              , m = s * h
              , g = o * h
              , v = a * l
              , y = a * c
              , _ = a * h
              , x = n.x
              , b = n.y
              , w = n.z;
            return i[0] = (1 - (f + g)) * x,
            i[1] = (d + _) * x,
            i[2] = (p - y) * x,
            i[3] = 0,
            i[4] = (d - _) * b,
            i[5] = (1 - (u + g)) * b,
            i[6] = (m + v) * b,
            i[7] = 0,
            i[8] = (p + y) * w,
            i[9] = (m - v) * w,
            i[10] = (1 - (u + f)) * w,
            i[11] = 0,
            i[12] = t.x,
            i[13] = t.y,
            i[14] = t.z,
            i[15] = 1,
            this
        }
        decompose(t, e, n) {
            const i = this.elements;
            let r = yl.set(i[0], i[1], i[2]).length();
            const s = yl.set(i[4], i[5], i[6]).length()
              , o = yl.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
            t.x = i[12],
            t.y = i[13],
            t.z = i[14],
            _l.copy(this);
            const a = 1 / r
              , l = 1 / s
              , c = 1 / o;
            return _l.elements[0] *= a,
            _l.elements[1] *= a,
            _l.elements[2] *= a,
            _l.elements[4] *= l,
            _l.elements[5] *= l,
            _l.elements[6] *= l,
            _l.elements[8] *= c,
            _l.elements[9] *= c,
            _l.elements[10] *= c,
            e.setFromRotationMatrix(_l),
            n.x = r,
            n.y = s,
            n.z = o,
            this
        }
        makePerspective(t, e, n, i, r, s) {
            void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const o = this.elements
              , a = 2 * r / (e - t)
              , l = 2 * r / (n - i)
              , c = (e + t) / (e - t)
              , h = (n + i) / (n - i)
              , u = -(s + r) / (s - r)
              , d = -2 * s * r / (s - r);
            return o[0] = a,
            o[4] = 0,
            o[8] = c,
            o[12] = 0,
            o[1] = 0,
            o[5] = l,
            o[9] = h,
            o[13] = 0,
            o[2] = 0,
            o[6] = 0,
            o[10] = u,
            o[14] = d,
            o[3] = 0,
            o[7] = 0,
            o[11] = -1,
            o[15] = 0,
            this
        }
        makeOrthographic(t, e, n, i, r, s) {
            const o = this.elements
              , a = 1 / (e - t)
              , l = 1 / (n - i)
              , c = 1 / (s - r)
              , h = (e + t) * a
              , u = (n + i) * l
              , d = (s + r) * c;
            return o[0] = 2 * a,
            o[4] = 0,
            o[8] = 0,
            o[12] = -h,
            o[1] = 0,
            o[5] = 2 * l,
            o[9] = 0,
            o[13] = -u,
            o[2] = 0,
            o[6] = 0,
            o[10] = -2 * c,
            o[14] = -d,
            o[3] = 0,
            o[7] = 0,
            o[11] = 0,
            o[15] = 1,
            this
        }
        equals(t) {
            const e = this.elements
              , n = t.elements;
            for (let t = 0; t < 16; t++)
                if (e[t] !== n[t])
                    return !1;
            return !0
        }
        fromArray(t, e=0) {
            for (let n = 0; n < 16; n++)
                this.elements[n] = t[n + e];
            return this
        }
        toArray(t=[], e=0) {
            const n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t[e + 9] = n[9],
            t[e + 10] = n[10],
            t[e + 11] = n[11],
            t[e + 12] = n[12],
            t[e + 13] = n[13],
            t[e + 14] = n[14],
            t[e + 15] = n[15],
            t
        }
    }
    vl.prototype.isMatrix4 = !0;
    const yl = new Ua
      , _l = new vl
      , xl = new Ua(0,0,0)
      , bl = new Ua(1,1,1)
      , wl = new Ua
      , Ml = new Ua
      , Sl = new Ua
      , Tl = new vl
      , El = new Fa;
    class Al {
        constructor(t=0, e=0, n=0, i=Al.DefaultOrder) {
            this._x = t,
            this._y = e,
            this._z = n,
            this._order = i
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t,
            this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(t) {
            this._order = t,
            this._onChangeCallback()
        }
        set(t, e, n, i=this._order) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._order = i,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        }
        copy(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(t, e=this._order, n=!0) {
            const i = t.elements
              , r = i[0]
              , s = i[4]
              , o = i[8]
              , a = i[1]
              , l = i[5]
              , c = i[9]
              , h = i[2]
              , u = i[6]
              , d = i[10];
            switch (e) {
            case "XYZ":
                this._y = Math.asin(_a(o, -1, 1)),
                Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d),
                this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-_a(c, -1, 1)),
                Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d),
                this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, r),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(_a(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d),
                this._z = Math.atan2(-s, l)) : (this._y = 0,
                this._z = Math.atan2(a, r));
                break;
            case "ZYX":
                this._y = Math.asin(-_a(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d),
                this._z = Math.atan2(a, r)) : (this._x = 0,
                this._z = Math.atan2(-s, l));
                break;
            case "YZX":
                this._z = Math.asin(_a(a, -1, 1)),
                Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l),
                this._y = Math.atan2(-h, r)) : (this._x = 0,
                this._y = Math.atan2(o, d));
                break;
            case "XZY":
                this._z = Math.asin(-_a(s, -1, 1)),
                Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l),
                this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e,
            !0 === n && this._onChangeCallback(),
            this
        }
        setFromQuaternion(t, e, n) {
            return Tl.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(Tl, e, n)
        }
        setFromVector3(t, e=this._order) {
            return this.set(t.x, t.y, t.z, e)
        }
        reorder(t) {
            return El.setFromEuler(this),
            this.setFromQuaternion(El, t)
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        }
        fromArray(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        }
        toVector3(t) {
            return t ? t.set(this._x, this._y, this._z) : new Ua(this._x,this._y,this._z)
        }
        _onChange(t) {
            return this._onChangeCallback = t,
            this
        }
        _onChangeCallback() {}
    }
    Al.prototype.isEuler = !0,
    Al.DefaultOrder = "XYZ",
    Al.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class Rl {
        constructor() {
            this.mask = 1
        }
        set(t) {
            this.mask = 1 << t | 0
        }
        enable(t) {
            this.mask |= 1 << t | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(t) {
            this.mask ^= 1 << t | 0
        }
        disable(t) {
            this.mask &= ~(1 << t | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(t) {
            return 0 != (this.mask & t.mask)
        }
    }
    let Ll = 0;
    const Cl = new Ua
      , Pl = new Fa
      , Dl = new vl
      , Il = new Ua
      , Ol = new Ua
      , kl = new Ua
      , Nl = new Fa
      , zl = new Ua(1,0,0)
      , Bl = new Ua(0,1,0)
      , Fl = new Ua(0,0,1)
      , Ul = {
        type: "added"
    }
      , Hl = {
        type: "removed"
    };
    class Vl extends da {
        constructor() {
            super(),
            Object.defineProperty(this, "id", {
                value: Ll++
            }),
            this.uuid = ya(),
            this.name = "",
            this.type = "Object3D",
            this.parent = null,
            this.children = [],
            this.up = Vl.DefaultUp.clone();
            const t = new Ua
              , e = new Al
              , n = new Fa
              , i = new Ua(1,1,1);
            e._onChange((function() {
                n.setFromEuler(e, !1)
            }
            )),
            n._onChange((function() {
                e.setFromQuaternion(n, void 0, !1)
            }
            )),
            Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new vl
                },
                normalMatrix: {
                    value: new Aa
                }
            }),
            this.matrix = new vl,
            this.matrixWorld = new vl,
            this.matrixAutoUpdate = Vl.DefaultMatrixAutoUpdate,
            this.matrixWorldNeedsUpdate = !1,
            this.layers = new Rl,
            this.visible = !0,
            this.castShadow = !1,
            this.receiveShadow = !1,
            this.frustumCulled = !0,
            this.renderOrder = 0,
            this.animations = [],
            this.userData = {}
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(t) {
            return this.quaternion.premultiply(t),
            this
        }
        setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        }
        setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0)
        }
        setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t)
        }
        setRotationFromQuaternion(t) {
            this.quaternion.copy(t)
        }
        rotateOnAxis(t, e) {
            return Pl.setFromAxisAngle(t, e),
            this.quaternion.multiply(Pl),
            this
        }
        rotateOnWorldAxis(t, e) {
            return Pl.setFromAxisAngle(t, e),
            this.quaternion.premultiply(Pl),
            this
        }
        rotateX(t) {
            return this.rotateOnAxis(zl, t)
        }
        rotateY(t) {
            return this.rotateOnAxis(Bl, t)
        }
        rotateZ(t) {
            return this.rotateOnAxis(Fl, t)
        }
        translateOnAxis(t, e) {
            return Cl.copy(t).applyQuaternion(this.quaternion),
            this.position.add(Cl.multiplyScalar(e)),
            this
        }
        translateX(t) {
            return this.translateOnAxis(zl, t)
        }
        translateY(t) {
            return this.translateOnAxis(Bl, t)
        }
        translateZ(t) {
            return this.translateOnAxis(Fl, t)
        }
        localToWorld(t) {
            return t.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(t) {
            return t.applyMatrix4(Dl.copy(this.matrixWorld).invert())
        }
        lookAt(t, e, n) {
            t.isVector3 ? Il.copy(t) : Il.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
            Ol.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? Dl.lookAt(Ol, Il, this.up) : Dl.lookAt(Il, Ol, this.up),
            this.quaternion.setFromRotationMatrix(Dl),
            i && (Dl.extractRotation(i.matrixWorld),
            Pl.setFromRotationMatrix(Dl),
            this.quaternion.premultiply(Pl.invert()))
        }
        add(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
            this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            this.children.push(t),
            t.dispatchEvent(Ul)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
            this)
        }
        remove(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            const e = this.children.indexOf(t);
            return -1 !== e && (t.parent = null,
            this.children.splice(e, 1),
            t.dispatchEvent(Hl)),
            this
        }
        removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this),
            this
        }
        clear() {
            for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t];
                e.parent = null,
                e.dispatchEvent(Hl)
            }
            return this.children.length = 0,
            this
        }
        attach(t) {
            return this.updateWorldMatrix(!0, !1),
            Dl.copy(this.matrixWorld).invert(),
            null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
            Dl.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(Dl),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
        }
        getObjectById(t) {
            return this.getObjectByProperty("id", t)
        }
        getObjectByName(t) {
            return this.getObjectByProperty("name", t)
        }
        getObjectByProperty(t, e) {
            if (this[t] === e)
                return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i)
                    return i
            }
        }
        getWorldPosition(t) {
            return this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(t) {
            return this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ol, t, kl),
            t
        }
        getWorldScale(t) {
            return this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ol, Nl, t),
            t
        }
        getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        }
        raycast() {}
        traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++)
                e[n].traverse(t)
        }
        traverseVisible(t) {
            if (!1 === this.visible)
                return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++)
                e[n].traverseVisible(t)
        }
        traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            t = !0);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++)
                e[n].updateMatrixWorld(t)
        }
        updateWorldMatrix(t, e) {
            const n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === e) {
                const t = this.children;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e].updateWorldMatrix(!1, !0)
            }
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t
              , n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            },
            n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};
            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                n.uuid
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh && (i.type = "InstancedMesh",
            i.count = this.count,
            i.instanceMatrix = this.instanceMatrix.toJSON(),
            null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
                this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                const e = this.geometry.parameters;
                if (void 0 !== e && void 0 !== e.shapes) {
                    const n = e.shapes;
                    if (Array.isArray(n))
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            r(t.shapes, i)
                        }
                    else
                        r(t.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
            i.bindMatrix = this.bindMatrix.toArray(),
            void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
            i.skeleton = this.skeleton.uuid)),
            void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const e = [];
                    for (let n = 0, i = this.material.length; n < i; n++)
                        e.push(r(t.materials, this.material[n]));
                    i.material = e
                } else
                    i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let e = 0; e < this.children.length; e++)
                    i.children.push(this.children[e].toJSON(t).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let e = 0; e < this.animations.length; e++) {
                    const n = this.animations[e];
                    i.animations.push(r(t.animations, n))
                }
            }
            if (e) {
                const e = s(t.geometries)
                  , i = s(t.materials)
                  , r = s(t.textures)
                  , o = s(t.images)
                  , a = s(t.shapes)
                  , l = s(t.skeletons)
                  , c = s(t.animations);
                e.length > 0 && (n.geometries = e),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                o.length > 0 && (n.images = o),
                a.length > 0 && (n.shapes = a),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c)
            }
            return n.object = i,
            n;
            function s(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
        }
        clone(t) {
            return (new this.constructor).copy(this, t)
        }
        copy(t, e=!0) {
            if (this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.rotation.order = t.rotation.order,
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (let e = 0; e < t.children.length; e++) {
                    const n = t.children[e];
                    this.add(n.clone())
                }
            return this
        }
    }
    Vl.DefaultUp = new Ua(0,1,0),
    Vl.DefaultMatrixAutoUpdate = !0,
    Vl.prototype.isObject3D = !0;
    const Gl = new Ua
      , Wl = new Ua
      , jl = new Ua
      , Xl = new Ua
      , ql = new Ua
      , Yl = new Ua
      , Zl = new Ua
      , Jl = new Ua
      , Kl = new Ua
      , Ql = new Ua;
    class $l {
        constructor(t=new Ua, e=new Ua, n=new Ua) {
            this.a = t,
            this.b = e,
            this.c = n
        }
        static getNormal(t, e, n, i) {
            i.subVectors(n, e),
            Gl.subVectors(t, e),
            i.cross(Gl);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }
        static getBarycoord(t, e, n, i, r) {
            Gl.subVectors(i, e),
            Wl.subVectors(n, e),
            jl.subVectors(t, e);
            const s = Gl.dot(Gl)
              , o = Gl.dot(Wl)
              , a = Gl.dot(jl)
              , l = Wl.dot(Wl)
              , c = Wl.dot(jl)
              , h = s * l - o * o;
            if (0 === h)
                return r.set(-2, -1, -1);
            const u = 1 / h
              , d = (l * a - o * c) * u
              , p = (s * c - o * a) * u;
            return r.set(1 - d - p, p, d)
        }
        static containsPoint(t, e, n, i) {
            return this.getBarycoord(t, e, n, i, Xl),
            Xl.x >= 0 && Xl.y >= 0 && Xl.x + Xl.y <= 1
        }
        static getUV(t, e, n, i, r, s, o, a) {
            return this.getBarycoord(t, e, n, i, Xl),
            a.set(0, 0),
            a.addScaledVector(r, Xl.x),
            a.addScaledVector(s, Xl.y),
            a.addScaledVector(o, Xl.z),
            a
        }
        static isFrontFacing(t, e, n, i) {
            return Gl.subVectors(n, e),
            Wl.subVectors(t, e),
            Gl.cross(Wl).dot(i) < 0
        }
        set(t, e, n) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(n),
            this
        }
        setFromPointsAndIndices(t, e, n, i) {
            return this.a.copy(t[e]),
            this.b.copy(t[n]),
            this.c.copy(t[i]),
            this
        }
        setFromAttributeAndIndices(t, e, n, i) {
            return this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, n),
            this.c.fromBufferAttribute(t, i),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        }
        getArea() {
            return Gl.subVectors(this.c, this.b),
            Wl.subVectors(this.a, this.b),
            .5 * Gl.cross(Wl).length()
        }
        getMidpoint(t) {
            return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(t) {
            return $l.getNormal(this.a, this.b, this.c, t)
        }
        getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(t, e) {
            return $l.getBarycoord(t, this.a, this.b, this.c, e)
        }
        getUV(t, e, n, i, r) {
            return $l.getUV(t, this.a, this.b, this.c, e, n, i, r)
        }
        containsPoint(t) {
            return $l.containsPoint(t, this.a, this.b, this.c)
        }
        isFrontFacing(t) {
            return $l.isFrontFacing(this.a, this.b, this.c, t)
        }
        intersectsBox(t) {
            return t.intersectsTriangle(this)
        }
        closestPointToPoint(t, e) {
            const n = this.a
              , i = this.b
              , r = this.c;
            let s, o;
            ql.subVectors(i, n),
            Yl.subVectors(r, n),
            Jl.subVectors(t, n);
            const a = ql.dot(Jl)
              , l = Yl.dot(Jl);
            if (a <= 0 && l <= 0)
                return e.copy(n);
            Kl.subVectors(t, i);
            const c = ql.dot(Kl)
              , h = Yl.dot(Kl);
            if (c >= 0 && h <= c)
                return e.copy(i);
            const u = a * h - c * l;
            if (u <= 0 && a >= 0 && c <= 0)
                return s = a / (a - c),
                e.copy(n).addScaledVector(ql, s);
            Ql.subVectors(t, r);
            const d = ql.dot(Ql)
              , p = Yl.dot(Ql);
            if (p >= 0 && d <= p)
                return e.copy(r);
            const f = d * l - a * p;
            if (f <= 0 && l >= 0 && p <= 0)
                return o = l / (l - p),
                e.copy(n).addScaledVector(Yl, o);
            const m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0)
                return Zl.subVectors(r, i),
                o = (h - c) / (h - c + (d - p)),
                e.copy(i).addScaledVector(Zl, o);
            const g = 1 / (m + f + u);
            return s = f * g,
            o = u * g,
            e.copy(n).addScaledVector(ql, s).addScaledVector(Yl, o)
        }
        equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }
    let tc = 0;
    class ec extends da {
        constructor() {
            super(),
            Object.defineProperty(this, "id", {
                value: tc++
            }),
            this.uuid = ya(),
            this.name = "",
            this.type = "Material",
            this.fog = !0,
            this.blending = 1,
            this.side = 0,
            this.vertexColors = !1,
            this.opacity = 1,
            this.format = Zo,
            this.transparent = !1,
            this.blendSrc = 204,
            this.blendDst = 205,
            this.blendEquation = Co,
            this.blendSrcAlpha = null,
            this.blendDstAlpha = null,
            this.blendEquationAlpha = null,
            this.depthFunc = 3,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.stencilWriteMask = 255,
            this.stencilFunc = 519,
            this.stencilRef = 0,
            this.stencilFuncMask = 255,
            this.stencilFail = la,
            this.stencilZFail = la,
            this.stencilZPass = la,
            this.stencilWrite = !1,
            this.clippingPlanes = null,
            this.clipIntersection = !1,
            this.clipShadows = !1,
            this.shadowSide = null,
            this.colorWrite = !0,
            this.precision = null,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 0,
            this.dithering = !1,
            this.alphaToCoverage = !1,
            this.premultipliedAlpha = !1,
            this.visible = !0,
            this.toneMapped = !0,
            this.userData = {},
            this.version = 0,
            this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++,
            this._alphaTest = t
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(t) {
            if (void 0 !== t)
                for (const e in t) {
                    const n = t[e];
                    if (void 0 === n) {
                        console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                        this.flatShading = 1 === n;
                        continue
                    }
                    const i = this[e];
                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                }
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function i(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
            this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
            n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
            n.lightMapIntensity = this.lightMapIntensity),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
            this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
            void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission && (n.transmission = this.transmission),
            this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            this.format !== Zo && (n.format = this.format),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            n.colorWrite = this.colorWrite,
            n.stencilWrite = this.stencilWrite,
            n.stencilWriteMask = this.stencilWriteMask,
            n.stencilFunc = this.stencilFunc,
            n.stencilRef = this.stencilRef,
            n.stencilFuncMask = this.stencilFuncMask,
            n.stencilFail = this.stencilFail,
            n.stencilZFail = this.stencilZFail,
            n.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            e) {
                const e = i(t.textures)
                  , r = i(t.images);
                e.length > 0 && (n.textures = e),
                r.length > 0 && (n.images = r)
            }
            return n
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.blending = t.blending,
            this.side = t.side,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.format = t.format,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.stencilWriteMask = t.stencilWriteMask,
            this.stencilFunc = t.stencilFunc,
            this.stencilRef = t.stencilRef,
            this.stencilFuncMask = t.stencilFuncMask,
            this.stencilFail = t.stencilFail,
            this.stencilZFail = t.stencilZFail,
            this.stencilZPass = t.stencilZPass,
            this.stencilWrite = t.stencilWrite;
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
                const t = e.length;
                n = new Array(t);
                for (let i = 0; i !== t; ++i)
                    n[i] = e[i].clone()
            }
            return this.clippingPlanes = n,
            this.clipIntersection = t.clipIntersection,
            this.clipShadows = t.clipShadows,
            this.shadowSide = t.shadowSide,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.alphaToCoverage = t.alphaToCoverage,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.visible = t.visible,
            this.toneMapped = t.toneMapped,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
    }
    ec.prototype.isMaterial = !0;
    const nc = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , ic = {
        h: 0,
        s: 0,
        l: 0
    }
      , rc = {
        h: 0,
        s: 0,
        l: 0
    };
    function sc(t, e, n) {
        return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }
    function oc(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }
    function ac(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    class lc {
        constructor(t, e, n) {
            return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
        }
        set(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        }
        setScalar(t) {
            return this.r = t,
            this.g = t,
            this.b = t,
            this
        }
        setHex(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        }
        setRGB(t, e, n) {
            return this.r = t,
            this.g = e,
            this.b = n,
            this
        }
        setHSL(t, e, n) {
            if (t = xa(t, 1),
            e = _a(e, 0, 1),
            n = _a(n, 0, 1),
            0 === e)
                this.r = this.g = this.b = n;
            else {
                const i = n <= .5 ? n * (1 + e) : n + e - n * e
                  , r = 2 * n - i;
                this.r = sc(r, i, t + 1 / 3),
                this.g = sc(r, i, t),
                this.b = sc(r, i, t - 1 / 3)
            }
            return this
        }
        setStyle(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            let n;
            if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                let t;
                const i = n[1]
                  , r = n[2];
                switch (i) {
                case "rgb":
                case "rgba":
                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                        return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                        e(t[4]),
                        this;
                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                        return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                        e(t[4]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                        const n = parseFloat(t[1]) / 360
                          , i = parseInt(t[2], 10) / 100
                          , r = parseInt(t[3], 10) / 100;
                        return e(t[4]),
                        this.setHSL(n, i, r)
                    }
                }
            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                const t = n[1]
                  , e = t.length;
                if (3 === e)
                    return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                    this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                    this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                    this;
                if (6 === e)
                    return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                    this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                    this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                    this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        }
        setColorName(t) {
            const e = nc[t.toLowerCase()];
            return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
            this
        }
        clone() {
            return new this.constructor(this.r,this.g,this.b)
        }
        copy(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        }
        copyGammaToLinear(t, e=2) {
            return this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        }
        copyLinearToGamma(t, e=2) {
            const n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n),
            this.g = Math.pow(t.g, n),
            this.b = Math.pow(t.b, n),
            this
        }
        convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t),
            this
        }
        convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t),
            this
        }
        copySRGBToLinear(t) {
            return this.r = oc(t.r),
            this.g = oc(t.g),
            this.b = oc(t.b),
            this
        }
        copyLinearToSRGB(t) {
            return this.r = ac(t.r),
            this.g = ac(t.g),
            this.b = ac(t.b),
            this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this),
            this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this),
            this
        }
        getHex() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }
        getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }
        getHSL(t) {
            const e = this.r
              , n = this.g
              , i = this.b
              , r = Math.max(e, n, i)
              , s = Math.min(e, n, i);
            let o, a;
            const l = (s + r) / 2;
            if (s === r)
                o = 0,
                a = 0;
            else {
                const t = r - s;
                switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s),
                r) {
                case e:
                    o = (n - i) / t + (n < i ? 6 : 0);
                    break;
                case n:
                    o = (i - e) / t + 2;
                    break;
                case i:
                    o = (e - n) / t + 4
                }
                o /= 6
            }
            return t.h = o,
            t.s = a,
            t.l = l,
            t
        }
        getStyle() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }
        offsetHSL(t, e, n) {
            return this.getHSL(ic),
            ic.h += t,
            ic.s += e,
            ic.l += n,
            this.setHSL(ic.h, ic.s, ic.l),
            this
        }
        add(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        }
        addColors(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        }
        addScalar(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        }
        sub(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        }
        multiply(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        }
        multiplyScalar(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        }
        lerp(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        }
        lerpColors(t, e, n) {
            return this.r = t.r + (e.r - t.r) * n,
            this.g = t.g + (e.g - t.g) * n,
            this.b = t.b + (e.b - t.b) * n,
            this
        }
        lerpHSL(t, e) {
            this.getHSL(ic),
            t.getHSL(rc);
            const n = ba(ic.h, rc.h, e)
              , i = ba(ic.s, rc.s, e)
              , r = ba(ic.l, rc.l, e);
            return this.setHSL(n, i, r),
            this
        }
        equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        }
        fromArray(t, e=0) {
            return this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        }
        fromBufferAttribute(t, e) {
            return this.r = t.getX(e),
            this.g = t.getY(e),
            this.b = t.getZ(e),
            !0 === t.normalized && (this.r /= 255,
            this.g /= 255,
            this.b /= 255),
            this
        }
        toJSON() {
            return this.getHex()
        }
    }
    lc.NAMES = nc,
    lc.prototype.isColor = !0,
    lc.prototype.r = 1,
    lc.prototype.g = 1,
    lc.prototype.b = 1;
    class cc extends ec {
        constructor(t) {
            super(),
            this.type = "MeshBasicMaterial",
            this.color = new lc(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = 0,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this
        }
    }
    cc.prototype.isMeshBasicMaterial = !0;
    const hc = new Ua
      , uc = new Ea;
    class dc {
        constructor(t, e, n) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "",
            this.array = t,
            this.itemSize = e,
            this.count = void 0 !== t ? t.length / e : 0,
            this.normalized = !0 === n,
            this.usage = ca,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0
        }
        onUploadCallback() {}
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        setUsage(t) {
            return this.usage = t,
            this
        }
        copy(t) {
            return this.name = t.name,
            this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.usage = t.usage,
            this
        }
        copyAt(t, e, n) {
            t *= this.itemSize,
            n *= e.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        }
        copyArray(t) {
            return this.array.set(t),
            this
        }
        copyColorsArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                r = new lc),
                e[n++] = r.r,
                e[n++] = r.g,
                e[n++] = r.b
            }
            return this
        }
        copyVector2sArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                r = new Ea),
                e[n++] = r.x,
                e[n++] = r.y
            }
            return this
        }
        copyVector3sArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                r = new Ua),
                e[n++] = r.x,
                e[n++] = r.y,
                e[n++] = r.z
            }
            return this
        }
        copyVector4sArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                r = new Na),
                e[n++] = r.x,
                e[n++] = r.y,
                e[n++] = r.z,
                e[n++] = r.w
            }
            return this
        }
        applyMatrix3(t) {
            if (2 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                    uc.fromBufferAttribute(this, e),
                    uc.applyMatrix3(t),
                    this.setXY(e, uc.x, uc.y);
            else if (3 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                    hc.fromBufferAttribute(this, e),
                    hc.applyMatrix3(t),
                    this.setXYZ(e, hc.x, hc.y, hc.z);
            return this
        }
        applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
                hc.x = this.getX(e),
                hc.y = this.getY(e),
                hc.z = this.getZ(e),
                hc.applyMatrix4(t),
                this.setXYZ(e, hc.x, hc.y, hc.z);
            return this
        }
        applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
                hc.x = this.getX(e),
                hc.y = this.getY(e),
                hc.z = this.getZ(e),
                hc.applyNormalMatrix(t),
                this.setXYZ(e, hc.x, hc.y, hc.z);
            return this
        }
        transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
                hc.x = this.getX(e),
                hc.y = this.getY(e),
                hc.z = this.getZ(e),
                hc.transformDirection(t),
                this.setXYZ(e, hc.x, hc.y, hc.z);
            return this
        }
        set(t, e=0) {
            return this.array.set(t, e),
            this
        }
        getX(t) {
            return this.array[t * this.itemSize]
        }
        setX(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        }
        getY(t) {
            return this.array[t * this.itemSize + 1]
        }
        setY(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        }
        getZ(t) {
            return this.array[t * this.itemSize + 2]
        }
        setZ(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        }
        getW(t) {
            return this.array[t * this.itemSize + 3]
        }
        setW(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        }
        setXY(t, e, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this
        }
        setXYZ(t, e, n, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this
        }
        setXYZW(t, e, n, i, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this.array[t + 3] = r,
            this
        }
        onUpload(t) {
            return this.onUploadCallback = t,
            this
        }
        clone() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
        toJSON() {
            const t = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (t.name = this.name),
            this.usage !== ca && (t.usage = this.usage),
            0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
            t
        }
    }
    dc.prototype.isBufferAttribute = !0;
    class pc extends dc {
        constructor(t, e, n) {
            super(new Uint16Array(t), e, n)
        }
    }
    class fc extends dc {
        constructor(t, e, n) {
            super(new Uint32Array(t), e, n)
        }
    }
    (class extends dc {
        constructor(t, e, n) {
            super(new Uint16Array(t), e, n)
        }
    }
    ).prototype.isFloat16BufferAttribute = !0;
    class mc extends dc {
        constructor(t, e, n) {
            super(new Float32Array(t), e, n)
        }
    }
    let gc = 0;
    const vc = new vl
      , yc = new Vl
      , _c = new Ua
      , xc = new Ga
      , bc = new Ga
      , wc = new Ua;
    class Mc extends da {
        constructor() {
            super(),
            Object.defineProperty(this, "id", {
                value: gc++
            }),
            this.uuid = ya(),
            this.name = "",
            this.type = "BufferGeometry",
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.morphTargetsRelative = !1,
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.drawRange = {
                start: 0,
                count: 1 / 0
            },
            this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(t) {
            return Array.isArray(t) ? this.index = new (Ra(t) > 65535 ? fc : pc)(t,1) : this.index = t,
            this
        }
        getAttribute(t) {
            return this.attributes[t]
        }
        setAttribute(t, e) {
            return this.attributes[t] = e,
            this
        }
        deleteAttribute(t) {
            return delete this.attributes[t],
            this
        }
        hasAttribute(t) {
            return void 0 !== this.attributes[t]
        }
        addGroup(t, e, n=0) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        }
        applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t),
            e.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const e = (new Aa).getNormalMatrix(t);
                n.applyNormalMatrix(e),
                n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(t),
            i.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        }
        applyQuaternion(t) {
            return vc.makeRotationFromQuaternion(t),
            this.applyMatrix4(vc),
            this
        }
        rotateX(t) {
            return vc.makeRotationX(t),
            this.applyMatrix4(vc),
            this
        }
        rotateY(t) {
            return vc.makeRotationY(t),
            this.applyMatrix4(vc),
            this
        }
        rotateZ(t) {
            return vc.makeRotationZ(t),
            this.applyMatrix4(vc),
            this
        }
        translate(t, e, n) {
            return vc.makeTranslation(t, e, n),
            this.applyMatrix4(vc),
            this
        }
        scale(t, e, n) {
            return vc.makeScale(t, e, n),
            this.applyMatrix4(vc),
            this
        }
        lookAt(t) {
            return yc.lookAt(t),
            yc.updateMatrix(),
            this.applyMatrix4(yc.matrix),
            this
        }
        center() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(_c).negate(),
            this.translate(_c.x, _c.y, _c.z),
            this
        }
        setFromPoints(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new mc(e,3)),
            this
        }
        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Ga);
            const t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingBox.set(new Ua(-1 / 0,-1 / 0,-1 / 0), new Ua(1 / 0,1 / 0,1 / 0));
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t),
                e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        xc.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (wc.addVectors(this.boundingBox.min, xc.min),
                        this.boundingBox.expandByPoint(wc),
                        wc.addVectors(this.boundingBox.max, xc.max),
                        this.boundingBox.expandByPoint(wc)) : (this.boundingBox.expandByPoint(xc.min),
                        this.boundingBox.expandByPoint(xc.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new ll);
            const t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingSphere.set(new Ua, 1 / 0);
            if (t) {
                const n = this.boundingSphere.center;
                if (xc.setFromBufferAttribute(t),
                e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        bc.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (wc.addVectors(xc.min, bc.min),
                        xc.expandByPoint(wc),
                        wc.addVectors(xc.max, bc.max),
                        xc.expandByPoint(wc)) : (xc.expandByPoint(bc.min),
                        xc.expandByPoint(bc.max))
                    }
                xc.getCenter(n);
                let i = 0;
                for (let e = 0, r = t.count; e < r; e++)
                    wc.fromBufferAttribute(t, e),
                    i = Math.max(i, n.distanceToSquared(wc));
                if (e)
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r]
                          , o = this.morphTargetsRelative;
                        for (let e = 0, r = s.count; e < r; e++)
                            wc.fromBufferAttribute(s, e),
                            o && (_c.fromBufferAttribute(t, e),
                            wc.add(_c)),
                            i = Math.max(i, n.distanceToSquared(wc))
                    }
                this.boundingSphere.radius = Math.sqrt(i),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeTangents() {
            const t = this.index
              , e = this.attributes;
            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const n = t.array
              , i = e.position.array
              , r = e.normal.array
              , s = e.uv.array
              , o = i.length / 3;
            void 0 === e.tangent && this.setAttribute("tangent", new dc(new Float32Array(4 * o),4));
            const a = e.tangent.array
              , l = []
              , c = [];
            for (let t = 0; t < o; t++)
                l[t] = new Ua,
                c[t] = new Ua;
            const h = new Ua
              , u = new Ua
              , d = new Ua
              , p = new Ea
              , f = new Ea
              , m = new Ea
              , g = new Ua
              , v = new Ua;
            function y(t, e, n) {
                h.fromArray(i, 3 * t),
                u.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(s, 2 * t),
                f.fromArray(s, 2 * e),
                m.fromArray(s, 2 * n),
                u.sub(h),
                d.sub(h),
                f.sub(p),
                m.sub(p);
                const r = 1 / (f.x * m.y - m.x * f.y);
                isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(v),
                c[e].add(v),
                c[n].add(v))
            }
            let _ = this.groups;
            0 === _.length && (_ = [{
                start: 0,
                count: n.length
            }]);
            for (let t = 0, e = _.length; t < e; ++t) {
                const e = _[t]
                  , i = e.start;
                for (let t = i, r = i + e.count; t < r; t += 3)
                    y(n[t + 0], n[t + 1], n[t + 2])
            }
            const x = new Ua
              , b = new Ua
              , w = new Ua
              , M = new Ua;
            function S(t) {
                w.fromArray(r, 3 * t),
                M.copy(w);
                const e = l[t];
                x.copy(e),
                x.sub(w.multiplyScalar(w.dot(e))).normalize(),
                b.crossVectors(M, e);
                const n = b.dot(c[t]) < 0 ? -1 : 1;
                a[4 * t] = x.x,
                a[4 * t + 1] = x.y,
                a[4 * t + 2] = x.z,
                a[4 * t + 3] = n
            }
            for (let t = 0, e = _.length; t < e; ++t) {
                const e = _[t]
                  , i = e.start;
                for (let t = i, r = i + e.count; t < r; t += 3)
                    S(n[t + 0]),
                    S(n[t + 1]),
                    S(n[t + 2])
            }
        }
        computeVertexNormals() {
            const t = this.index
              , e = this.getAttribute("position");
            if (void 0 !== e) {
                let n = this.getAttribute("normal");
                if (void 0 === n)
                    n = new dc(new Float32Array(3 * e.count),3),
                    this.setAttribute("normal", n);
                else
                    for (let t = 0, e = n.count; t < e; t++)
                        n.setXYZ(t, 0, 0, 0);
                const i = new Ua
                  , r = new Ua
                  , s = new Ua
                  , o = new Ua
                  , a = new Ua
                  , l = new Ua
                  , c = new Ua
                  , h = new Ua;
                if (t)
                    for (let u = 0, d = t.count; u < d; u += 3) {
                        const d = t.getX(u + 0)
                          , p = t.getX(u + 1)
                          , f = t.getX(u + 2);
                        i.fromBufferAttribute(e, d),
                        r.fromBufferAttribute(e, p),
                        s.fromBufferAttribute(e, f),
                        c.subVectors(s, r),
                        h.subVectors(i, r),
                        c.cross(h),
                        o.fromBufferAttribute(n, d),
                        a.fromBufferAttribute(n, p),
                        l.fromBufferAttribute(n, f),
                        o.add(c),
                        a.add(c),
                        l.add(c),
                        n.setXYZ(d, o.x, o.y, o.z),
                        n.setXYZ(p, a.x, a.y, a.z),
                        n.setXYZ(f, l.x, l.y, l.z)
                    }
                else
                    for (let t = 0, o = e.count; t < o; t += 3)
                        i.fromBufferAttribute(e, t + 0),
                        r.fromBufferAttribute(e, t + 1),
                        s.fromBufferAttribute(e, t + 2),
                        c.subVectors(s, r),
                        h.subVectors(i, r),
                        c.cross(h),
                        n.setXYZ(t + 0, c.x, c.y, c.z),
                        n.setXYZ(t + 1, c.x, c.y, c.z),
                        n.setXYZ(t + 2, c.x, c.y, c.z);
                this.normalizeNormals(),
                n.needsUpdate = !0
            }
        }
        merge(t, e) {
            if (!t || !t.isBufferGeometry)
                return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
            void 0 === e && (e = 0,
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const n = this.attributes;
            for (const i in n) {
                if (void 0 === t.attributes[i])
                    continue;
                const r = n[i].array
                  , s = t.attributes[i]
                  , o = s.array
                  , a = s.itemSize * e
                  , l = Math.min(o.length, r.length - a);
                for (let t = 0, e = a; t < l; t++,
                e++)
                    r[e] = o[t]
            }
            return this
        }
        normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
                wc.fromBufferAttribute(t, e),
                wc.normalize(),
                t.setXYZ(e, wc.x, wc.y, wc.z)
        }
        toNonIndexed() {
            function t(t, e) {
                const n = t.array
                  , i = t.itemSize
                  , r = t.normalized
                  , s = new n.constructor(e.length * i);
                let o = 0
                  , a = 0;
                for (let r = 0, l = e.length; r < l; r++) {
                    o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                    for (let t = 0; t < i; t++)
                        s[a++] = n[o++]
                }
                return new dc(s,i,r)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                this;
            const e = new Mc
              , n = this.index.array
              , i = this.attributes;
            for (const r in i) {
                const s = t(i[r], n);
                e.setAttribute(r, s)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const s = []
                  , o = r[i];
                for (let e = 0, i = o.length; e < i; e++) {
                    const i = t(o[e], n);
                    s.push(i)
                }
                e.morphAttributes[i] = s
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, n = s.length; t < n; t++) {
                const n = s[t];
                e.addGroup(n.start, n.count, n.materialIndex)
            }
            return e
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 && (t.userData = this.userData),
            void 0 !== this.parameters) {
                const e = this.parameters;
                for (const n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            const e = this.index;
            null !== e && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            const n = this.attributes;
            for (const e in n) {
                const i = n[e];
                t.data.attributes[e] = i.toJSON(t.data)
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
                const n = this.morphAttributes[e]
                  , s = [];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    s.push(i.toJSON(t.data))
                }
                s.length > 0 && (i[e] = s,
                r = !0)
            }
            r && (t.data.morphAttributes = i,
            t.data.morphTargetsRelative = this.morphTargetsRelative);
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const o = this.boundingSphere;
            return null !== o && (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius
            }),
            t
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null;
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
                const n = i[t];
                this.setAttribute(t, n.clone(e))
            }
            const r = t.morphAttributes;
            for (const t in r) {
                const n = []
                  , i = r[t];
                for (let t = 0, r = i.length; t < r; t++)
                    n.push(i[t].clone(e));
                this.morphAttributes[t] = n
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t];
                this.addGroup(e.start, e.count, e.materialIndex)
            }
            const o = t.boundingBox;
            null !== o && (this.boundingBox = o.clone());
            const a = t.boundingSphere;
            return null !== a && (this.boundingSphere = a.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this.userData = t.userData,
            void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)),
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    Mc.prototype.isBufferGeometry = !0;
    const Sc = new vl
      , Tc = new gl
      , Ec = new ll
      , Ac = new Ua
      , Rc = new Ua
      , Lc = new Ua
      , Cc = new Ua
      , Pc = new Ua
      , Dc = new Ua
      , Ic = new Ua
      , Oc = new Ua
      , kc = new Ua
      , Nc = new Ea
      , zc = new Ea
      , Bc = new Ea
      , Fc = new Ua
      , Uc = new Ua;
    class Hc extends Vl {
        constructor(t=new Mc, e=new cc) {
            super(),
            this.type = "Mesh",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        copy(t) {
            return super.copy(t),
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        }
        updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        raycast(t, e) {
            const n = this.geometry
              , i = this.material
              , r = this.matrixWorld;
            if (void 0 === i)
                return;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            Ec.copy(n.boundingSphere),
            Ec.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(Ec))
                return;
            if (Sc.copy(r).invert(),
            Tc.copy(t.ray).applyMatrix4(Sc),
            null !== n.boundingBox && !1 === Tc.intersectsBox(n.boundingBox))
                return;
            let s;
            if (n.isBufferGeometry) {
                const r = n.index
                  , o = n.attributes.position
                  , a = n.morphAttributes.position
                  , l = n.morphTargetsRelative
                  , c = n.attributes.uv
                  , h = n.attributes.uv2
                  , u = n.groups
                  , d = n.drawRange;
                if (null !== r)
                    if (Array.isArray(i))
                        for (let n = 0, p = u.length; n < p; n++) {
                            const p = u[n]
                              , f = i[p.materialIndex];
                            for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                const i = r.getX(n)
                                  , u = r.getX(n + 1)
                                  , d = r.getX(n + 2);
                                s = Vc(this, f, t, Tc, o, a, l, c, h, i, u, d),
                                s && (s.faceIndex = Math.floor(n / 3),
                                s.face.materialIndex = p.materialIndex,
                                e.push(s))
                            }
                        }
                    else
                        for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                            const u = r.getX(n)
                              , d = r.getX(n + 1)
                              , p = r.getX(n + 2);
                            s = Vc(this, i, t, Tc, o, a, l, c, h, u, d, p),
                            s && (s.faceIndex = Math.floor(n / 3),
                            e.push(s))
                        }
                else if (void 0 !== o)
                    if (Array.isArray(i))
                        for (let n = 0, r = u.length; n < r; n++) {
                            const r = u[n]
                              , p = i[r.materialIndex];
                            for (let n = Math.max(r.start, d.start), i = Math.min(o.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3)
                                s = Vc(this, p, t, Tc, o, a, l, c, h, n, n + 1, n + 2),
                                s && (s.faceIndex = Math.floor(n / 3),
                                s.face.materialIndex = r.materialIndex,
                                e.push(s))
                        }
                    else
                        for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3)
                            s = Vc(this, i, t, Tc, o, a, l, c, h, n, n + 1, n + 2),
                            s && (s.faceIndex = Math.floor(n / 3),
                            e.push(s))
            } else
                n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
    function Vc(t, e, n, i, r, s, o, a, l, c, h, u) {
        Ac.fromBufferAttribute(r, c),
        Rc.fromBufferAttribute(r, h),
        Lc.fromBufferAttribute(r, u);
        const d = t.morphTargetInfluences;
        if (s && d) {
            Ic.set(0, 0, 0),
            Oc.set(0, 0, 0),
            kc.set(0, 0, 0);
            for (let t = 0, e = s.length; t < e; t++) {
                const e = d[t]
                  , n = s[t];
                0 !== e && (Cc.fromBufferAttribute(n, c),
                Pc.fromBufferAttribute(n, h),
                Dc.fromBufferAttribute(n, u),
                o ? (Ic.addScaledVector(Cc, e),
                Oc.addScaledVector(Pc, e),
                kc.addScaledVector(Dc, e)) : (Ic.addScaledVector(Cc.sub(Ac), e),
                Oc.addScaledVector(Pc.sub(Rc), e),
                kc.addScaledVector(Dc.sub(Lc), e)))
            }
            Ac.add(Ic),
            Rc.add(Oc),
            Lc.add(kc)
        }
        t.isSkinnedMesh && (t.boneTransform(c, Ac),
        t.boneTransform(h, Rc),
        t.boneTransform(u, Lc));
        const p = function(t, e, n, i, r, s, o, a) {
            let l;
            if (l = 1 === e.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 2 !== e.side, a),
            null === l)
                return null;
            Uc.copy(a),
            Uc.applyMatrix4(t.matrixWorld);
            const c = n.ray.origin.distanceTo(Uc);
            return c < n.near || c > n.far ? null : {
                distance: c,
                point: Uc.clone(),
                object: t
            }
        }(t, e, n, i, Ac, Rc, Lc, Fc);
        if (p) {
            a && (Nc.fromBufferAttribute(a, c),
            zc.fromBufferAttribute(a, h),
            Bc.fromBufferAttribute(a, u),
            p.uv = $l.getUV(Fc, Ac, Rc, Lc, Nc, zc, Bc, new Ea)),
            l && (Nc.fromBufferAttribute(l, c),
            zc.fromBufferAttribute(l, h),
            Bc.fromBufferAttribute(l, u),
            p.uv2 = $l.getUV(Fc, Ac, Rc, Lc, Nc, zc, Bc, new Ea));
            const t = {
                a: c,
                b: h,
                c: u,
                normal: new Ua,
                materialIndex: 0
            };
            $l.getNormal(Ac, Rc, Lc, t.normal),
            p.face = t
        }
        return p
    }
    Hc.prototype.isMesh = !0;
    class Gc extends Mc {
        constructor(t=1, e=1, n=1, i=1, r=1, s=1) {
            super(),
            this.type = "BoxGeometry",
            this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s
            };
            const o = this;
            i = Math.floor(i),
            r = Math.floor(r),
            s = Math.floor(s);
            const a = []
              , l = []
              , c = []
              , h = [];
            let u = 0
              , d = 0;
            function p(t, e, n, i, r, s, p, f, m, g, v) {
                const y = s / m
                  , _ = p / g
                  , x = s / 2
                  , b = p / 2
                  , w = f / 2
                  , M = m + 1
                  , S = g + 1;
                let T = 0
                  , E = 0;
                const A = new Ua;
                for (let s = 0; s < S; s++) {
                    const o = s * _ - b;
                    for (let a = 0; a < M; a++) {
                        const u = a * y - x;
                        A[t] = u * i,
                        A[e] = o * r,
                        A[n] = w,
                        l.push(A.x, A.y, A.z),
                        A[t] = 0,
                        A[e] = 0,
                        A[n] = f > 0 ? 1 : -1,
                        c.push(A.x, A.y, A.z),
                        h.push(a / m),
                        h.push(1 - s / g),
                        T += 1
                    }
                }
                for (let t = 0; t < g; t++)
                    for (let e = 0; e < m; e++) {
                        const n = u + e + M * t
                          , i = u + e + M * (t + 1)
                          , r = u + (e + 1) + M * (t + 1)
                          , s = u + (e + 1) + M * t;
                        a.push(n, i, s),
                        a.push(i, r, s),
                        E += 6
                    }
                o.addGroup(d, E, v),
                d += E,
                u += T
            }
            p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
            p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
            p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
            p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
            p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
            p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
            this.setIndex(a),
            this.setAttribute("position", new mc(l,3)),
            this.setAttribute("normal", new mc(c,3)),
            this.setAttribute("uv", new mc(h,2))
        }
        static fromJSON(t) {
            return new Gc(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
        }
    }
    function Wc(t) {
        const e = {};
        for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
                const r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        }
        return e
    }
    function jc(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const i = Wc(t[n]);
            for (const t in i)
                e[t] = i[t]
        }
        return e
    }
    const Xc = {
        clone: Wc,
        merge: jc
    };
    class qc extends ec {
        constructor(t) {
            super(),
            this.type = "ShaderMaterial",
            this.defines = {},
            this.uniforms = {},
            this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
            this.linewidth = 1,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.lights = !1,
            this.clipping = !1,
            this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            },
            this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            },
            this.index0AttributeName = void 0,
            this.uniformsNeedUpdate = !1,
            this.glslVersion = null,
            void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
            this.setValues(t))
        }
        copy(t) {
            return super.copy(t),
            this.fragmentShader = t.fragmentShader,
            this.vertexShader = t.vertexShader,
            this.uniforms = Wc(t.uniforms),
            this.defines = Object.assign({}, t.defines),
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.lights = t.lights,
            this.clipping = t.clipping,
            this.extensions = Object.assign({}, t.extensions),
            this.glslVersion = t.glslVersion,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            e.glslVersion = this.glslVersion,
            e.uniforms = {};
            for (const n in this.uniforms) {
                const i = this.uniforms[n].value;
                i && i.isTexture ? e.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(t).uuid
                } : i && i.isColor ? e.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? e.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? e.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? e.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? e.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? e.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : e.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            e.vertexShader = this.vertexShader,
            e.fragmentShader = this.fragmentShader;
            const n = {};
            for (const t in this.extensions)
                !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n),
            e
        }
    }
    qc.prototype.isShaderMaterial = !0;
    class Yc extends Vl {
        constructor() {
            super(),
            this.type = "Camera",
            this.matrixWorldInverse = new vl,
            this.projectionMatrix = new vl,
            this.projectionMatrixInverse = new vl
        }
        copy(t, e) {
            return super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
        }
        getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    Yc.prototype.isCamera = !0;
    class Zc extends Yc {
        constructor(t=50, e=1, n=.1, i=2e3) {
            super(),
            this.type = "PerspectiveCamera",
            this.fov = t,
            this.zoom = 1,
            this.near = n,
            this.far = i,
            this.focus = 10,
            this.aspect = e,
            this.view = null,
            this.filmGauge = 35,
            this.filmOffset = 0,
            this.updateProjectionMatrix()
        }
        copy(t, e) {
            return super.copy(t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        }
        setFocalLength(t) {
            const e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * ma * Math.atan(e),
            this.updateProjectionMatrix()
        }
        getFocalLength() {
            const t = Math.tan(.5 * fa * this.fov);
            return .5 * this.getFilmHeight() / t
        }
        getEffectiveFOV() {
            return 2 * ma * Math.atan(Math.tan(.5 * fa * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(t, e, n, i, r, s) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = s,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const t = this.near;
            let e = t * Math.tan(.5 * fa * this.fov) / this.zoom
              , n = 2 * e
              , i = this.aspect * n
              , r = -.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
                const t = s.fullWidth
                  , o = s.fullHeight;
                r += s.offsetX * i / t,
                e -= s.offsetY * n / o,
                i *= s.width / t,
                n *= s.height / o
            }
            const o = this.filmOffset;
            0 !== o && (r += t * o / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    }
    Zc.prototype.isPerspectiveCamera = !0;
    const Jc = 90;
    class Kc extends Vl {
        constructor(t, e, n) {
            if (super(),
            this.type = "CubeCamera",
            !0 !== n.isWebGLCubeRenderTarget)
                return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            this.renderTarget = n;
            const i = new Zc(Jc,1,t,e);
            i.layers = this.layers,
            i.up.set(0, -1, 0),
            i.lookAt(new Ua(1,0,0)),
            this.add(i);
            const r = new Zc(Jc,1,t,e);
            r.layers = this.layers,
            r.up.set(0, -1, 0),
            r.lookAt(new Ua(-1,0,0)),
            this.add(r);
            const s = new Zc(Jc,1,t,e);
            s.layers = this.layers,
            s.up.set(0, 0, 1),
            s.lookAt(new Ua(0,1,0)),
            this.add(s);
            const o = new Zc(Jc,1,t,e);
            o.layers = this.layers,
            o.up.set(0, 0, -1),
            o.lookAt(new Ua(0,-1,0)),
            this.add(o);
            const a = new Zc(Jc,1,t,e);
            a.layers = this.layers,
            a.up.set(0, -1, 0),
            a.lookAt(new Ua(0,0,1)),
            this.add(a);
            const l = new Zc(Jc,1,t,e);
            l.layers = this.layers,
            l.up.set(0, -1, 0),
            l.lookAt(new Ua(0,0,-1)),
            this.add(l)
        }
        update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget
              , [i,r,s,o,a,l] = this.children
              , c = t.xr.enabled
              , h = t.getRenderTarget();
            t.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            t.setRenderTarget(n, 0),
            t.render(e, i),
            t.setRenderTarget(n, 1),
            t.render(e, r),
            t.setRenderTarget(n, 2),
            t.render(e, s),
            t.setRenderTarget(n, 3),
            t.render(e, o),
            t.setRenderTarget(n, 4),
            t.render(e, a),
            n.texture.generateMipmaps = u,
            t.setRenderTarget(n, 5),
            t.render(e, l),
            t.setRenderTarget(h),
            t.xr.enabled = c
        }
    }
    class Qc extends Oa {
        constructor(t, e, n, i, r, s, o, a, l, c) {
            super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Po, n, i, r, s, o, a, l, c),
            this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(t) {
            this.image = t
        }
    }
    Qc.prototype.isCubeTexture = !0;
    class $c extends za {
        constructor(t, e, n) {
            Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
            e = n),
            super(t, t, e),
            e = e || {},
            this.texture = new Qc(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
            this.texture.isRenderTargetTexture = !0,
            this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
            this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Uo,
            this.texture._needsFlipEnvMap = !1
        }
        fromEquirectangularTexture(t, e) {
            this.texture.type = e.type,
            this.texture.format = Zo,
            this.texture.encoding = e.encoding,
            this.texture.generateMipmaps = e.generateMipmaps,
            this.texture.minFilter = e.minFilter,
            this.texture.magFilter = e.magFilter;
            const n = {
                tEquirect: {
                    value: null
                }
            }
              , i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
              , r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
              , s = new Gc(5,5,5)
              , o = new qc({
                name: "CubemapFromEquirect",
                uniforms: Wc(n),
                vertexShader: i,
                fragmentShader: r,
                side: 1,
                blending: 0
            });
            o.uniforms.tEquirect.value = e;
            const a = new Hc(s,o)
              , l = e.minFilter;
            return e.minFilter === Ho && (e.minFilter = Uo),
            new Kc(1,10,this).update(t, a),
            e.minFilter = l,
            a.geometry.dispose(),
            a.material.dispose(),
            this
        }
        clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++)
                t.setRenderTarget(this, r),
                t.clear(e, n, i);
            t.setRenderTarget(r)
        }
    }
    $c.prototype.isWebGLCubeRenderTarget = !0;
    const th = new Ua
      , eh = new Ua
      , nh = new Aa;
    class ih {
        constructor(t=new Ua(1,0,0), e=0) {
            this.normal = t,
            this.constant = e
        }
        set(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        }
        setComponents(t, e, n, i) {
            return this.normal.set(t, e, n),
            this.constant = i,
            this
        }
        setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        }
        setFromCoplanarPoints(t, e, n) {
            const i = th.subVectors(n, e).cross(eh.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t),
            this
        }
        copy(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        }
        normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        }
        negate() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        }
        distanceToPoint(t) {
            return this.normal.dot(t) + this.constant
        }
        distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius
        }
        projectPoint(t, e) {
            return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        }
        intersectLine(t, e) {
            const n = t.delta(th)
              , i = this.normal.dot(n);
            if (0 === i)
                return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
        }
        intersectsLine(t) {
            const e = this.distanceToPoint(t.start)
              , n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        }
        intersectsBox(t) {
            return t.intersectsPlane(this)
        }
        intersectsSphere(t) {
            return t.intersectsPlane(this)
        }
        coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(t, e) {
            const n = e || nh.getNormalMatrix(t)
              , i = this.coplanarPoint(th).applyMatrix4(t)
              , r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r),
            this
        }
        translate(t) {
            return this.constant -= t.dot(this.normal),
            this
        }
        equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    ih.prototype.isPlane = !0;
    const rh = new ll
      , sh = new Ua;
    class oh {
        constructor(t=new ih, e=new ih, n=new ih, i=new ih, r=new ih, s=new ih) {
            this.planes = [t, e, n, i, r, s]
        }
        set(t, e, n, i, r, s) {
            const o = this.planes;
            return o[0].copy(t),
            o[1].copy(e),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(s),
            this
        }
        copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
                e[n].copy(t.planes[n]);
            return this
        }
        setFromProjectionMatrix(t) {
            const e = this.planes
              , n = t.elements
              , i = n[0]
              , r = n[1]
              , s = n[2]
              , o = n[3]
              , a = n[4]
              , l = n[5]
              , c = n[6]
              , h = n[7]
              , u = n[8]
              , d = n[9]
              , p = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = n[15];
            return e[0].setComponents(o - i, h - a, f - u, y - m).normalize(),
            e[1].setComponents(o + i, h + a, f + u, y + m).normalize(),
            e[2].setComponents(o + r, h + l, f + d, y + g).normalize(),
            e[3].setComponents(o - r, h - l, f - d, y - g).normalize(),
            e[4].setComponents(o - s, h - c, f - p, y - v).normalize(),
            e[5].setComponents(o + s, h + c, f + p, y + v).normalize(),
            this
        }
        intersectsObject(t) {
            const e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(),
            rh.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(rh)
        }
        intersectsSprite(t) {
            return rh.center.set(0, 0, 0),
            rh.radius = .7071067811865476,
            rh.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(rh)
        }
        intersectsSphere(t) {
            const e = this.planes
              , n = t.center
              , i = -t.radius;
            for (let t = 0; t < 6; t++)
                if (e[t].distanceToPoint(n) < i)
                    return !1;
            return !0
        }
        intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = e[n];
                if (sh.x = i.normal.x > 0 ? t.max.x : t.min.x,
                sh.y = i.normal.y > 0 ? t.max.y : t.min.y,
                sh.z = i.normal.z > 0 ? t.max.z : t.min.z,
                i.distanceToPoint(sh) < 0)
                    return !1
            }
            return !0
        }
        containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0)
                    return !1;
            return !0
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    function ah() {
        let t = null
          , e = !1
          , n = null
          , i = null;
        function r(e, s) {
            n(e, s),
            i = t.requestAnimationFrame(r)
        }
        return {
            start: function() {
                !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                e = !0)
            },
            stop: function() {
                t.cancelAnimationFrame(i),
                e = !1
            },
            setAnimationLoop: function(t) {
                n = t
            },
            setContext: function(e) {
                t = e
            }
        }
    }
    function lh(t, e) {
        const n = e.isWebGL2
          , i = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                i.get(t)
            },
            remove: function(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const n = i.get(e);
                n && (t.deleteBuffer(n.buffer),
                i.delete(e))
            },
            update: function(e, r) {
                if (e.isGLBufferAttribute) {
                    const t = i.get(e);
                    return void ((!t || t.version < e.version) && i.set(e, {
                        buffer: e.buffer,
                        type: e.type,
                        bytesPerElement: e.elementSize,
                        version: e.version
                    }))
                }
                e.isInterleavedBufferAttribute && (e = e.data);
                const s = i.get(e);
                void 0 === s ? i.set(e, function(e, i) {
                    const r = e.array
                      , s = e.usage
                      , o = t.createBuffer();
                    t.bindBuffer(i, o),
                    t.bufferData(i, r, s),
                    e.onUploadCallback();
                    let a = 5126;
                    return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121),
                    {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : s.version < e.version && (function(e, i, r) {
                    const s = i.array
                      , o = i.updateRange;
                    t.bindBuffer(r, e),
                    -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)),
                    o.count = -1)
                }(s.buffer, e, r),
                s.version = e.version)
            }
        }
    }
    class ch extends Mc {
        constructor(t=1, e=1, n=1, i=1) {
            super(),
            this.type = "PlaneGeometry",
            this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            };
            const r = t / 2
              , s = e / 2
              , o = Math.floor(n)
              , a = Math.floor(i)
              , l = o + 1
              , c = a + 1
              , h = t / o
              , u = e / a
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let t = 0; t < c; t++) {
                const e = t * u - s;
                for (let n = 0; n < l; n++) {
                    const i = n * h - r;
                    p.push(i, -e, 0),
                    f.push(0, 0, 1),
                    m.push(n / o),
                    m.push(1 - t / a)
                }
            }
            for (let t = 0; t < a; t++)
                for (let e = 0; e < o; e++) {
                    const n = e + l * t
                      , i = e + l * (t + 1)
                      , r = e + 1 + l * (t + 1)
                      , s = e + 1 + l * t;
                    d.push(n, i, s),
                    d.push(i, r, s)
                }
            this.setIndex(d),
            this.setAttribute("position", new mc(p,3)),
            this.setAttribute("normal", new mc(f,3)),
            this.setAttribute("uv", new mc(m,2))
        }
        static fromJSON(t) {
            return new ch(t.width,t.height,t.widthSegments,t.heightSegments)
        }
    }
    const hh = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
    }
      , uh = {
        common: {
            diffuse: {
                value: new lc(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Aa
            },
            uv2Transform: {
                value: new Aa
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Ea(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new lc(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new lc(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Aa
            }
        },
        sprite: {
            diffuse: {
                value: new lc(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ea(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new Aa
            }
        }
    }
      , dh = {
        basic: {
            uniforms: jc([uh.common, uh.specularmap, uh.envmap, uh.aomap, uh.lightmap, uh.fog]),
            vertexShader: hh.meshbasic_vert,
            fragmentShader: hh.meshbasic_frag
        },
        lambert: {
            uniforms: jc([uh.common, uh.specularmap, uh.envmap, uh.aomap, uh.lightmap, uh.emissivemap, uh.fog, uh.lights, {
                emissive: {
                    value: new lc(0)
                }
            }]),
            vertexShader: hh.meshlambert_vert,
            fragmentShader: hh.meshlambert_frag
        },
        phong: {
            uniforms: jc([uh.common, uh.specularmap, uh.envmap, uh.aomap, uh.lightmap, uh.emissivemap, uh.bumpmap, uh.normalmap, uh.displacementmap, uh.fog, uh.lights, {
                emissive: {
                    value: new lc(0)
                },
                specular: {
                    value: new lc(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: hh.meshphong_vert,
            fragmentShader: hh.meshphong_frag
        },
        standard: {
            uniforms: jc([uh.common, uh.envmap, uh.aomap, uh.lightmap, uh.emissivemap, uh.bumpmap, uh.normalmap, uh.displacementmap, uh.roughnessmap, uh.metalnessmap, uh.fog, uh.lights, {
                emissive: {
                    value: new lc(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: hh.meshphysical_vert,
            fragmentShader: hh.meshphysical_frag
        },
        toon: {
            uniforms: jc([uh.common, uh.aomap, uh.lightmap, uh.emissivemap, uh.bumpmap, uh.normalmap, uh.displacementmap, uh.gradientmap, uh.fog, uh.lights, {
                emissive: {
                    value: new lc(0)
                }
            }]),
            vertexShader: hh.meshtoon_vert,
            fragmentShader: hh.meshtoon_frag
        },
        matcap: {
            uniforms: jc([uh.common, uh.bumpmap, uh.normalmap, uh.displacementmap, uh.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: hh.meshmatcap_vert,
            fragmentShader: hh.meshmatcap_frag
        },
        points: {
            uniforms: jc([uh.points, uh.fog]),
            vertexShader: hh.points_vert,
            fragmentShader: hh.points_frag
        },
        dashed: {
            uniforms: jc([uh.common, uh.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: hh.linedashed_vert,
            fragmentShader: hh.linedashed_frag
        },
        depth: {
            uniforms: jc([uh.common, uh.displacementmap]),
            vertexShader: hh.depth_vert,
            fragmentShader: hh.depth_frag
        },
        normal: {
            uniforms: jc([uh.common, uh.bumpmap, uh.normalmap, uh.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: hh.meshnormal_vert,
            fragmentShader: hh.meshnormal_frag
        },
        sprite: {
            uniforms: jc([uh.sprite, uh.fog]),
            vertexShader: hh.sprite_vert,
            fragmentShader: hh.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Aa
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: hh.background_vert,
            fragmentShader: hh.background_frag
        },
        cube: {
            uniforms: jc([uh.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: hh.cube_vert,
            fragmentShader: hh.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: hh.equirect_vert,
            fragmentShader: hh.equirect_frag
        },
        distanceRGBA: {
            uniforms: jc([uh.common, uh.displacementmap, {
                referencePosition: {
                    value: new Ua
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: hh.distanceRGBA_vert,
            fragmentShader: hh.distanceRGBA_frag
        },
        shadow: {
            uniforms: jc([uh.lights, uh.fog, {
                color: {
                    value: new lc(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: hh.shadow_vert,
            fragmentShader: hh.shadow_frag
        }
    };
    function ph(t, e, n, i, r) {
        const s = new lc(0);
        let o, a, l = 0, c = null, h = 0, u = null;
        function d(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, r)
        }
        return {
            getClearColor: function() {
                return s
            },
            setClearColor: function(t, e=1) {
                s.set(t),
                l = e,
                d(s, l)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(t) {
                l = t,
                d(s, l)
            },
            render: function(n, r) {
                let p = !1
                  , f = !0 === r.isScene ? r.background : null;
                f && f.isTexture && (f = e.get(f));
                const m = t.xr
                  , g = m.getSession && m.getSession();
                g && "additive" === g.environmentBlendMode && (f = null),
                null === f ? d(s, l) : f && f.isColor && (d(f, 1),
                p = !0),
                (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                f && (f.isCubeTexture || f.mapping === Io) ? (void 0 === a && (a = new Hc(new Gc(1,1,1),new qc({
                    name: "BackgroundCubeMaterial",
                    uniforms: Wc(dh.cube.uniforms),
                    vertexShader: dh.cube.vertexShader,
                    fragmentShader: dh.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                a.geometry.deleteAttribute("normal"),
                a.geometry.deleteAttribute("uv"),
                a.onBeforeRender = function(t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }
                ,
                Object.defineProperty(a.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                i.update(a)),
                a.material.uniforms.envMap.value = f,
                a.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1,
                c === f && h === f.version && u === t.toneMapping || (a.material.needsUpdate = !0,
                c = f,
                h = f.version,
                u = t.toneMapping),
                n.unshift(a, a.geometry, a.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Hc(new ch(2,2),new qc({
                    name: "BackgroundMaterial",
                    uniforms: Wc(dh.background.uniforms),
                    vertexShader: dh.background.vertexShader,
                    fragmentShader: dh.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                o.geometry.deleteAttribute("normal"),
                Object.defineProperty(o.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                i.update(o)),
                o.material.uniforms.t2D.value = f,
                !0 === f.matrixAutoUpdate && f.updateMatrix(),
                o.material.uniforms.uvTransform.value.copy(f.matrix),
                c === f && h === f.version && u === t.toneMapping || (o.material.needsUpdate = !0,
                c = f,
                h = f.version,
                u = t.toneMapping),
                n.unshift(o, o.geometry, o.material, 0, 0, null))
            }
        }
    }
    function fh(t, e, n, i) {
        const r = t.getParameter(34921)
          , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
          , o = i.isWebGL2 || null !== s
          , a = {}
          , l = d(null);
        let c = l;
        function h(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
        }
        function u(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
        }
        function d(t) {
            const e = []
              , n = []
              , i = [];
            for (let t = 0; t < r; t++)
                e[t] = 0,
                n[t] = 0,
                i[t] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: e,
                enabledAttributes: n,
                attributeDivisors: i,
                object: t,
                attributes: {},
                index: null
            }
        }
        function p() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++)
                t[e] = 0
        }
        function f(t) {
            m(t, 0)
        }
        function m(n, r) {
            const s = c.newAttributes
              , o = c.enabledAttributes
              , a = c.attributeDivisors;
            s[n] = 1,
            0 === o[n] && (t.enableVertexAttribArray(n),
            o[n] = 1),
            a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
            a[n] = r)
        }
        function g() {
            const e = c.newAttributes
              , n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
                n[i] !== e[i] && (t.disableVertexAttribArray(i),
                n[i] = 0)
        }
        function v(e, n, r, s, o, a) {
            !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a)
        }
        function y() {
            _(),
            c !== l && (c = l,
            h(c.object))
        }
        function _() {
            l.geometry = null,
            l.program = null,
            l.wireframe = !1
        }
        return {
            setup: function(r, l, u, y, _) {
                let x = !1;
                if (o) {
                    const e = function(e, n, r) {
                        const o = !0 === r.wireframe;
                        let l = a[e.id];
                        void 0 === l && (l = {},
                        a[e.id] = l);
                        let c = l[n.id];
                        void 0 === c && (c = {},
                        l[n.id] = c);
                        let h = c[o];
                        return void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                        c[o] = h),
                        h
                    }(y, u, l);
                    c !== e && (c = e,
                    h(c.object)),
                    x = function(t, e) {
                        const n = c.attributes
                          , i = t.attributes;
                        let r = 0;
                        for (const t in i) {
                            const e = n[t]
                              , s = i[t];
                            if (void 0 === e)
                                return !0;
                            if (e.attribute !== s)
                                return !0;
                            if (e.data !== s.data)
                                return !0;
                            r++
                        }
                        return c.attributesNum !== r || c.index !== e
                    }(y, _),
                    x && function(t, e) {
                        const n = {}
                          , i = t.attributes;
                        let r = 0;
                        for (const t in i) {
                            const e = i[t]
                              , s = {};
                            s.attribute = e,
                            e.data && (s.data = e.data),
                            n[t] = s,
                            r++
                        }
                        c.attributes = n,
                        c.attributesNum = r,
                        c.index = e
                    }(y, _)
                } else {
                    const t = !0 === l.wireframe;
                    c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id,
                    c.program = u.id,
                    c.wireframe = t,
                    x = !0)
                }
                !0 === r.isInstancedMesh && (x = !0),
                null !== _ && n.update(_, 34963),
                x && (function(r, s, o, a) {
                    if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                        return;
                    p();
                    const l = a.attributes
                      , c = o.getAttributes()
                      , h = s.defaultAttributeValues;
                    for (const e in c) {
                        const i = c[e];
                        if (i.location >= 0) {
                            let s = l[e];
                            if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix),
                            "instanceColor" === e && r.instanceColor && (s = r.instanceColor)),
                            void 0 !== s) {
                                const e = s.normalized
                                  , o = s.itemSize
                                  , l = n.get(s);
                                if (void 0 === l)
                                    continue;
                                const c = l.buffer
                                  , h = l.type
                                  , u = l.bytesPerElement;
                                if (s.isInterleavedBufferAttribute) {
                                    const n = s.data
                                      , l = n.stride
                                      , d = s.offset;
                                    if (n && n.isInstancedInterleavedBuffer) {
                                        for (let t = 0; t < i.locationSize; t++)
                                            m(i.location + t, n.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                    } else
                                        for (let t = 0; t < i.locationSize; t++)
                                            f(i.location + t);
                                    t.bindBuffer(34962, c);
                                    for (let t = 0; t < i.locationSize; t++)
                                        v(i.location + t, o / i.locationSize, h, e, l * u, (d + o / i.locationSize * t) * u)
                                } else {
                                    if (s.isInstancedBufferAttribute) {
                                        for (let t = 0; t < i.locationSize; t++)
                                            m(i.location + t, s.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)
                                    } else
                                        for (let t = 0; t < i.locationSize; t++)
                                            f(i.location + t);
                                    t.bindBuffer(34962, c);
                                    for (let t = 0; t < i.locationSize; t++)
                                        v(i.location + t, o / i.locationSize, h, e, o * u, o / i.locationSize * t * u)
                                }
                            } else if (void 0 !== h) {
                                const n = h[e];
                                if (void 0 !== n)
                                    switch (n.length) {
                                    case 2:
                                        t.vertexAttrib2fv(i.location, n);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(i.location, n);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(i.location, n);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(i.location, n)
                                    }
                            }
                        }
                    }
                    g()
                }(r, l, u, y),
                null !== _ && t.bindBuffer(34963, n.get(_).buffer))
            },
            reset: y,
            resetDefaultState: _,
            dispose: function() {
                y();
                for (const t in a) {
                    const e = a[t];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            u(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete a[t]
                }
            },
            releaseStatesOfGeometry: function(t) {
                if (void 0 === a[t.id])
                    return;
                const e = a[t.id];
                for (const t in e) {
                    const n = e[t];
                    for (const t in n)
                        u(n[t].object),
                        delete n[t];
                    delete e[t]
                }
                delete a[t.id]
            },
            releaseStatesOfProgram: function(t) {
                for (const e in a) {
                    const n = a[e];
                    if (void 0 === n[t.id])
                        continue;
                    const i = n[t.id];
                    for (const t in i)
                        u(i[t].object),
                        delete i[t];
                    delete n[t.id]
                }
            },
            initAttributes: p,
            enableAttribute: f,
            disableUnusedAttributes: g
        }
    }
    function mh(t, e, n, i) {
        const r = i.isWebGL2;
        let s;
        this.setMode = function(t) {
            s = t
        }
        ,
        this.render = function(e, i) {
            t.drawArrays(s, e, i),
            n.update(i, s, 1)
        }
        ,
        this.renderInstances = function(i, o, a) {
            if (0 === a)
                return;
            let l, c;
            if (r)
                l = t,
                c = "drawArraysInstanced";
            else if (l = e.get("ANGLE_instanced_arrays"),
            c = "drawArraysInstancedANGLE",
            null === l)
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[c](s, i, o, a),
            n.update(o, s, a)
        }
    }
    function gh(t, e, n) {
        let i;
        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
        let o = void 0 !== n.precision ? n.precision : "highp";
        const a = r(o);
        a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."),
        o = a);
        const l = s || e.has("WEBGL_draw_buffers")
          , c = !0 === n.logarithmicDepthBuffer
          , h = t.getParameter(34930)
          , u = t.getParameter(35660)
          , d = t.getParameter(3379)
          , p = t.getParameter(34076)
          , f = t.getParameter(34921)
          , m = t.getParameter(36347)
          , g = t.getParameter(36348)
          , v = t.getParameter(36349)
          , y = u > 0
          , _ = s || e.has("OES_texture_float");
        return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function() {
                if (void 0 !== i)
                    return i;
                if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                    const n = e.get("EXT_texture_filter_anisotropic");
                    i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else
                    i = 0;
                return i
            },
            getMaxPrecision: r,
            precision: o,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: v,
            vertexTextures: y,
            floatFragmentTextures: _,
            floatVertexTextures: y && _,
            maxSamples: s ? t.getParameter(36183) : 0
        }
    }
    function vh(t) {
        const e = this;
        let n = null
          , i = 0
          , r = !1
          , s = !1;
        const o = new ih
          , a = new Aa
          , l = {
            value: null,
            needsUpdate: !1
        };
        function c() {
            l.value !== n && (l.value = n,
            l.needsUpdate = i > 0),
            e.numPlanes = i,
            e.numIntersection = 0
        }
        function h(t, n, i, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
                if (c = l.value,
                !0 !== r || null === c) {
                    const e = i + 4 * s
                      , r = n.matrixWorldInverse;
                    a.getNormalMatrix(r),
                    (null === c || c.length < e) && (c = new Float32Array(e));
                    for (let e = 0, n = i; e !== s; ++e,
                    n += 4)
                        o.copy(t[e]).applyMatrix4(r, a),
                        o.normal.toArray(c, n),
                        c[n + 3] = o.constant
                }
                l.value = c,
                l.needsUpdate = !0
            }
            return e.numPlanes = s,
            e.numIntersection = 0,
            c
        }
        this.uniform = l,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(t, e, s) {
            const o = 0 !== t.length || e || 0 !== i || r;
            return r = e,
            n = h(t, s, 0),
            i = t.length,
            o
        }
        ,
        this.beginShadows = function() {
            s = !0,
            h(null)
        }
        ,
        this.endShadows = function() {
            s = !1,
            c()
        }
        ,
        this.setState = function(e, o, a) {
            const u = e.clippingPlanes
              , d = e.clipIntersection
              , p = e.clipShadows
              , f = t.get(e);
            if (!r || null === u || 0 === u.length || s && !p)
                s ? h(null) : c();
            else {
                const t = s ? 0 : i
                  , e = 4 * t;
                let r = f.clippingState || null;
                l.value = r,
                r = h(u, o, e, a);
                for (let t = 0; t !== e; ++t)
                    r[t] = n[t];
                f.clippingState = r,
                this.numIntersection = d ? this.numPlanes : 0,
                this.numPlanes += t
            }
        }
    }
    function yh(t) {
        let e = new WeakMap;
        function n(t, e) {
            return 303 === e ? t.mapping = Po : 304 === e && (t.mapping = Do),
            t
        }
        function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n),
            r.dispose())
        }
        return {
            get: function(r) {
                if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                    const s = r.mapping;
                    if (303 === s || 304 === s) {
                        if (e.has(r))
                            return n(e.get(r).texture, r.mapping);
                        {
                            const s = r.image;
                            if (s && s.height > 0) {
                                const o = t.getRenderTarget()
                                  , a = new $c(s.height / 2);
                                return a.fromEquirectangularTexture(t, r),
                                e.set(r, a),
                                t.setRenderTarget(o),
                                r.addEventListener("dispose", i),
                                n(a.texture, r.mapping)
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    dh.physical = {
        uniforms: jc([dh.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Ea(1,1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new lc(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenRoughness: {
                value: 0
            },
            sheenRoughnessMap: {
                value: null
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new Ea
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new lc(0)
            },
            specularIntensity: {
                value: 0
            },
            specularIntensityMap: {
                value: null
            },
            specularColor: {
                value: new lc(1,1,1)
            },
            specularColorMap: {
                value: null
            }
        }]),
        vertexShader: hh.meshphysical_vert,
        fragmentShader: hh.meshphysical_frag
    };
    class _h extends Yc {
        constructor(t=-1, e=1, n=1, i=-1, r=.1, s=2e3) {
            super(),
            this.type = "OrthographicCamera",
            this.zoom = 1,
            this.view = null,
            this.left = t,
            this.right = e,
            this.top = n,
            this.bottom = i,
            this.near = r,
            this.far = s,
            this.updateProjectionMatrix()
        }
        copy(t, e) {
            return super.copy(t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        }
        setViewOffset(t, e, n, i, r, s) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = s,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2;
            let r = n - t
              , s = n + t
              , o = i + e
              , a = i - e;
            if (null !== this.view && this.view.enabled) {
                const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += t * this.view.offsetX,
                s = r + t * this.view.width,
                o -= e * this.view.offsetY,
                a = o - e * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
        }
    }
    _h.prototype.isOrthographicCamera = !0;
    class xh extends qc {
        constructor(t) {
            super(t),
            this.type = "RawShaderMaterial"
        }
    }
    xh.prototype.isRawShaderMaterial = !0;
    const bh = Math.pow(2, 8)
      , wh = [.125, .215, .35, .446, .526, .582]
      , Mh = 5 + wh.length
      , Sh = {
        [ra]: 0,
        [sa]: 1,
        [aa]: 2,
        3004: 3,
        3005: 4,
        3006: 5,
        [oa]: 6
    }
      , Th = new _h
      , {_lodPlanes: Eh, _sizeLods: Ah, _sigmas: Rh} = Nh()
      , Lh = new lc;
    let Ch = null;
    const Ph = (1 + Math.sqrt(5)) / 2
      , Dh = 1 / Ph
      , Ih = [new Ua(1,1,1), new Ua(-1,1,1), new Ua(1,1,-1), new Ua(-1,1,-1), new Ua(0,Ph,Dh), new Ua(0,Ph,-Dh), new Ua(Dh,0,Ph), new Ua(-Dh,0,Ph), new Ua(Ph,Dh,0), new Ua(-Ph,Dh,0)];
    class Oh {
        constructor(t) {
            this._renderer = t,
            this._pingPongRenderTarget = null,
            this._blurMaterial = function(t) {
                const e = new Float32Array(20)
                  , n = new Ua(0,1,0);
                return new xh({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: 20
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: e
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: n
                        },
                        inputEncoding: {
                            value: Sh[3e3]
                        },
                        outputEncoding: {
                            value: Sh[3e3]
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }(),
            this._equirectShader = null,
            this._cubemapShader = null,
            this._compileMaterial(this._blurMaterial)
        }
        fromScene(t, e=0, n=.1, i=100) {
            Ch = this._renderer.getRenderTarget();
            const r = this._allocateTargets();
            return this._sceneToCubeUV(t, n, i, r),
            e > 0 && this._blur(r, 0, 0, e),
            this._applyPMREM(r),
            this._cleanup(r),
            r
        }
        fromEquirectangular(t) {
            return this._fromTexture(t)
        }
        fromCubemap(t) {
            return this._fromTexture(t)
        }
        compileCubemapShader() {
            null === this._cubemapShader && (this._cubemapShader = Uh(),
            this._compileMaterial(this._cubemapShader))
        }
        compileEquirectangularShader() {
            null === this._equirectShader && (this._equirectShader = Fh(),
            this._compileMaterial(this._equirectShader))
        }
        dispose() {
            this._blurMaterial.dispose(),
            null !== this._cubemapShader && this._cubemapShader.dispose(),
            null !== this._equirectShader && this._equirectShader.dispose();
            for (let t = 0; t < Eh.length; t++)
                Eh[t].dispose()
        }
        _cleanup(t) {
            this._pingPongRenderTarget.dispose(),
            this._renderer.setRenderTarget(Ch),
            t.scissorTest = !1,
            Bh(t, 0, 0, t.width, t.height)
        }
        _fromTexture(t) {
            Ch = this._renderer.getRenderTarget();
            const e = this._allocateTargets(t);
            return this._textureToCubeUV(t, e),
            this._applyPMREM(e),
            this._cleanup(e),
            e
        }
        _allocateTargets(t) {
            const e = {
                magFilter: zo,
                minFilter: zo,
                generateMipmaps: !1,
                type: Vo,
                format: 1023,
                encoding: kh(t) ? t.encoding : aa,
                depthBuffer: !1
            }
              , n = zh(e);
            return n.depthBuffer = !t,
            this._pingPongRenderTarget = zh(e),
            n
        }
        _compileMaterial(t) {
            const e = new Hc(Eh[0],t);
            this._renderer.compile(e, Th)
        }
        _sceneToCubeUV(t, e, n, i) {
            const r = new Zc(90,1,e,n)
              , s = [1, -1, 1, 1, 1, 1]
              , o = [1, 1, 1, -1, -1, -1]
              , a = this._renderer
              , l = a.autoClear
              , c = a.outputEncoding
              , h = a.toneMapping;
            a.getClearColor(Lh),
            a.toneMapping = 0,
            a.outputEncoding = ra,
            a.autoClear = !1;
            const u = new cc({
                name: "PMREM.Background",
                side: 1,
                depthWrite: !1,
                depthTest: !1
            })
              , d = new Hc(new Gc,u);
            let p = !1;
            const f = t.background;
            f ? f.isColor && (u.color.copy(f),
            t.background = null,
            p = !0) : (u.color.copy(Lh),
            p = !0);
            for (let e = 0; e < 6; e++) {
                const n = e % 3;
                0 == n ? (r.up.set(0, s[e], 0),
                r.lookAt(o[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, s[e]),
                r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0),
                r.lookAt(0, 0, o[e])),
                Bh(i, n * bh, e > 2 ? bh : 0, bh, bh),
                a.setRenderTarget(i),
                p && a.render(d, r),
                a.render(t, r)
            }
            d.geometry.dispose(),
            d.material.dispose(),
            a.toneMapping = h,
            a.outputEncoding = c,
            a.autoClear = l,
            t.background = f
        }
        _setEncoding(t, e) {
            !0 === this._renderer.capabilities.isWebGL2 && e.format === Zo && e.type === Vo && e.encoding === sa ? t.value = Sh[3e3] : t.value = Sh[e.encoding]
        }
        _textureToCubeUV(t, e) {
            const n = this._renderer
              , i = t.mapping === Po || t.mapping === Do;
            i ? null == this._cubemapShader && (this._cubemapShader = Uh()) : null == this._equirectShader && (this._equirectShader = Fh());
            const r = i ? this._cubemapShader : this._equirectShader
              , s = new Hc(Eh[0],r)
              , o = r.uniforms;
            o.envMap.value = t,
            i || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
            this._setEncoding(o.inputEncoding, t),
            this._setEncoding(o.outputEncoding, e.texture),
            Bh(e, 0, 0, 3 * bh, 2 * bh),
            n.setRenderTarget(e),
            n.render(s, Th)
        }
        _applyPMREM(t) {
            const e = this._renderer
              , n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < Mh; e++) {
                const n = Math.sqrt(Rh[e] * Rh[e] - Rh[e - 1] * Rh[e - 1])
                  , i = Ih[(e - 1) % Ih.length];
                this._blur(t, e - 1, e, n, i)
            }
            e.autoClear = n
        }
        _blur(t, e, n, i, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(t, s, e, n, i, "latitudinal", r),
            this._halfBlur(s, t, n, n, i, "longitudinal", r)
        }
        _halfBlur(t, e, n, i, r, s, o) {
            const a = this._renderer
              , l = this._blurMaterial;
            "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
            const c = new Hc(Eh[i],l)
              , h = l.uniforms
              , u = Ah[n] - 1
              , d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39
              , p = r / d
              , f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
            const m = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
                const e = t / p
                  , n = Math.exp(-e * e / 2);
                m.push(n),
                0 == t ? g += n : t < f && (g += 2 * n)
            }
            for (let t = 0; t < m.length; t++)
                m[t] = m[t] / g;
            h.envMap.value = t.texture,
            h.samples.value = f,
            h.weights.value = m,
            h.latitudinal.value = "latitudinal" === s,
            o && (h.poleAxis.value = o),
            h.dTheta.value = d,
            h.mipInt.value = 8 - n,
            this._setEncoding(h.inputEncoding, t.texture),
            this._setEncoding(h.outputEncoding, t.texture);
            const v = Ah[i];
            Bh(e, 3 * Math.max(0, bh - 2 * v), (0 === i ? 0 : 2 * bh) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v),
            a.setRenderTarget(e),
            a.render(c, Th)
        }
    }
    function kh(t) {
        return void 0 !== t && t.type === Vo && (t.encoding === ra || t.encoding === sa || t.encoding === oa)
    }
    function Nh() {
        const t = []
          , e = []
          , n = [];
        let i = 8;
        for (let r = 0; r < Mh; r++) {
            const s = Math.pow(2, i);
            e.push(s);
            let o = 1 / s;
            r > 4 ? o = wh[r - 8 + 4 - 1] : 0 == r && (o = 0),
            n.push(o);
            const a = 1 / (s - 1)
              , l = -a / 2
              , c = 1 + a / 2
              , h = [l, l, c, l, c, c, l, l, c, c, l, c]
              , u = 6
              , d = 6
              , p = 3
              , f = 2
              , m = 1
              , g = new Float32Array(p * d * u)
              , v = new Float32Array(f * d * u)
              , y = new Float32Array(m * d * u);
            for (let t = 0; t < u; t++) {
                const e = t % 3 * 2 / 3 - 1
                  , n = t > 2 ? 0 : -1
                  , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                g.set(i, p * d * t),
                v.set(h, f * d * t);
                const r = [t, t, t, t, t, t];
                y.set(r, m * d * t)
            }
            const _ = new Mc;
            _.setAttribute("position", new dc(g,p)),
            _.setAttribute("uv", new dc(v,f)),
            _.setAttribute("faceIndex", new dc(y,m)),
            t.push(_),
            i > 4 && i--
        }
        return {
            _lodPlanes: t,
            _sizeLods: e,
            _sigmas: n
        }
    }
    function zh(t) {
        const e = new za(3 * bh,3 * bh,t);
        return e.texture.mapping = Io,
        e.texture.name = "PMREM.cubeUv",
        e.scissorTest = !0,
        e
    }
    function Bh(t, e, n, i, r) {
        t.viewport.set(e, n, i, r),
        t.scissor.set(e, n, i, r)
    }
    function Fh() {
        const t = new Ea(1,1);
        return new xh({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                texelSize: {
                    value: t
                },
                inputEncoding: {
                    value: Sh[3e3]
                },
                outputEncoding: {
                    value: Sh[3e3]
                }
            },
            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }
    function Uh() {
        return new xh({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                inputEncoding: {
                    value: Sh[3e3]
                },
                outputEncoding: {
                    value: Sh[3e3]
                }
            },
            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1
        })
    }
    function Hh(t) {
        let e = new WeakMap
          , n = null;
        function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n),
            r.dispose())
        }
        return {
            get: function(r) {
                if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                    const s = r.mapping
                      , o = 303 === s || 304 === s
                      , a = s === Po || s === Do;
                    if (o || a) {
                        if (e.has(r))
                            return e.get(r).texture;
                        {
                            const s = r.image;
                            if (o && s && s.height > 0 || a && s && function(t) {
                                let e = 0;
                                for (let n = 0; n < 6; n++)
                                    void 0 !== t[n] && e++;
                                return 6 === e
                            }(s)) {
                                const s = t.getRenderTarget();
                                null === n && (n = new Oh(t));
                                const a = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                return e.set(r, a),
                                t.setRenderTarget(s),
                                r.addEventListener("dispose", i),
                                a.texture
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function() {
                e = new WeakMap,
                null !== n && (n.dispose(),
                n = null)
            }
        }
    }
    function Vh(t) {
        const e = {};
        function n(n) {
            if (void 0 !== e[n])
                return e[n];
            let i;
            switch (n) {
            case "WEBGL_depth_texture":
                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i = t.getExtension(n)
            }
            return e[n] = i,
            i
        }
        return {
            has: function(t) {
                return null !== n(t)
            },
            init: function(t) {
                t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float")
            },
            get: function(t) {
                const e = n(t);
                return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                e
            }
        }
    }
    function Gh(t, e, n, i) {
        const r = {}
          , s = new WeakMap;
        function o(t) {
            const a = t.target;
            null !== a.index && e.remove(a.index);
            for (const t in a.attributes)
                e.remove(a.attributes[t]);
            a.removeEventListener("dispose", o),
            delete r[a.id];
            const l = s.get(a);
            l && (e.remove(l),
            s.delete(a)),
            i.releaseStatesOfGeometry(a),
            !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
            n.memory.geometries--
        }
        function a(t) {
            const n = []
              , i = t.index
              , r = t.attributes.position;
            let o = 0;
            if (null !== i) {
                const t = i.array;
                o = i.version;
                for (let e = 0, i = t.length; e < i; e += 3) {
                    const i = t[e + 0]
                      , r = t[e + 1]
                      , s = t[e + 2];
                    n.push(i, r, r, s, s, i)
                }
            } else {
                const t = r.array;
                o = r.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                    const t = e + 0
                      , i = e + 1
                      , r = e + 2;
                    n.push(t, i, i, r, r, t)
                }
            }
            const a = new (Ra(n) > 65535 ? fc : pc)(n,1);
            a.version = o;
            const l = s.get(t);
            l && e.remove(l),
            s.set(t, a)
        }
        return {
            get: function(t, e) {
                return !0 === r[e.id] || (e.addEventListener("dispose", o),
                r[e.id] = !0,
                n.memory.geometries++),
                e
            },
            update: function(t) {
                const n = t.attributes;
                for (const t in n)
                    e.update(n[t], 34962);
                const i = t.morphAttributes;
                for (const t in i) {
                    const n = i[t];
                    for (let t = 0, i = n.length; t < i; t++)
                        e.update(n[t], 34962)
                }
            },
            getWireframeAttribute: function(t) {
                const e = s.get(t);
                if (e) {
                    const n = t.index;
                    null !== n && e.version < n.version && a(t)
                } else
                    a(t);
                return s.get(t)
            }
        }
    }
    function Wh(t, e, n, i) {
        const r = i.isWebGL2;
        let s, o, a;
        this.setMode = function(t) {
            s = t
        }
        ,
        this.setIndex = function(t) {
            o = t.type,
            a = t.bytesPerElement
        }
        ,
        this.render = function(e, i) {
            t.drawElements(s, i, o, e * a),
            n.update(i, s, 1)
        }
        ,
        this.renderInstances = function(i, l, c) {
            if (0 === c)
                return;
            let h, u;
            if (r)
                h = t,
                u = "drawElementsInstanced";
            else if (h = e.get("ANGLE_instanced_arrays"),
            u = "drawElementsInstancedANGLE",
            null === h)
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[u](s, l, o, i * a, c),
            n.update(l, s, c)
        }
    }
    function jh(t) {
        const e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function() {
                e.frame++,
                e.calls = 0,
                e.triangles = 0,
                e.points = 0,
                e.lines = 0
            },
            update: function(t, n, i) {
                switch (e.calls++,
                n) {
                case 4:
                    e.triangles += i * (t / 3);
                    break;
                case 1:
                    e.lines += i * (t / 2);
                    break;
                case 3:
                    e.lines += i * (t - 1);
                    break;
                case 2:
                    e.lines += i * t;
                    break;
                case 0:
                    e.points += i * t;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }
    class Xh extends Oa {
        constructor(t=null, e=1, n=1, i=1) {
            super(null),
            this.image = {
                data: t,
                width: e,
                height: n,
                depth: i
            },
            this.magFilter = zo,
            this.minFilter = zo,
            this.wrapR = ko,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    function qh(t, e) {
        return t[0] - e[0]
    }
    function Yh(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function Zh(t, e) {
        let n = 1;
        const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
        i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i),
        t.divideScalar(n)
    }
    function Jh(t, e, n) {
        const i = {}
          , r = new Float32Array(8)
          , s = new WeakMap
          , o = new Ua
          , a = [];
        for (let t = 0; t < 8; t++)
            a[t] = [t, 0];
        return {
            update: function(l, c, h, u) {
                const d = l.morphTargetInfluences;
                if (!0 === e.isWebGL2) {
                    const i = c.morphAttributes.position.length;
                    let r = s.get(c);
                    if (void 0 === r || r.count !== i) {
                        void 0 !== r && r.texture.dispose();
                        const t = void 0 !== c.morphAttributes.normal
                          , n = c.morphAttributes.position
                          , a = c.morphAttributes.normal || []
                          , l = !0 === t ? 2 : 1;
                        let h = c.attributes.position.count * l
                          , u = 1;
                        h > e.maxTextureSize && (u = Math.ceil(h / e.maxTextureSize),
                        h = e.maxTextureSize);
                        const d = new Float32Array(h * u * 4 * i)
                          , p = new Xh(d,h,u,i);
                        p.format = Zo,
                        p.type = jo;
                        const f = 4 * l;
                        for (let e = 0; e < i; e++) {
                            const i = n[e]
                              , r = a[e]
                              , s = h * u * 4 * e;
                            for (let e = 0; e < i.count; e++) {
                                o.fromBufferAttribute(i, e),
                                !0 === i.normalized && Zh(o, i);
                                const n = e * f;
                                d[s + n + 0] = o.x,
                                d[s + n + 1] = o.y,
                                d[s + n + 2] = o.z,
                                d[s + n + 3] = 0,
                                !0 === t && (o.fromBufferAttribute(r, e),
                                !0 === r.normalized && Zh(o, r),
                                d[s + n + 4] = o.x,
                                d[s + n + 5] = o.y,
                                d[s + n + 6] = o.z,
                                d[s + n + 7] = 0)
                            }
                        }
                        r = {
                            count: i,
                            texture: p,
                            size: new Ea(h,u)
                        },
                        s.set(c, r)
                    }
                    let a = 0;
                    for (let t = 0; t < d.length; t++)
                        a += d[t];
                    const l = c.morphTargetsRelative ? 1 : 1 - a;
                    u.getUniforms().setValue(t, "morphTargetBaseInfluence", l),
                    u.getUniforms().setValue(t, "morphTargetInfluences", d),
                    u.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n),
                    u.getUniforms().setValue(t, "morphTargetsTextureSize", r.size)
                } else {
                    const e = void 0 === d ? 0 : d.length;
                    let n = i[c.id];
                    if (void 0 === n || n.length !== e) {
                        n = [];
                        for (let t = 0; t < e; t++)
                            n[t] = [t, 0];
                        i[c.id] = n
                    }
                    for (let t = 0; t < e; t++) {
                        const e = n[t];
                        e[0] = t,
                        e[1] = d[t]
                    }
                    n.sort(Yh);
                    for (let t = 0; t < 8; t++)
                        t < e && n[t][1] ? (a[t][0] = n[t][0],
                        a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER,
                        a[t][1] = 0);
                    a.sort(qh);
                    const s = c.morphAttributes.position
                      , o = c.morphAttributes.normal;
                    let l = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = a[t]
                          , n = e[0]
                          , i = e[1];
                        n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + t) !== s[n] && c.setAttribute("morphTarget" + t, s[n]),
                        o && c.getAttribute("morphNormal" + t) !== o[n] && c.setAttribute("morphNormal" + t, o[n]),
                        r[t] = i,
                        l += i) : (s && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t),
                        o && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t),
                        r[t] = 0)
                    }
                    const h = c.morphTargetsRelative ? 1 : 1 - l;
                    u.getUniforms().setValue(t, "morphTargetBaseInfluence", h),
                    u.getUniforms().setValue(t, "morphTargetInfluences", r)
                }
            }
        }
    }
    function Kh(t, e, n, i) {
        let r = new WeakMap;
        function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
            n.remove(e.instanceMatrix),
            null !== e.instanceColor && n.remove(e.instanceColor)
        }
        return {
            update: function(t) {
                const o = i.render.frame
                  , a = t.geometry
                  , l = e.get(t, a);
                return r.get(l) !== o && (e.update(l),
                r.set(l, o)),
                t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s),
                n.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                l
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }
    Xh.prototype.isDataTexture2DArray = !0;
    class Qh extends Oa {
        constructor(t=null, e=1, n=1, i=1) {
            super(null),
            this.image = {
                data: t,
                width: e,
                height: n,
                depth: i
            },
            this.magFilter = zo,
            this.minFilter = zo,
            this.wrapR = ko,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    Qh.prototype.isDataTexture3D = !0;
    const $h = new Oa
      , tu = new Xh
      , eu = new Qh
      , nu = new Qc
      , iu = []
      , ru = []
      , su = new Float32Array(16)
      , ou = new Float32Array(9)
      , au = new Float32Array(4);
    function lu(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0)
            return t;
        const r = e * n;
        let s = iu[r];
        if (void 0 === s && (s = new Float32Array(r),
        iu[r] = s),
        0 !== e) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== e; ++i)
                r += n,
                t[i].toArray(s, r)
        }
        return s
    }
    function cu(t, e) {
        if (t.length !== e.length)
            return !1;
        for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n])
                return !1;
        return !0
    }
    function hu(t, e) {
        for (let n = 0, i = e.length; n < i; n++)
            t[n] = e[n]
    }
    function uu(t, e) {
        let n = ru[e];
        void 0 === n && (n = new Int32Array(e),
        ru[e] = n);
        for (let i = 0; i !== e; ++i)
            n[i] = t.allocateTextureUnit();
        return n
    }
    function du(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e),
        n[0] = e)
    }
    function pu(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
            n[0] = e.x,
            n[1] = e.y);
        else {
            if (cu(n, e))
                return;
            t.uniform2fv(this.addr, e),
            hu(n, e)
        }
    }
    function fu(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
            n[0] = e.x,
            n[1] = e.y,
            n[2] = e.z);
        else if (void 0 !== e.r)
            n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
            n[0] = e.r,
            n[1] = e.g,
            n[2] = e.b);
        else {
            if (cu(n, e))
                return;
            t.uniform3fv(this.addr, e),
            hu(n, e)
        }
    }
    function mu(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            n[0] = e.x,
            n[1] = e.y,
            n[2] = e.z,
            n[3] = e.w);
        else {
            if (cu(n, e))
                return;
            t.uniform4fv(this.addr, e),
            hu(n, e)
        }
    }
    function gu(t, e) {
        const n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if (cu(n, e))
                return;
            t.uniformMatrix2fv(this.addr, !1, e),
            hu(n, e)
        } else {
            if (cu(n, i))
                return;
            au.set(i),
            t.uniformMatrix2fv(this.addr, !1, au),
            hu(n, i)
        }
    }
    function vu(t, e) {
        const n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if (cu(n, e))
                return;
            t.uniformMatrix3fv(this.addr, !1, e),
            hu(n, e)
        } else {
            if (cu(n, i))
                return;
            ou.set(i),
            t.uniformMatrix3fv(this.addr, !1, ou),
            hu(n, i)
        }
    }
    function yu(t, e) {
        const n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if (cu(n, e))
                return;
            t.uniformMatrix4fv(this.addr, !1, e),
            hu(n, e)
        } else {
            if (cu(n, i))
                return;
            su.set(i),
            t.uniformMatrix4fv(this.addr, !1, su),
            hu(n, i)
        }
    }
    function _u(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e),
        n[0] = e)
    }
    function xu(t, e) {
        const n = this.cache;
        cu(n, e) || (t.uniform2iv(this.addr, e),
        hu(n, e))
    }
    function bu(t, e) {
        const n = this.cache;
        cu(n, e) || (t.uniform3iv(this.addr, e),
        hu(n, e))
    }
    function wu(t, e) {
        const n = this.cache;
        cu(n, e) || (t.uniform4iv(this.addr, e),
        hu(n, e))
    }
    function Mu(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e),
        n[0] = e)
    }
    function Su(t, e) {
        const n = this.cache;
        cu(n, e) || (t.uniform2uiv(this.addr, e),
        hu(n, e))
    }
    function Tu(t, e) {
        const n = this.cache;
        cu(n, e) || (t.uniform3uiv(this.addr, e),
        hu(n, e))
    }
    function Eu(t, e) {
        const n = this.cache;
        cu(n, e) || (t.uniform4uiv(this.addr, e),
        hu(n, e))
    }
    function Au(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTexture2D(e || $h, r)
    }
    function Ru(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture3D(e || eu, r)
    }
    function Lu(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTextureCube(e || nu, r)
    }
    function Cu(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture2DArray(e || tu, r)
    }
    function Pu(t, e) {
        t.uniform1fv(this.addr, e)
    }
    function Du(t, e) {
        const n = lu(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }
    function Iu(t, e) {
        const n = lu(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }
    function Ou(t, e) {
        const n = lu(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }
    function ku(t, e) {
        const n = lu(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }
    function Nu(t, e) {
        const n = lu(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }
    function zu(t, e) {
        const n = lu(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }
    function Bu(t, e) {
        t.uniform1iv(this.addr, e)
    }
    function Fu(t, e) {
        t.uniform2iv(this.addr, e)
    }
    function Uu(t, e) {
        t.uniform3iv(this.addr, e)
    }
    function Hu(t, e) {
        t.uniform4iv(this.addr, e)
    }
    function Vu(t, e) {
        t.uniform1uiv(this.addr, e)
    }
    function Gu(t, e) {
        t.uniform2uiv(this.addr, e)
    }
    function Wu(t, e) {
        t.uniform3uiv(this.addr, e)
    }
    function ju(t, e) {
        t.uniform4uiv(this.addr, e)
    }
    function Xu(t, e, n) {
        const i = e.length
          , r = uu(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t)
            n.safeSetTexture2D(e[t] || $h, r[t])
    }
    function qu(t, e, n) {
        const i = e.length
          , r = uu(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t)
            n.safeSetTextureCube(e[t] || nu, r[t])
    }
    function Yu(t, e, n) {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return du;
            case 35664:
                return pu;
            case 35665:
                return fu;
            case 35666:
                return mu;
            case 35674:
                return gu;
            case 35675:
                return vu;
            case 35676:
                return yu;
            case 5124:
            case 35670:
                return _u;
            case 35667:
            case 35671:
                return xu;
            case 35668:
            case 35672:
                return bu;
            case 35669:
            case 35673:
                return wu;
            case 5125:
                return Mu;
            case 36294:
                return Su;
            case 36295:
                return Tu;
            case 36296:
                return Eu;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Au;
            case 35679:
            case 36299:
            case 36307:
                return Ru;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Lu;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Cu
            }
        }(e.type)
    }
    function Zu(t, e, n) {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.size = e.size,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return Pu;
            case 35664:
                return Du;
            case 35665:
                return Iu;
            case 35666:
                return Ou;
            case 35674:
                return ku;
            case 35675:
                return Nu;
            case 35676:
                return zu;
            case 5124:
            case 35670:
                return Bu;
            case 35667:
            case 35671:
                return Fu;
            case 35668:
            case 35672:
                return Uu;
            case 35669:
            case 35673:
                return Hu;
            case 5125:
                return Vu;
            case 36294:
                return Gu;
            case 36295:
                return Wu;
            case 36296:
                return ju;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Xu;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return qu
            }
        }(e.type)
    }
    function Ju(t) {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    Zu.prototype.updateCache = function(t) {
        const e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
        hu(e, t)
    }
    ,
    Ju.prototype.setValue = function(t, e, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(t, e[s.id], n)
        }
    }
    ;
    const Ku = /(\w+)(\])?(\[|\.)?/g;
    function Qu(t, e) {
        t.seq.push(e),
        t.map[e.id] = e
    }
    function $u(t, e, n) {
        const i = t.name
          , r = i.length;
        for (Ku.lastIndex = 0; ; ) {
            const s = Ku.exec(i)
              , o = Ku.lastIndex;
            let a = s[1];
            const l = "]" === s[2]
              , c = s[3];
            if (l && (a |= 0),
            void 0 === c || "[" === c && o + 2 === r) {
                Qu(n, void 0 === c ? new Yu(a,t,e) : new Zu(a,t,e));
                break
            }
            {
                let t = n.map[a];
                void 0 === t && (t = new Ju(a),
                Qu(n, t)),
                n = t
            }
        }
    }
    function td(t, e) {
        this.seq = [],
        this.map = {};
        const n = t.getProgramParameter(e, 35718);
        for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            $u(n, t.getUniformLocation(e, n.name), this)
        }
    }
    function ed(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n),
        t.compileShader(i),
        i
    }
    td.prototype.setValue = function(t, e, n, i) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, n, i)
    }
    ,
    td.prototype.setOptional = function(t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }
    ,
    td.upload = function(t, e, n, i) {
        for (let r = 0, s = e.length; r !== s; ++r) {
            const s = e[r]
              , o = n[s.id];
            !1 !== o.needsUpdate && s.setValue(t, o.value, i)
        }
    }
    ,
    td.seqWithValue = function(t, e) {
        const n = [];
        for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i];
            r.id in e && n.push(r)
        }
        return n
    }
    ;
    let nd = 0;
    function id(t) {
        switch (t) {
        case ra:
            return ["Linear", "( value )"];
        case sa:
            return ["sRGB", "( value )"];
        case aa:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case oa:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
            return ["LogLuv", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
        }
    }
    function rd(t, e, n) {
        const i = t.getShaderParameter(e, 35713)
          , r = t.getShaderInfoLog(e).trim();
        return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) {
            const e = t.split("\n");
            for (let t = 0; t < e.length; t++)
                e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(t.getShaderSource(e))
    }
    function sd(t, e) {
        const n = id(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }
    function od(t, e) {
        const n = id(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }
    function ad(t, e) {
        let n;
        switch (e) {
        case 1:
            n = "Linear";
            break;
        case 2:
            n = "Reinhard";
            break;
        case 3:
            n = "OptimizedCineon";
            break;
        case 4:
            n = "ACESFilmic";
            break;
        case 5:
            n = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            n = "Linear"
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    function ld(t) {
        return "" !== t
    }
    function cd(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }
    function hd(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const ud = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function dd(t) {
        return t.replace(ud, pd)
    }
    function pd(t, e) {
        const n = hh[e];
        if (void 0 === n)
            throw new Error("Can not resolve #include <" + e + ">");
        return dd(n)
    }
    const fd = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
      , md = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function gd(t) {
        return t.replace(md, yd).replace(fd, vd)
    }
    function vd(t, e, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
        yd(0, e, n, i)
    }
    function yd(t, e, n, i) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(n); t++)
            r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
        return r
    }
    function _d(t) {
        let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
    }
    function xd(t, e, n, i) {
        const r = t.getContext()
          , s = n.defines;
        let o = n.vertexShader
          , a = n.fragmentShader;
        const l = function(t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
            e
        }(n)
          , c = function(t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
                switch (t.envMapMode) {
                case Po:
                case Do:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case Io:
                case 307:
                    e = "ENVMAP_TYPE_CUBE_UV"
                }
            return e
        }(n)
          , h = function(t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
                switch (t.envMapMode) {
                case Do:
                case 307:
                    e = "ENVMAP_MODE_REFRACTION"
                }
            return e
        }(n)
          , u = function(t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
                switch (t.combine) {
                case 0:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    e = "ENVMAP_BLENDING_ADD"
                }
            return e
        }(n)
          , d = t.gammaFactor > 0 ? t.gammaFactor : 1
          , p = n.isWebGL2 ? "" : function(t) {
            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ld).join("\n")
        }(n)
          , f = function(t) {
            const e = [];
            for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i)
            }
            return e.join("\n")
        }(s)
          , m = r.createProgram();
        let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (g = [f].filter(ld).join("\n"),
        g.length > 0 && (g += "\n"),
        v = [p, f].filter(ld).join("\n"),
        v.length > 0 && (v += "\n")) : (g = [_d(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ld).join("\n"),
        v = [p, _d(n), "#define SHADER_NAME " + n.shaderName, f, "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? hh.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? ad("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === Yo ? "#define OPAQUE" : "", hh.encodings_pars_fragment, n.map ? sd("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? sd("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? sd("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? sd("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularColorMap ? sd("specularColorMapTexelToLinear", n.specularColorMapEncoding) : "", n.sheenColorMap ? sd("sheenColorMapTexelToLinear", n.sheenColorMapEncoding) : "", n.lightMap ? sd("lightMapTexelToLinear", n.lightMapEncoding) : "", od("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ld).join("\n")),
        o = dd(o),
        o = cd(o, n),
        o = hd(o, n),
        a = dd(a),
        a = cd(a, n),
        a = hd(a, n),
        o = gd(o),
        a = gd(a),
        n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
        g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
        v = ["#define varying in", n.glslVersion === ua ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === ua ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
        const _ = y + v + a
          , x = ed(r, 35633, y + g + o)
          , b = ed(r, 35632, _);
        if (r.attachShader(m, x),
        r.attachShader(m, b),
        void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
        r.linkProgram(m),
        t.debug.checkShaderErrors) {
            const t = r.getProgramInfoLog(m).trim()
              , e = r.getShaderInfoLog(x).trim()
              , n = r.getShaderInfoLog(b).trim();
            let i = !0
              , s = !0;
            if (!1 === r.getProgramParameter(m, 35714)) {
                i = !1;
                const e = rd(r, x, "vertex")
                  , n = rd(r, b, "fragment");
                console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
            } else
                "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
            s && (this.diagnostics = {
                runnable: i,
                programLog: t,
                vertexShader: {
                    log: e,
                    prefix: g
                },
                fragmentShader: {
                    log: n,
                    prefix: v
                }
            })
        }
        let w, M;
        return r.deleteShader(x),
        r.deleteShader(b),
        this.getUniforms = function() {
            return void 0 === w && (w = new td(r,m)),
            w
        }
        ,
        this.getAttributes = function() {
            return void 0 === M && (M = function(t, e) {
                const n = {}
                  , i = t.getProgramParameter(e, 35721);
                for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r)
                      , s = i.name;
                    let o = 1;
                    35674 === i.type && (o = 2),
                    35675 === i.type && (o = 3),
                    35676 === i.type && (o = 4),
                    n[s] = {
                        type: i.type,
                        location: t.getAttribLocation(e, s),
                        locationSize: o
                    }
                }
                return n
            }(r, m)),
            M
        }
        ,
        this.destroy = function() {
            i.releaseStatesOfProgram(this),
            r.deleteProgram(m),
            this.program = void 0
        }
        ,
        this.name = n.shaderName,
        this.id = nd++,
        this.cacheKey = e,
        this.usedTimes = 1,
        this.program = m,
        this.vertexShader = x,
        this.fragmentShader = b,
        this
    }
    function bd(t, e, n, i, r, s, o) {
        const a = []
          , l = r.isWebGL2
          , c = r.logarithmicDepthBuffer
          , h = r.floatVertexTextures
          , u = r.maxVertexUniforms
          , d = r.vertexTextures;
        let p = r.precision;
        const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];
        function g(t) {
            let e;
            return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            e = t.texture.encoding) : e = ra,
            l && t && t.isTexture && t.format === Zo && t.type === Vo && t.encoding === sa && (e = ra),
            e
        }
        return {
            getParameters: function(s, a, m, v, y) {
                const _ = v.fog
                  , x = s.isMeshStandardMaterial ? v.environment : null
                  , b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x)
                  , w = f[s.type]
                  , M = y.isSkinnedMesh ? function(t) {
                    const e = t.skeleton.bones;
                    if (h)
                        return 1024;
                    {
                        const t = u
                          , n = Math.floor((t - 20) / 4)
                          , i = Math.min(n, e.length);
                        return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."),
                        0) : i
                    }
                }(y) : 0;
                let S, T;
                if (null !== s.precision && (p = r.getMaxPrecision(s.precision),
                p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead.")),
                w) {
                    const t = dh[w];
                    S = t.vertexShader,
                    T = t.fragmentShader
                } else
                    S = s.vertexShader,
                    T = s.fragmentShader;
                const E = t.getRenderTarget()
                  , A = s.alphaTest > 0
                  , R = s.clearcoat > 0;
                return {
                    isWebGL2: l,
                    shaderID: w,
                    shaderName: s.type,
                    vertexShader: S,
                    fragmentShader: T,
                    defines: s.defines,
                    isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                    glslVersion: s.glslVersion,
                    precision: p,
                    instancing: !0 === y.isInstancedMesh,
                    instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                    supportsVertexTextures: d,
                    outputEncoding: null !== E ? g(E.texture) : t.outputEncoding,
                    map: !!s.map,
                    mapEncoding: g(s.map),
                    matcap: !!s.matcap,
                    matcapEncoding: g(s.matcap),
                    envMap: !!b,
                    envMapMode: b && b.mapping,
                    envMapEncoding: g(b),
                    envMapCubeUV: !!b && (b.mapping === Io || 307 === b.mapping),
                    lightMap: !!s.lightMap,
                    lightMapEncoding: g(s.lightMap),
                    aoMap: !!s.aoMap,
                    emissiveMap: !!s.emissiveMap,
                    emissiveMapEncoding: g(s.emissiveMap),
                    bumpMap: !!s.bumpMap,
                    normalMap: !!s.normalMap,
                    objectSpaceNormalMap: 1 === s.normalMapType,
                    tangentSpaceNormalMap: 0 === s.normalMapType,
                    clearcoat: R,
                    clearcoatMap: R && !!s.clearcoatMap,
                    clearcoatRoughnessMap: R && !!s.clearcoatRoughnessMap,
                    clearcoatNormalMap: R && !!s.clearcoatNormalMap,
                    displacementMap: !!s.displacementMap,
                    roughnessMap: !!s.roughnessMap,
                    metalnessMap: !!s.metalnessMap,
                    specularMap: !!s.specularMap,
                    specularIntensityMap: !!s.specularIntensityMap,
                    specularColorMap: !!s.specularColorMap,
                    specularColorMapEncoding: g(s.specularColorMap),
                    alphaMap: !!s.alphaMap,
                    alphaTest: A,
                    gradientMap: !!s.gradientMap,
                    sheen: s.sheen > 0,
                    sheenColorMap: !!s.sheenColorMap,
                    sheenColorMapEncoding: g(s.sheenColorMap),
                    sheenRoughnessMap: !!s.sheenRoughnessMap,
                    transmission: s.transmission > 0,
                    transmissionMap: !!s.transmissionMap,
                    thicknessMap: !!s.thicknessMap,
                    combine: s.combine,
                    vertexTangents: !!s.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
                    vertexColors: s.vertexColors,
                    vertexAlphas: !0 === s.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
                    vertexUvs: !!s.map || !!s.bumpMap || !!s.normalMap || !!s.specularMap || !!s.alphaMap || !!s.emissiveMap || !!s.roughnessMap || !!s.metalnessMap || !!s.clearcoatMap || !!s.clearcoatRoughnessMap || !!s.clearcoatNormalMap || !!s.displacementMap || !!s.transmissionMap || !!s.thicknessMap || !!s.specularIntensityMap || !!s.specularColorMap || !!s.sheenColorMap || s.sheenRoughnessMap,
                    uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || !!s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                    fog: !!_,
                    useFog: s.fog,
                    fogExp2: _ && _.isFogExp2,
                    flatShading: !!s.flatShading,
                    sizeAttenuation: s.sizeAttenuation,
                    logarithmicDepthBuffer: c,
                    skinning: !0 === y.isSkinnedMesh && M > 0,
                    maxBones: M,
                    useVertexTexture: h,
                    morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
                    morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
                    morphTargetsCount: y.geometry && y.geometry.morphAttributes.position ? y.geometry.morphAttributes.position.length : 0,
                    numDirLights: a.directional.length,
                    numPointLights: a.point.length,
                    numSpotLights: a.spot.length,
                    numRectAreaLights: a.rectArea.length,
                    numHemiLights: a.hemi.length,
                    numDirLightShadows: a.directionalShadowMap.length,
                    numPointLightShadows: a.pointShadowMap.length,
                    numSpotLightShadows: a.spotShadowMap.length,
                    numClippingPlanes: o.numPlanes,
                    numClipIntersection: o.numIntersection,
                    format: s.format,
                    dithering: s.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: s.toneMapped ? t.toneMapping : 0,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: s.premultipliedAlpha,
                    doubleSided: 2 === s.side,
                    flipSided: 1 === s.side,
                    depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                    index0AttributeName: s.index0AttributeName,
                    extensionDerivatives: s.extensions && s.extensions.derivatives,
                    extensionFragDepth: s.extensions && s.extensions.fragDepth,
                    extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                    extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: s.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(e) {
                const n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(Ca(e.fragmentShader)),
                n.push(Ca(e.vertexShader))),
                void 0 !== e.defines)
                    for (const t in e.defines)
                        n.push(t),
                        n.push(e.defines[t]);
                if (!1 === e.isRawShaderMaterial) {
                    for (let t = 0; t < m.length; t++)
                        n.push(e[m[t]]);
                    n.push(t.outputEncoding),
                    n.push(t.gammaFactor)
                }
                return n.push(e.customProgramCacheKey),
                n.join()
            },
            getUniforms: function(t) {
                const e = f[t.type];
                let n;
                if (e) {
                    const t = dh[e];
                    n = Xc.clone(t.uniforms)
                } else
                    n = t.uniforms;
                return n
            },
            acquireProgram: function(e, n) {
                let i;
                for (let t = 0, e = a.length; t < e; t++) {
                    const e = a[t];
                    if (e.cacheKey === n) {
                        i = e,
                        ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new xd(t,n,e,s),
                a.push(i)),
                i
            },
            releaseProgram: function(t) {
                if (0 == --t.usedTimes) {
                    const e = a.indexOf(t);
                    a[e] = a[a.length - 1],
                    a.pop(),
                    t.destroy()
                }
            },
            programs: a
        }
    }
    function wd() {
        let t = new WeakMap;
        return {
            get: function(e) {
                let n = t.get(e);
                return void 0 === n && (n = {},
                t.set(e, n)),
                n
            },
            remove: function(e) {
                t.delete(e)
            },
            update: function(e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function Md(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function Sd(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function Td(t) {
        const e = [];
        let n = 0;
        const i = []
          , r = []
          , s = []
          , o = {
            id: -1
        };
        function a(i, r, s, a, l, c) {
            let h = e[n];
            const u = t.get(s);
            return void 0 === h ? (h = {
                id: i.id,
                object: i,
                geometry: r,
                material: s,
                program: u.program || o,
                groupOrder: a,
                renderOrder: i.renderOrder,
                z: l,
                group: c
            },
            e[n] = h) : (h.id = i.id,
            h.object = i,
            h.geometry = r,
            h.material = s,
            h.program = u.program || o,
            h.groupOrder = a,
            h.renderOrder = i.renderOrder,
            h.z = l,
            h.group = c),
            n++,
            h
        }
        return {
            opaque: i,
            transmissive: r,
            transparent: s,
            init: function() {
                n = 0,
                i.length = 0,
                r.length = 0,
                s.length = 0
            },
            push: function(t, e, n, o, l, c) {
                const h = a(t, e, n, o, l, c);
                n.transmission > 0 ? r.push(h) : !0 === n.transparent ? s.push(h) : i.push(h)
            },
            unshift: function(t, e, n, o, l, c) {
                const h = a(t, e, n, o, l, c);
                n.transmission > 0 ? r.unshift(h) : !0 === n.transparent ? s.unshift(h) : i.unshift(h)
            },
            finish: function() {
                for (let t = n, i = e.length; t < i; t++) {
                    const n = e[t];
                    if (null === n.id)
                        break;
                    n.id = null,
                    n.object = null,
                    n.geometry = null,
                    n.material = null,
                    n.program = null,
                    n.group = null
                }
            },
            sort: function(t, e) {
                i.length > 1 && i.sort(t || Md),
                r.length > 1 && r.sort(e || Sd),
                s.length > 1 && s.sort(e || Sd)
            }
        }
    }
    function Ed(t) {
        let e = new WeakMap;
        return {
            get: function(n, i) {
                let r;
                return !1 === e.has(n) ? (r = new Td(t),
                e.set(n, [r])) : i >= e.get(n).length ? (r = new Td(t),
                e.get(n).push(r)) : r = e.get(n)[i],
                r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function Ad() {
        const t = {};
        return {
            get: function(e) {
                if (void 0 !== t[e.id])
                    return t[e.id];
                let n;
                switch (e.type) {
                case "DirectionalLight":
                    n = {
                        direction: new Ua,
                        color: new lc
                    };
                    break;
                case "SpotLight":
                    n = {
                        position: new Ua,
                        direction: new Ua,
                        color: new lc,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n = {
                        position: new Ua,
                        color: new lc,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n = {
                        direction: new Ua,
                        skyColor: new lc,
                        groundColor: new lc
                    };
                    break;
                case "RectAreaLight":
                    n = {
                        color: new lc,
                        position: new Ua,
                        halfWidth: new Ua,
                        halfHeight: new Ua
                    }
                }
                return t[e.id] = n,
                n
            }
        }
    }
    let Rd = 0;
    function Ld(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }
    function Cd(t, e) {
        const n = new Ad
          , i = function() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ea
                        };
                        break;
                    case "PointLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Ea,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }()
          , r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        for (let t = 0; t < 9; t++)
            r.probe.push(new Ua);
        const s = new Ua
          , o = new vl
          , a = new vl;
        return {
            setup: function(s, o) {
                let a = 0
                  , l = 0
                  , c = 0;
                for (let t = 0; t < 9; t++)
                    r.probe[t].set(0, 0, 0);
                let h = 0
                  , u = 0
                  , d = 0
                  , p = 0
                  , f = 0
                  , m = 0
                  , g = 0
                  , v = 0;
                s.sort(Ld);
                const y = !0 !== o ? Math.PI : 1;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t]
                      , o = e.color
                      , _ = e.intensity
                      , x = e.distance
                      , b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                    if (e.isAmbientLight)
                        a += o.r * _ * y,
                        l += o.g * _ * y,
                        c += o.b * _ * y;
                    else if (e.isLightProbe)
                        for (let t = 0; t < 9; t++)
                            r.probe[t].addScaledVector(e.sh.coefficients[t], _);
                    else if (e.isDirectionalLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                        e.castShadow) {
                            const t = e.shadow
                              , n = i.get(e);
                            n.shadowBias = t.bias,
                            n.shadowNormalBias = t.normalBias,
                            n.shadowRadius = t.radius,
                            n.shadowMapSize = t.mapSize,
                            r.directionalShadow[h] = n,
                            r.directionalShadowMap[h] = b,
                            r.directionalShadowMatrix[h] = e.shadow.matrix,
                            m++
                        }
                        r.directional[h] = t,
                        h++
                    } else if (e.isSpotLight) {
                        const t = n.get(e);
                        if (t.position.setFromMatrixPosition(e.matrixWorld),
                        t.color.copy(o).multiplyScalar(_ * y),
                        t.distance = x,
                        t.coneCos = Math.cos(e.angle),
                        t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                        t.decay = e.decay,
                        e.castShadow) {
                            const t = e.shadow
                              , n = i.get(e);
                            n.shadowBias = t.bias,
                            n.shadowNormalBias = t.normalBias,
                            n.shadowRadius = t.radius,
                            n.shadowMapSize = t.mapSize,
                            r.spotShadow[d] = n,
                            r.spotShadowMap[d] = b,
                            r.spotShadowMatrix[d] = e.shadow.matrix,
                            v++
                        }
                        r.spot[d] = t,
                        d++
                    } else if (e.isRectAreaLight) {
                        const t = n.get(e);
                        t.color.copy(o).multiplyScalar(_),
                        t.halfWidth.set(.5 * e.width, 0, 0),
                        t.halfHeight.set(0, .5 * e.height, 0),
                        r.rectArea[p] = t,
                        p++
                    } else if (e.isPointLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                        t.distance = e.distance,
                        t.decay = e.decay,
                        e.castShadow) {
                            const t = e.shadow
                              , n = i.get(e);
                            n.shadowBias = t.bias,
                            n.shadowNormalBias = t.normalBias,
                            n.shadowRadius = t.radius,
                            n.shadowMapSize = t.mapSize,
                            n.shadowCameraNear = t.camera.near,
                            n.shadowCameraFar = t.camera.far,
                            r.pointShadow[u] = n,
                            r.pointShadowMap[u] = b,
                            r.pointShadowMatrix[u] = e.shadow.matrix,
                            g++
                        }
                        r.point[u] = t,
                        u++
                    } else if (e.isHemisphereLight) {
                        const t = n.get(e);
                        t.skyColor.copy(e.color).multiplyScalar(_ * y),
                        t.groundColor.copy(e.groundColor).multiplyScalar(_ * y),
                        r.hemi[f] = t,
                        f++
                    }
                }
                p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = uh.LTC_FLOAT_1,
                r.rectAreaLTC2 = uh.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = uh.LTC_HALF_1,
                r.rectAreaLTC2 = uh.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                r.ambient[0] = a,
                r.ambient[1] = l,
                r.ambient[2] = c;
                const _ = r.hash;
                _.directionalLength === h && _.pointLength === u && _.spotLength === d && _.rectAreaLength === p && _.hemiLength === f && _.numDirectionalShadows === m && _.numPointShadows === g && _.numSpotShadows === v || (r.directional.length = h,
                r.spot.length = d,
                r.rectArea.length = p,
                r.point.length = u,
                r.hemi.length = f,
                r.directionalShadow.length = m,
                r.directionalShadowMap.length = m,
                r.pointShadow.length = g,
                r.pointShadowMap.length = g,
                r.spotShadow.length = v,
                r.spotShadowMap.length = v,
                r.directionalShadowMatrix.length = m,
                r.pointShadowMatrix.length = g,
                r.spotShadowMatrix.length = v,
                _.directionalLength = h,
                _.pointLength = u,
                _.spotLength = d,
                _.rectAreaLength = p,
                _.hemiLength = f,
                _.numDirectionalShadows = m,
                _.numPointShadows = g,
                _.numSpotShadows = v,
                r.version = Rd++)
            },
            setupView: function(t, e) {
                let n = 0
                  , i = 0
                  , l = 0
                  , c = 0
                  , h = 0;
                const u = e.matrixWorldInverse;
                for (let e = 0, d = t.length; e < d; e++) {
                    const d = t[e];
                    if (d.isDirectionalLight) {
                        const t = r.directional[n];
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        s.setFromMatrixPosition(d.target.matrixWorld),
                        t.direction.sub(s),
                        t.direction.transformDirection(u),
                        n++
                    } else if (d.isSpotLight) {
                        const t = r.spot[l];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(u),
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        s.setFromMatrixPosition(d.target.matrixWorld),
                        t.direction.sub(s),
                        t.direction.transformDirection(u),
                        l++
                    } else if (d.isRectAreaLight) {
                        const t = r.rectArea[c];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(u),
                        a.identity(),
                        o.copy(d.matrixWorld),
                        o.premultiply(u),
                        a.extractRotation(o),
                        t.halfWidth.set(.5 * d.width, 0, 0),
                        t.halfHeight.set(0, .5 * d.height, 0),
                        t.halfWidth.applyMatrix4(a),
                        t.halfHeight.applyMatrix4(a),
                        c++
                    } else if (d.isPointLight) {
                        const t = r.point[i];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(u),
                        i++
                    } else if (d.isHemisphereLight) {
                        const t = r.hemi[h];
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        t.direction.transformDirection(u),
                        t.direction.normalize(),
                        h++
                    }
                }
            },
            state: r
        }
    }
    function Pd(t, e) {
        const n = new Cd(t,e)
          , i = []
          , r = [];
        return {
            init: function() {
                i.length = 0,
                r.length = 0
            },
            state: {
                lightsArray: i,
                shadowsArray: r,
                lights: n
            },
            setupLights: function(t) {
                n.setup(i, t)
            },
            setupLightsView: function(t) {
                n.setupView(i, t)
            },
            pushLight: function(t) {
                i.push(t)
            },
            pushShadow: function(t) {
                r.push(t)
            }
        }
    }
    function Dd(t, e) {
        let n = new WeakMap;
        return {
            get: function(i, r=0) {
                let s;
                return !1 === n.has(i) ? (s = new Pd(t,e),
                n.set(i, [s])) : r >= n.get(i).length ? (s = new Pd(t,e),
                n.get(i).push(s)) : s = n.get(i)[r],
                s
            },
            dispose: function() {
                n = new WeakMap
            }
        }
    }
    class Id extends ec {
        constructor(t) {
            super(),
            this.type = "MeshDepthMaterial",
            this.depthPacking = 3200,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.depthPacking = t.depthPacking,
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this
        }
    }
    Id.prototype.isMeshDepthMaterial = !0;
    class Od extends ec {
        constructor(t) {
            super(),
            this.type = "MeshDistanceMaterial",
            this.referencePosition = new Ua,
            this.nearDistance = 1,
            this.farDistance = 1e3,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.fog = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.referencePosition.copy(t.referencePosition),
            this.nearDistance = t.nearDistance,
            this.farDistance = t.farDistance,
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this
        }
    }
    function kd(t, e, n) {
        let i = new oh;
        const r = new Ea
          , s = new Ea
          , o = new Na
          , a = new Id({
            depthPacking: 3201
        })
          , l = new Od
          , c = {}
          , h = n.maxTextureSize
          , u = {
            0: 1,
            1: 0,
            2: 2
        }
          , d = new qc({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Ea
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        })
          , p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const f = new Mc;
        f.setAttribute("position", new dc(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        const m = new Hc(f,d)
          , g = this;
        function v(n, i) {
            const r = e.update(m);
            d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples,
            p.defines.VSM_SAMPLES = n.blurSamples,
            d.needsUpdate = !0,
            p.needsUpdate = !0),
            d.uniforms.shadow_pass.value = n.map.texture,
            d.uniforms.resolution.value = n.mapSize,
            d.uniforms.radius.value = n.radius,
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, r, d, m, null),
            p.uniforms.shadow_pass.value = n.mapPass.texture,
            p.uniforms.resolution.value = n.mapSize,
            p.uniforms.radius.value = n.radius,
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, r, p, m, null)
        }
        function y(e, n, i, r, s, o, h) {
            let d = null;
            const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
            if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : a,
            t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                const t = d.uuid
                  , e = i.uuid;
                let n = c[t];
                void 0 === n && (n = {},
                c[t] = n);
                let r = n[e];
                void 0 === r && (r = d.clone(),
                n[e] = r),
                d = r
            }
            return d.visible = i.visible,
            d.wireframe = i.wireframe,
            d.side = 3 === h ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side],
            d.alphaMap = i.alphaMap,
            d.alphaTest = i.alphaTest,
            d.clipShadows = i.clipShadows,
            d.clippingPlanes = i.clippingPlanes,
            d.clipIntersection = i.clipIntersection,
            d.displacementMap = i.displacementMap,
            d.displacementScale = i.displacementScale,
            d.displacementBias = i.displacementBias,
            d.wireframeLinewidth = i.wireframeLinewidth,
            d.linewidth = i.linewidth,
            !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
            d.nearDistance = s,
            d.farDistance = o),
            d
        }
        function _(n, r, s, o, a) {
            if (!1 === n.visible)
                return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                const i = e.update(n)
                  , r = n.material;
                if (Array.isArray(r)) {
                    const e = i.groups;
                    for (let l = 0, c = e.length; l < c; l++) {
                        const c = e[l]
                          , h = r[c.materialIndex];
                        if (h && h.visible) {
                            const e = y(n, 0, h, o, s.near, s.far, a);
                            t.renderBufferDirect(s, null, i, e, n, c)
                        }
                    }
                } else if (r.visible) {
                    const e = y(n, 0, r, o, s.near, s.far, a);
                    t.renderBufferDirect(s, null, i, e, n, null)
                }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++)
                _(l[t], r, s, o, a)
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(e, n, a) {
            if (!1 === g.enabled)
                return;
            if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                return;
            if (0 === e.length)
                return;
            const l = t.getRenderTarget()
              , c = t.getActiveCubeFace()
              , u = t.getActiveMipmapLevel()
              , d = t.state;
            d.setBlending(0),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
            for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l]
                  , u = c.shadow;
                if (void 0 === u) {
                    console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                    continue
                }
                if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                    continue;
                r.copy(u.mapSize);
                const p = u.getFrameExtents();
                if (r.multiply(p),
                s.copy(u.mapSize),
                (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x),
                r.x = s.x * p.x,
                u.mapSize.x = s.x),
                r.y > h && (s.y = Math.floor(h / p.y),
                r.y = s.y * p.y,
                u.mapSize.y = s.y)),
                null === u.map && !u.isPointLightShadow && 3 === this.type) {
                    const t = {
                        minFilter: Uo,
                        magFilter: Uo,
                        format: Zo
                    };
                    u.map = new za(r.x,r.y,t),
                    u.map.texture.name = c.name + ".shadowMap",
                    u.mapPass = new za(r.x,r.y,t),
                    u.camera.updateProjectionMatrix()
                }
                if (null === u.map) {
                    const t = {
                        minFilter: zo,
                        magFilter: zo,
                        format: Zo
                    };
                    u.map = new za(r.x,r.y,t),
                    u.map.texture.name = c.name + ".shadowMap",
                    u.camera.updateProjectionMatrix()
                }
                t.setRenderTarget(u.map),
                t.clear();
                const f = u.getViewportCount();
                for (let t = 0; t < f; t++) {
                    const e = u.getViewport(t);
                    o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                    d.viewport(o),
                    u.updateMatrices(c, t),
                    i = u.getFrustum(),
                    _(n, a, u.camera, c, this.type)
                }
                u.isPointLightShadow || 3 !== this.type || v(u, a),
                u.needsUpdate = !1
            }
            g.needsUpdate = !1,
            t.setRenderTarget(l, c, u)
        }
    }
    function Nd(t, e, n) {
        const i = n.isWebGL2
          , r = new function() {
            let e = !1;
            const n = new Na;
            let i = null;
            const r = new Na(0,0,0,0);
            return {
                setMask: function(n) {
                    i === n || e || (t.colorMask(n, n, n, n),
                    i = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, i, s, o, a) {
                    !0 === a && (e *= o,
                    i *= o,
                    s *= o),
                    n.set(e, i, s, o),
                    !1 === r.equals(n) && (t.clearColor(e, i, s, o),
                    r.copy(n))
                },
                reset: function() {
                    e = !1,
                    i = null,
                    r.set(-1, 0, 0, 0)
                }
            }
        }
          , s = new function() {
            let e = !1
              , n = null
              , i = null
              , r = null;
            return {
                setTest: function(t) {
                    t ? z(2929) : B(2929)
                },
                setMask: function(i) {
                    n === i || e || (t.depthMask(i),
                    n = i)
                },
                setFunc: function(e) {
                    if (i !== e) {
                        if (e)
                            switch (e) {
                            case 0:
                                t.depthFunc(512);
                                break;
                            case 1:
                                t.depthFunc(519);
                                break;
                            case 2:
                                t.depthFunc(513);
                                break;
                            default:
                                t.depthFunc(515);
                                break;
                            case 4:
                                t.depthFunc(514);
                                break;
                            case 5:
                                t.depthFunc(518);
                                break;
                            case 6:
                                t.depthFunc(516);
                                break;
                            case 7:
                                t.depthFunc(517)
                            }
                        else
                            t.depthFunc(515);
                        i = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    r !== e && (t.clearDepth(e),
                    r = e)
                },
                reset: function() {
                    e = !1,
                    n = null,
                    i = null,
                    r = null
                }
            }
        }
          , o = new function() {
            let e = !1
              , n = null
              , i = null
              , r = null
              , s = null
              , o = null
              , a = null
              , l = null
              , c = null;
            return {
                setTest: function(t) {
                    e || (t ? z(2960) : B(2960))
                },
                setMask: function(i) {
                    n === i || e || (t.stencilMask(i),
                    n = i)
                },
                setFunc: function(e, n, o) {
                    i === e && r === n && s === o || (t.stencilFunc(e, n, o),
                    i = e,
                    r = n,
                    s = o)
                },
                setOp: function(e, n, i) {
                    o === e && a === n && l === i || (t.stencilOp(e, n, i),
                    o = e,
                    a = n,
                    l = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    c !== e && (t.clearStencil(e),
                    c = e)
                },
                reset: function() {
                    e = !1,
                    n = null,
                    i = null,
                    r = null,
                    s = null,
                    o = null,
                    a = null,
                    l = null,
                    c = null
                }
            }
        }
        ;
        let a = {}
          , l = null
          , c = {}
          , h = null
          , u = !1
          , d = null
          , p = null
          , f = null
          , m = null
          , g = null
          , v = null
          , y = null
          , _ = !1
          , x = null
          , b = null
          , w = null
          , M = null
          , S = null;
        const T = t.getParameter(35661);
        let E = !1
          , A = 0;
        const R = t.getParameter(7938);
        -1 !== R.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(R)[1]),
        E = A >= 1) : -1 !== R.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),
        E = A >= 2);
        let L = null
          , C = {};
        const P = t.getParameter(3088)
          , D = t.getParameter(2978)
          , I = (new Na).fromArray(P)
          , O = (new Na).fromArray(D);
        function k(e, n, i) {
            const r = new Uint8Array(4)
              , s = t.createTexture();
            t.bindTexture(e, s),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < i; e++)
                t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return s
        }
        const N = {};
        function z(e) {
            !0 !== a[e] && (t.enable(e),
            a[e] = !0)
        }
        function B(e) {
            !1 !== a[e] && (t.disable(e),
            a[e] = !1)
        }
        N[3553] = k(3553, 3553, 1),
        N[34067] = k(34067, 34069, 6),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        o.setClear(0),
        z(2929),
        s.setFunc(3),
        V(!1),
        G(1),
        z(2884),
        H(0);
        const F = {
            [Co]: 32774,
            101: 32778,
            102: 32779
        };
        if (i)
            F[103] = 32775,
            F[104] = 32776;
        else {
            const t = e.get("EXT_blend_minmax");
            null !== t && (F[103] = t.MIN_EXT,
            F[104] = t.MAX_EXT)
        }
        const U = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };
        function H(e, n, i, r, s, o, a, l) {
            if (0 !== e) {
                if (!1 === u && (z(3042),
                u = !0),
                5 === e)
                    s = s || n,
                    o = o || i,
                    a = a || r,
                    n === p && s === g || (t.blendEquationSeparate(F[n], F[s]),
                    p = n,
                    g = s),
                    i === f && r === m && o === v && a === y || (t.blendFuncSeparate(U[i], U[r], U[o], U[a]),
                    f = i,
                    m = r,
                    v = o,
                    y = a),
                    d = e,
                    _ = null;
                else if (e !== d || l !== _) {
                    if (p === Co && g === Co || (t.blendEquation(32774),
                    p = Co,
                    g = Co),
                    l)
                        switch (e) {
                        case 1:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(1, 1);
                            break;
                        case 3:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            t.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    else
                        switch (e) {
                        case 1:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(770, 1);
                            break;
                        case 3:
                            t.blendFunc(0, 769);
                            break;
                        case 4:
                            t.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    f = null,
                    m = null,
                    v = null,
                    y = null,
                    d = e,
                    _ = l
                }
            } else
                !0 === u && (B(3042),
                u = !1)
        }
        function V(e) {
            x !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
            x = e)
        }
        function G(e) {
            0 !== e ? (z(2884),
            e !== b && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : B(2884),
            b = e
        }
        function W(e, n, i) {
            e ? (z(32823),
            M === n && S === i || (t.polygonOffset(n, i),
            M = n,
            S = i)) : B(32823)
        }
        function j(e) {
            void 0 === e && (e = 33984 + T - 1),
            L !== e && (t.activeTexture(e),
            L = e)
        }
        return {
            buffers: {
                color: r,
                depth: s,
                stencil: o
            },
            enable: z,
            disable: B,
            bindFramebuffer: function(e, n) {
                return null === n && null !== l && (n = l),
                c[e] !== n && (t.bindFramebuffer(e, n),
                c[e] = n,
                i && (36009 === e && (c[36160] = n),
                36160 === e && (c[36009] = n)),
                !0)
            },
            bindXRFramebuffer: function(e) {
                e !== l && (t.bindFramebuffer(36160, e),
                l = e)
            },
            useProgram: function(e) {
                return h !== e && (t.useProgram(e),
                h = e,
                !0)
            },
            setBlending: H,
            setMaterial: function(t, e) {
                2 === t.side ? B(2884) : z(2884);
                let n = 1 === t.side;
                e && (n = !n),
                V(n),
                1 === t.blending && !1 === t.transparent ? H(0) : H(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                s.setFunc(t.depthFunc),
                s.setTest(t.depthTest),
                s.setMask(t.depthWrite),
                r.setMask(t.colorWrite);
                const i = t.stencilWrite;
                o.setTest(i),
                i && (o.setMask(t.stencilWriteMask),
                o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                W(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                !0 === t.alphaToCoverage ? z(32926) : B(32926)
            },
            setFlipSided: V,
            setCullFace: G,
            setLineWidth: function(e) {
                e !== w && (E && t.lineWidth(e),
                w = e)
            },
            setPolygonOffset: W,
            setScissorTest: function(t) {
                t ? z(3089) : B(3089)
            },
            activeTexture: j,
            bindTexture: function(e, n) {
                null === L && j();
                let i = C[L];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                C[L] = i),
                i.type === e && i.texture === n || (t.bindTexture(e, n || N[e]),
                i.type = e,
                i.texture = n)
            },
            unbindTexture: function() {
                const e = C[L];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                e.type = void 0,
                e.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function(e) {
                !1 === I.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                I.copy(e))
            },
            viewport: function(e) {
                !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                O.copy(e))
            },
            reset: function() {
                t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === i && (t.bindFramebuffer(36009, null),
                t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                a = {},
                L = null,
                C = {},
                l = null,
                c = {},
                h = null,
                u = !1,
                d = null,
                p = null,
                f = null,
                m = null,
                g = null,
                v = null,
                y = null,
                _ = !1,
                x = null,
                b = null,
                w = null,
                M = null,
                S = null,
                I.set(0, 0, t.canvas.width, t.canvas.height),
                O.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                s.reset(),
                o.reset()
            }
        }
    }
    function zd(t, e, n, i, r, s, o) {
        const a = r.isWebGL2
          , l = r.maxTextures
          , c = r.maxCubemapSize
          , h = r.maxTextureSize
          , u = r.maxSamples
          , d = new WeakMap;
        let p, f = !1;
        try {
            f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
        } catch (t) {}
        function m(t, e) {
            return f ? new OffscreenCanvas(t,e) : La("canvas")
        }
        function g(t, e, n, i) {
            let r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const i = e ? Sa : Math.floor
                      , s = i(r * t.width)
                      , o = i(r * t.height);
                    void 0 === p && (p = m(s, o));
                    const a = n ? m(s, o) : p;
                    return a.width = s,
                    a.height = o,
                    a.getContext("2d").drawImage(t, 0, 0, s, o),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."),
                    a
                }
                return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                t
            }
            return t
        }
        function v(t) {
            return wa(t.width) && wa(t.height)
        }
        function y(t, e) {
            return t.generateMipmaps && e && t.minFilter !== zo && t.minFilter !== Uo
        }
        function _(e, n, r, s, o=1) {
            t.generateMipmap(e),
            i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, o))
        }
        function x(n, i, r, s) {
            if (!1 === a)
                return i;
            if (null !== n) {
                if (void 0 !== t[n])
                    return t[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let o = i;
            return 6403 === i && (5126 === r && (o = 33326),
            5131 === r && (o = 33325),
            5121 === r && (o = 33321)),
            6407 === i && (5126 === r && (o = 34837),
            5131 === r && (o = 34843),
            5121 === r && (o = 32849)),
            6408 === i && (5126 === r && (o = 34836),
            5131 === r && (o = 34842),
            5121 === r && (o = s === sa ? 35907 : 32856)),
            33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"),
            o
        }
        function b(t) {
            return t === zo || t === Bo || t === Fo ? 9728 : 9729
        }
        function w(e) {
            const n = e.target;
            n.removeEventListener("dispose", w),
            function(e) {
                const n = i.get(e);
                void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture),
                i.remove(e))
            }(n),
            n.isVideoTexture && d.delete(n),
            o.memory.textures--
        }
        function M(e) {
            const n = e.target;
            n.removeEventListener("dispose", M),
            function(e) {
                const n = e.texture
                  , r = i.get(e)
                  , s = i.get(n);
                if (e) {
                    if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture),
                    o.memory.textures--),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++)
                            t.deleteFramebuffer(r.__webglFramebuffer[e]),
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                    else
                        t.deleteFramebuffer(r.__webglFramebuffer),
                        r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                        r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                        r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                    if (e.isWebGLMultipleRenderTargets)
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            r.__webglTexture && (t.deleteTexture(r.__webglTexture),
                            o.memory.textures--),
                            i.remove(n[e])
                        }
                    i.remove(n),
                    i.remove(e)
                }
            }(n)
        }
        let S = 0;
        function T(t, e) {
            const r = i.get(t);
            if (t.isVideoTexture && function(t) {
                const e = o.render.frame;
                d.get(t) !== e && (d.set(t, e),
                t.update())
            }(t),
            t.version > 0 && r.__version !== t.version) {
                const n = t.image;
                if (void 0 === n)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== n.complete)
                        return void P(r, t, e);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + e),
            n.bindTexture(3553, r.__webglTexture)
        }
        function E(e, r) {
            const o = i.get(e);
            e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                if (6 !== i.image.length)
                    return;
                C(e, i),
                n.activeTexture(33984 + r),
                n.bindTexture(34067, e.__webglTexture),
                t.pixelStorei(37440, i.flipY),
                t.pixelStorei(37441, i.premultiplyAlpha),
                t.pixelStorei(3317, i.unpackAlignment),
                t.pixelStorei(37443, 0);
                const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture)
                  , l = i.image[0] && i.image[0].isDataTexture
                  , h = [];
                for (let t = 0; t < 6; t++)
                    h[t] = o || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                const u = h[0]
                  , d = v(u) || a
                  , p = s.convert(i.format)
                  , f = s.convert(i.type)
                  , m = x(i.internalFormat, p, f, i.encoding);
                let b;
                if (L(34067, i, d),
                o) {
                    for (let t = 0; t < 6; t++) {
                        b = h[t].mipmaps;
                        for (let e = 0; e < b.length; e++) {
                            const r = b[e];
                            i.format !== Zo && i.format !== Yo ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                        }
                    }
                    e.__maxMipLevel = b.length - 1
                } else {
                    b = i.mipmaps;
                    for (let t = 0; t < 6; t++)
                        if (l) {
                            n.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, p, f, h[t].data);
                            for (let e = 0; e < b.length; e++) {
                                const i = b[e].image[t].image;
                                n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                            }
                        } else {
                            n.texImage2D(34069 + t, 0, m, p, f, h[t]);
                            for (let e = 0; e < b.length; e++) {
                                const i = b[e];
                                n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                            }
                        }
                    e.__maxMipLevel = b.length
                }
                y(i, d) && _(34067, i, u.width, u.height),
                e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }(o, e, r) : (n.activeTexture(33984 + r),
            n.bindTexture(34067, o.__webglTexture))
        }
        const A = {
            [Oo]: 10497,
            [ko]: 33071,
            [No]: 33648
        }
          , R = {
            [zo]: 9728,
            [Bo]: 9984,
            [Fo]: 9986,
            [Uo]: 9729,
            1007: 9985,
            [Ho]: 9987
        };
        function L(n, s, o) {
            if (o ? (t.texParameteri(n, 10242, A[s.wrapS]),
            t.texParameteri(n, 10243, A[s.wrapT]),
            32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]),
            t.texParameteri(n, 10240, R[s.magFilter]),
            t.texParameteri(n, 10241, R[s.minFilter])) : (t.texParameteri(n, 10242, 33071),
            t.texParameteri(n, 10243, 33071),
            32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071),
            s.wrapS === ko && s.wrapT === ko || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            t.texParameteri(n, 10240, b(s.magFilter)),
            t.texParameteri(n, 10241, b(s.minFilter)),
            s.minFilter !== zo && s.minFilter !== Uo && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            !0 === e.has("EXT_texture_filter_anisotropic")) {
                const o = e.get("EXT_texture_filter_anisotropic");
                if (s.type === jo && !1 === e.has("OES_texture_float_linear"))
                    return;
                if (!1 === a && s.type === Xo && !1 === e.has("OES_texture_half_float_linear"))
                    return;
                (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                i.get(s).__currentAnisotropy = s.anisotropy)
            }
        }
        function C(e, n) {
            void 0 === e.__webglInit && (e.__webglInit = !0,
            n.addEventListener("dispose", w),
            e.__webglTexture = t.createTexture(),
            o.memory.textures++)
        }
        function P(e, i, r) {
            let o = 3553;
            i.isDataTexture2DArray && (o = 35866),
            i.isDataTexture3D && (o = 32879),
            C(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(o, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment),
            t.pixelStorei(37443, 0);
            const l = function(t) {
                return !a && (t.wrapS !== ko || t.wrapT !== ko || t.minFilter !== zo && t.minFilter !== Uo)
            }(i) && !1 === v(i.image)
              , c = g(i.image, l, !1, h)
              , u = v(c) || a
              , d = s.convert(i.format);
            let p, f = s.convert(i.type), m = x(i.internalFormat, d, f, i.encoding);
            L(o, i, u);
            const b = i.mipmaps;
            if (i.isDepthTexture)
                m = 6402,
                a ? m = i.type === jo ? 36012 : i.type === Wo ? 33190 : i.type === qo ? 35056 : 33189 : i.type === jo && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                i.format === Jo && 6402 === m && i.type !== Go && i.type !== Wo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                i.type = Go,
                f = s.convert(i.type)),
                i.format === Ko && 6402 === m && (m = 34041,
                i.type !== qo && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                i.type = qo,
                f = s.convert(i.type))),
                n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
            else if (i.isDataTexture)
                if (b.length > 0 && u) {
                    for (let t = 0, e = b.length; t < e; t++)
                        p = b[t],
                        n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    i.generateMipmaps = !1,
                    e.__maxMipLevel = b.length - 1
                } else
                    n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                    e.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (let t = 0, e = b.length; t < e; t++)
                    p = b[t],
                    i.format !== Zo && i.format !== Yo ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                e.__maxMipLevel = b.length - 1
            } else if (i.isDataTexture2DArray)
                n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                e.__maxMipLevel = 0;
            else if (i.isDataTexture3D)
                n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                e.__maxMipLevel = 0;
            else if (b.length > 0 && u) {
                for (let t = 0, e = b.length; t < e; t++)
                    p = b[t],
                    n.texImage2D(3553, t, m, d, f, p);
                i.generateMipmaps = !1,
                e.__maxMipLevel = b.length - 1
            } else
                n.texImage2D(3553, 0, m, d, f, c),
                e.__maxMipLevel = 0;
            y(i, u) && _(o, i, c.width, c.height),
            e.__version = i.version,
            i.onUpdate && i.onUpdate(i)
        }
        function D(e, r, o, a, l) {
            const c = s.convert(o.format)
              , h = s.convert(o.type)
              , u = x(o.internalFormat, c, h, o.encoding);
            32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null),
            n.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0),
            n.bindFramebuffer(36160, null)
        }
        function I(e, n, i) {
            if (t.bindRenderbuffer(36161, e),
            n.depthBuffer && !n.stencilBuffer) {
                let r = 33189;
                if (i) {
                    const e = n.depthTexture;
                    e && e.isDepthTexture && (e.type === jo ? r = 36012 : e.type === Wo && (r = 33190));
                    const i = O(n);
                    t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, r, n.width, n.height);
                t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    const e = O(n);
                    t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, 34041, n.width, n.height);
                t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture
                  , r = s.convert(e.format)
                  , o = s.convert(e.type)
                  , a = x(e.internalFormat, r, o, e.encoding);
                if (i) {
                    const e = O(n);
                    t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, a, n.width, n.height)
            }
            t.bindRenderbuffer(36161, null)
        }
        function O(t) {
            return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
        }
        let k = !1
          , N = !1;
        this.allocateTextureUnit = function() {
            const t = S;
            return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
            S += 1,
            t
        }
        ,
        this.resetTextureUnits = function() {
            S = 0
        }
        ,
        this.setTexture2D = T,
        this.setTexture2DArray = function(t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e),
            n.bindTexture(35866, r.__webglTexture))
        }
        ,
        this.setTexture3D = function(t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version ? P(r, t, e) : (n.activeTexture(33984 + e),
            n.bindTexture(32879, r.__webglTexture))
        }
        ,
        this.setTextureCube = E,
        this.setupRenderTarget = function(e) {
            const l = e.texture
              , c = i.get(e)
              , h = i.get(l);
            e.addEventListener("dispose", M),
            !0 !== e.isWebGLMultipleRenderTargets && (h.__webglTexture = t.createTexture(),
            h.__version = l.version,
            o.memory.textures++);
            const u = !0 === e.isWebGLCubeRenderTarget
              , d = !0 === e.isWebGLMultipleRenderTargets
              , p = !0 === e.isWebGLMultisampleRenderTarget
              , f = l.isDataTexture3D || l.isDataTexture2DArray
              , m = v(e) || a;
            if (!a || l.format !== Yo || l.type !== jo && l.type !== Xo || (l.format = Zo,
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
            u) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                    c.__webglFramebuffer[e] = t.createFramebuffer()
            } else if (c.__webglFramebuffer = t.createFramebuffer(),
            d)
                if (r.drawBuffers) {
                    const n = e.texture;
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = i.get(n[e]);
                        void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(),
                        o.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            else if (p)
                if (a) {
                    c.__webglMultisampledFramebuffer = t.createFramebuffer(),
                    c.__webglColorRenderbuffer = t.createRenderbuffer(),
                    t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                    const i = s.convert(l.format)
                      , r = s.convert(l.type)
                      , o = x(l.internalFormat, i, r, l.encoding)
                      , a = O(e);
                    t.renderbufferStorageMultisample(36161, a, o, e.width, e.height),
                    n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(),
                    I(c.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (u) {
                n.bindTexture(34067, h.__webglTexture),
                L(34067, l, m);
                for (let t = 0; t < 6; t++)
                    D(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                y(l, m) && _(34067, l, e.width, e.height),
                n.unbindTexture()
            } else if (d) {
                const t = e.texture;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r]
                      , o = i.get(s);
                    n.bindTexture(3553, o.__webglTexture),
                    L(3553, s, m),
                    D(c.__webglFramebuffer, e, s, 36064 + r, 3553),
                    y(s, m) && _(3553, s, e.width, e.height)
                }
                n.unbindTexture()
            } else {
                let t = 3553;
                f && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),
                n.bindTexture(t, h.__webglTexture),
                L(t, l, m),
                D(c.__webglFramebuffer, e, l, 36064, t),
                y(l, m) && _(t, l, e.width, e.height, e.depth),
                n.unbindTexture()
            }
            e.depthBuffer && function(e) {
                const r = i.get(e)
                  , s = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (s)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(e, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        T(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture;
                        if (r.depthTexture.format === Jo)
                            t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                        else {
                            if (r.depthTexture.format !== Ko)
                                throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                        r.__webglDepthbuffer[i] = t.createRenderbuffer(),
                        I(r.__webglDepthbuffer[i], e, !1)
                } else
                    n.bindFramebuffer(36160, r.__webglFramebuffer),
                    r.__webglDepthbuffer = t.createRenderbuffer(),
                    I(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }(e)
        }
        ,
        this.updateRenderTargetMipmap = function(t) {
            const e = v(t) || a
              , r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
            for (let s = 0, o = r.length; s < o; s++) {
                const o = r[s];
                if (y(o, e)) {
                    const e = t.isWebGLCubeRenderTarget ? 34067 : 3553
                      , r = i.get(o).__webglTexture;
                    n.bindTexture(e, r),
                    _(e, o, t.width, t.height),
                    n.unbindTexture()
                }
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(e) {
            if (e.isWebGLMultisampleRenderTarget)
                if (a) {
                    const r = e.width
                      , s = e.height;
                    let o = 16384;
                    e.depthBuffer && (o |= 256),
                    e.stencilBuffer && (o |= 1024);
                    const a = i.get(e);
                    n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, a.__webglFramebuffer),
                    t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728),
                    n.bindFramebuffer(36008, null),
                    n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(t, e) {
            t && t.isWebGLRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            k = !0),
            t = t.texture),
            T(t, e)
        }
        ,
        this.safeSetTextureCube = function(t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            N = !0),
            t = t.texture),
            E(t, e)
        }
    }
    function Bd(t, e, n) {
        const i = n.isWebGL2;
        return {
            convert: function(t) {
                let n;
                if (t === Vo)
                    return 5121;
                if (1017 === t)
                    return 32819;
                if (1018 === t)
                    return 32820;
                if (1019 === t)
                    return 33635;
                if (1010 === t)
                    return 5120;
                if (1011 === t)
                    return 5122;
                if (t === Go)
                    return 5123;
                if (1013 === t)
                    return 5124;
                if (t === Wo)
                    return 5125;
                if (t === jo)
                    return 5126;
                if (t === Xo)
                    return i ? 5131 : (n = e.get("OES_texture_half_float"),
                    null !== n ? n.HALF_FLOAT_OES : null);
                if (1021 === t)
                    return 6406;
                if (t === Yo)
                    return 6407;
                if (t === Zo)
                    return 6408;
                if (1024 === t)
                    return 6409;
                if (1025 === t)
                    return 6410;
                if (t === Jo)
                    return 6402;
                if (t === Ko)
                    return 34041;
                if (1028 === t)
                    return 6403;
                if (1029 === t)
                    return 36244;
                if (1030 === t)
                    return 33319;
                if (1031 === t)
                    return 33320;
                if (1032 === t)
                    return 36248;
                if (1033 === t)
                    return 36249;
                if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                    if (n = e.get("WEBGL_compressed_texture_s3tc"),
                    null === n)
                        return null;
                    if (33776 === t)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                    if (n = e.get("WEBGL_compressed_texture_pvrtc"),
                    null === n)
                        return null;
                    if (35840 === t)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t)
                    return n = e.get("WEBGL_compressed_texture_etc1"),
                    null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"),
                null !== n)) {
                    if (37492 === t)
                        return n.COMPRESSED_RGB8_ETC2;
                    if (37496 === t)
                        return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"),
                null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"),
                null !== n ? t : null) : t === qo ? i ? 34042 : (n = e.get("WEBGL_depth_texture"),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }
    Od.prototype.isMeshDistanceMaterial = !0;
    class Fd extends Zc {
        constructor(t=[]) {
            super(),
            this.cameras = t
        }
    }
    Fd.prototype.isArrayCamera = !0;
    class Ud extends Vl {
        constructor() {
            super(),
            this.type = "Group"
        }
    }
    Ud.prototype.isGroup = !0;
    const Hd = {
        type: "move"
    };
    class Vd {
        constructor() {
            this._targetRay = null,
            this._grip = null,
            this._hand = null
        }
        getHandSpace() {
            return null === this._hand && (this._hand = new Ud,
            this._hand.matrixAutoUpdate = !1,
            this._hand.visible = !1,
            this._hand.joints = {},
            this._hand.inputState = {
                pinching: !1
            }),
            this._hand
        }
        getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new Ud,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1,
            this._targetRay.hasLinearVelocity = !1,
            this._targetRay.linearVelocity = new Ua,
            this._targetRay.hasAngularVelocity = !1,
            this._targetRay.angularVelocity = new Ua),
            this._targetRay
        }
        getGripSpace() {
            return null === this._grip && (this._grip = new Ud,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1,
            this._grip.hasLinearVelocity = !1,
            this._grip.linearVelocity = new Ua,
            this._grip.hasAngularVelocity = !1,
            this._grip.angularVelocity = new Ua),
            this._grip
        }
        dispatchEvent(t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
        }
        disconnect(t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
        }
        update(t, e, n) {
            let i = null
              , r = null
              , s = null;
            const o = this._targetRay
              , a = this._grip
              , l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState)
                if (null !== o && (i = e.getPose(t.targetRaySpace, n),
                null !== i && (o.matrix.fromArray(i.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                i.linearVelocity ? (o.hasLinearVelocity = !0,
                o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                i.angularVelocity ? (o.hasAngularVelocity = !0,
                o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1,
                this.dispatchEvent(Hd))),
                l && t.hand) {
                    s = !0;
                    for (const i of t.hand.values()) {
                        const t = e.getJointPose(i, n);
                        if (void 0 === l.joints[i.jointName]) {
                            const t = new Ud;
                            t.matrixAutoUpdate = !1,
                            t.visible = !1,
                            l.joints[i.jointName] = t,
                            l.add(t)
                        }
                        const r = l.joints[i.jointName];
                        null !== t && (r.matrix.fromArray(t.transform.matrix),
                        r.matrix.decompose(r.position, r.rotation, r.scale),
                        r.jointRadius = t.radius),
                        r.visible = null !== t
                    }
                    const i = l.joints["index-finger-tip"]
                      , r = l.joints["thumb-tip"]
                      , o = i.position.distanceTo(r.position)
                      , a = .02
                      , c = .005;
                    l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1,
                    this.dispatchEvent({
                        type: "pinchend",
                        handedness: t.handedness,
                        target: this
                    })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0,
                    this.dispatchEvent({
                        type: "pinchstart",
                        handedness: t.handedness,
                        target: this
                    }))
                } else
                    null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                    null !== r && (a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    r.linearVelocity ? (a.hasLinearVelocity = !0,
                    a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
                    r.angularVelocity ? (a.hasAngularVelocity = !0,
                    a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
            return null !== o && (o.visible = null !== i),
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
        }
    }
    class Gd extends da {
        constructor(t, e) {
            super();
            const n = this
              , i = t.state;
            let r = null
              , s = 1
              , o = null
              , a = "local-floor"
              , l = null
              , c = null
              , h = null
              , u = null
              , d = null
              , p = !1
              , f = null
              , m = null
              , g = null
              , v = null
              , y = null
              , _ = null;
            const x = []
              , b = new Map
              , w = new Zc;
            w.layers.enable(1),
            w.viewport = new Na;
            const M = new Zc;
            M.layers.enable(2),
            M.viewport = new Na;
            const S = [w, M]
              , T = new Fd;
            T.layers.enable(1),
            T.layers.enable(2);
            let E = null
              , A = null;
            function R(t) {
                const e = b.get(t.inputSource);
                e && e.dispatchEvent({
                    type: t.type,
                    data: t.inputSource
                })
            }
            function L() {
                b.forEach((function(t, e) {
                    t.disconnect(e)
                }
                )),
                b.clear(),
                E = null,
                A = null,
                i.bindXRFramebuffer(null),
                t.setRenderTarget(t.getRenderTarget()),
                h && e.deleteFramebuffer(h),
                f && e.deleteFramebuffer(f),
                m && e.deleteRenderbuffer(m),
                g && e.deleteRenderbuffer(g),
                h = null,
                f = null,
                m = null,
                g = null,
                d = null,
                u = null,
                c = null,
                r = null,
                k.stop(),
                n.isPresenting = !1,
                n.dispatchEvent({
                    type: "sessionend"
                })
            }
            function C(t) {
                const e = r.inputSources;
                for (let t = 0; t < x.length; t++)
                    b.set(e[t], x[t]);
                for (let e = 0; e < t.removed.length; e++) {
                    const n = t.removed[e]
                      , i = b.get(n);
                    i && (i.dispatchEvent({
                        type: "disconnected",
                        data: n
                    }),
                    b.delete(n))
                }
                for (let e = 0; e < t.added.length; e++) {
                    const n = t.added[e]
                      , i = b.get(n);
                    i && i.dispatchEvent({
                        type: "connected",
                        data: n
                    })
                }
            }
            this.cameraAutoUpdate = !0,
            this.enabled = !1,
            this.isPresenting = !1,
            this.getController = function(t) {
                let e = x[t];
                return void 0 === e && (e = new Vd,
                x[t] = e),
                e.getTargetRaySpace()
            }
            ,
            this.getControllerGrip = function(t) {
                let e = x[t];
                return void 0 === e && (e = new Vd,
                x[t] = e),
                e.getGripSpace()
            }
            ,
            this.getHand = function(t) {
                let e = x[t];
                return void 0 === e && (e = new Vd,
                x[t] = e),
                e.getHandSpace()
            }
            ,
            this.setFramebufferScaleFactor = function(t) {
                s = t,
                !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }
            ,
            this.setReferenceSpaceType = function(t) {
                a = t,
                !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }
            ,
            this.getReferenceSpace = function() {
                return o
            }
            ,
            this.getBaseLayer = function() {
                return null !== u ? u : d
            }
            ,
            this.getBinding = function() {
                return c
            }
            ,
            this.getFrame = function() {
                return v
            }
            ,
            this.getSession = function() {
                return r
            }
            ,
            this.setSession = async function(t) {
                if (r = t,
                null !== r) {
                    r.addEventListener("select", R),
                    r.addEventListener("selectstart", R),
                    r.addEventListener("selectend", R),
                    r.addEventListener("squeeze", R),
                    r.addEventListener("squeezestart", R),
                    r.addEventListener("squeezeend", R),
                    r.addEventListener("end", L),
                    r.addEventListener("inputsourceschange", C);
                    const t = e.getContextAttributes();
                    if (!0 !== t.xrCompatible && await e.makeXRCompatible(),
                    void 0 === r.renderState.layers) {
                        const n = {
                            antialias: t.antialias,
                            alpha: t.alpha,
                            depth: t.depth,
                            stencil: t.stencil,
                            framebufferScaleFactor: s
                        };
                        d = new XRWebGLLayer(r,e,n),
                        r.updateRenderState({
                            baseLayer: d
                        })
                    } else if (e instanceof WebGLRenderingContext) {
                        const n = {
                            antialias: !0,
                            alpha: t.alpha,
                            depth: t.depth,
                            stencil: t.stencil,
                            framebufferScaleFactor: s
                        };
                        d = new XRWebGLLayer(r,e,n),
                        r.updateRenderState({
                            layers: [d]
                        })
                    } else {
                        p = t.antialias;
                        let n = null;
                        t.depth && (_ = 256,
                        t.stencil && (_ |= 1024),
                        y = t.stencil ? 33306 : 36096,
                        n = t.stencil ? 35056 : 33190);
                        const o = {
                            colorFormat: t.alpha ? 32856 : 32849,
                            depthFormat: n,
                            scaleFactor: s
                        };
                        c = new XRWebGLBinding(r,e),
                        u = c.createProjectionLayer(o),
                        h = e.createFramebuffer(),
                        r.updateRenderState({
                            layers: [u]
                        }),
                        p && (f = e.createFramebuffer(),
                        m = e.createRenderbuffer(),
                        e.bindRenderbuffer(36161, m),
                        e.renderbufferStorageMultisample(36161, 4, 32856, u.textureWidth, u.textureHeight),
                        i.bindFramebuffer(36160, f),
                        e.framebufferRenderbuffer(36160, 36064, 36161, m),
                        e.bindRenderbuffer(36161, null),
                        null !== n && (g = e.createRenderbuffer(),
                        e.bindRenderbuffer(36161, g),
                        e.renderbufferStorageMultisample(36161, 4, n, u.textureWidth, u.textureHeight),
                        e.framebufferRenderbuffer(36160, y, 36161, g),
                        e.bindRenderbuffer(36161, null)),
                        i.bindFramebuffer(36160, null))
                    }
                    o = await r.requestReferenceSpace(a),
                    k.setContext(r),
                    k.start(),
                    n.isPresenting = !0,
                    n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }
            ;
            const P = new Ua
              , D = new Ua;
            function I(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert()
            }
            this.updateCamera = function(t) {
                if (null === r)
                    return;
                T.near = M.near = w.near = t.near,
                T.far = M.far = w.far = t.far,
                E === T.near && A === T.far || (r.updateRenderState({
                    depthNear: T.near,
                    depthFar: T.far
                }),
                E = T.near,
                A = T.far);
                const e = t.parent
                  , n = T.cameras;
                I(T, e);
                for (let t = 0; t < n.length; t++)
                    I(n[t], e);
                T.matrixWorld.decompose(T.position, T.quaternion, T.scale),
                t.position.copy(T.position),
                t.quaternion.copy(T.quaternion),
                t.scale.copy(T.scale),
                t.matrix.copy(T.matrix),
                t.matrixWorld.copy(T.matrixWorld);
                const i = t.children;
                for (let t = 0, e = i.length; t < e; t++)
                    i[t].updateMatrixWorld(!0);
                2 === n.length ? function(t, e, n) {
                    P.setFromMatrixPosition(e.matrixWorld),
                    D.setFromMatrixPosition(n.matrixWorld);
                    const i = P.distanceTo(D)
                      , r = e.projectionMatrix.elements
                      , s = n.projectionMatrix.elements
                      , o = r[14] / (r[10] - 1)
                      , a = r[14] / (r[10] + 1)
                      , l = (r[9] + 1) / r[5]
                      , c = (r[9] - 1) / r[5]
                      , h = (r[8] - 1) / r[0]
                      , u = (s[8] + 1) / s[0]
                      , d = o * h
                      , p = o * u
                      , f = i / (-h + u)
                      , m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + f
                      , v = a + f
                      , y = d - m
                      , _ = p + (i - m)
                      , x = l * a / v * g
                      , b = c * a / v * g;
                    t.projectionMatrix.makePerspective(y, _, x, b, g, v)
                }(T, w, M) : T.projectionMatrix.copy(w.projectionMatrix)
            }
            ,
            this.getCamera = function() {
                return T
            }
            ,
            this.getFoveation = function() {
                return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0
            }
            ,
            this.setFoveation = function(t) {
                null !== u && (u.fixedFoveation = t),
                null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
            }
            ;
            let O = null;
            const k = new ah;
            k.setAnimationLoop((function(t, n) {
                if (l = n.getViewerPose(o),
                v = n,
                null !== l) {
                    const t = l.views;
                    null !== d && i.bindXRFramebuffer(d.framebuffer);
                    let n = !1;
                    t.length !== T.cameras.length && (T.cameras.length = 0,
                    n = !0);
                    for (let r = 0; r < t.length; r++) {
                        const s = t[r];
                        let o = null;
                        if (null !== d)
                            o = d.getViewport(s);
                        else {
                            const t = c.getViewSubImage(u, s);
                            i.bindXRFramebuffer(h),
                            void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, y, 3553, t.depthStencilTexture, 0),
                            e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0),
                            o = t.viewport
                        }
                        const a = S[r];
                        a.matrix.fromArray(s.transform.matrix),
                        a.projectionMatrix.fromArray(s.projectionMatrix),
                        a.viewport.set(o.x, o.y, o.width, o.height),
                        0 === r && T.matrix.copy(a.matrix),
                        !0 === n && T.cameras.push(a)
                    }
                    p && (i.bindXRFramebuffer(f),
                    null !== _ && e.clear(_))
                }
                const s = r.inputSources;
                for (let t = 0; t < x.length; t++) {
                    const e = x[t]
                      , i = s[t];
                    e.update(i, n, o)
                }
                if (O && O(t, n),
                p) {
                    const t = u.textureWidth
                      , n = u.textureHeight;
                    i.bindFramebuffer(36008, f),
                    i.bindFramebuffer(36009, h),
                    e.invalidateFramebuffer(36008, [y]),
                    e.invalidateFramebuffer(36009, [y]),
                    e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728),
                    e.invalidateFramebuffer(36008, [36064]),
                    i.bindFramebuffer(36008, null),
                    i.bindFramebuffer(36009, null),
                    i.bindFramebuffer(36160, f)
                }
                v = null
            }
            )),
            this.setAnimationLoop = function(t) {
                O = t
            }
            ,
            this.dispose = function() {}
        }
    }
    function Wd(t) {
        function e(e, n) {
            e.opacity.value = n.opacity,
            n.color && e.diffuse.value.copy(n.color),
            n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
            n.map && (e.map.value = n.map),
            n.alphaMap && (e.alphaMap.value = n.alphaMap),
            n.specularMap && (e.specularMap.value = n.specularMap),
            n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
            const i = t.get(n).envMap;
            if (i) {
                e.envMap.value = i,
                e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1,
                e.reflectivity.value = n.reflectivity,
                e.ior.value = n.ior,
                e.refractionRatio.value = n.refractionRatio;
                const r = t.get(i).__maxMipLevel;
                void 0 !== r && (e.maxMipLevel.value = r)
            }
            let r, s;
            n.lightMap && (e.lightMap.value = n.lightMap,
            e.lightMapIntensity.value = n.lightMapIntensity),
            n.aoMap && (e.aoMap.value = n.aoMap,
            e.aoMapIntensity.value = n.aoMapIntensity),
            n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),
            void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            e.uvTransform.value.copy(r.matrix)),
            n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap),
            void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
            !0 === s.matrixAutoUpdate && s.updateMatrix(),
            e.uv2Transform.value.copy(s.matrix))
        }
        function n(e, n) {
            e.roughness.value = n.roughness,
            e.metalness.value = n.metalness,
            n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
            n.bumpMap && (e.bumpMap.value = n.bumpMap,
            e.bumpScale.value = n.bumpScale,
            1 === n.side && (e.bumpScale.value *= -1)),
            n.normalMap && (e.normalMap.value = n.normalMap,
            e.normalScale.value.copy(n.normalScale),
            1 === n.side && e.normalScale.value.negate()),
            n.displacementMap && (e.displacementMap.value = n.displacementMap,
            e.displacementScale.value = n.displacementScale,
            e.displacementBias.value = n.displacementBias),
            t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(t, e) {
                t.fogColor.value.copy(e.color),
                e.isFog ? (t.fogNear.value = e.near,
                t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            },
            refreshMaterialUniforms: function(t, i, r, s, o) {
                i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i),
                function(t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }(t, i)) : i.isMeshToonMaterial ? (e(t, i),
                function(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshPhongMaterial ? (e(t, i),
                function(t, e) {
                    t.specular.value.copy(e.specular),
                    t.shininess.value = Math.max(e.shininess, 1e-4),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshStandardMaterial ? (e(t, i),
                i.isMeshPhysicalMaterial ? function(t, e, i) {
                    n(t, e),
                    t.ior.value = e.ior,
                    e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                    t.sheenRoughness.value = e.sheenRoughness,
                    e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap),
                    e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)),
                    e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat,
                    t.clearcoatRoughness.value = e.clearcoatRoughness,
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                    e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                    e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                    1 === e.side && t.clearcoatNormalScale.value.negate())),
                    e.transmission > 0 && (t.transmission.value = e.transmission,
                    t.transmissionSamplerMap.value = i.texture,
                    t.transmissionSamplerSize.value.set(i.width, i.height),
                    e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                    t.thickness.value = e.thickness,
                    e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                    t.attenuationDistance.value = e.attenuationDistance,
                    t.attenuationColor.value.copy(e.attenuationColor)),
                    t.specularIntensity.value = e.specularIntensity,
                    t.specularColor.value.copy(e.specularColor),
                    e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap),
                    e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                }(t, i, o) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i),
                function(t, e) {
                    e.matcap && (t.matcap.value = e.matcap),
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshDepthMaterial ? (e(t, i),
                function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i),
                function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias),
                    t.referencePosition.value.copy(e.referencePosition),
                    t.nearDistance.value = e.nearDistance,
                    t.farDistance.value = e.farDistance
                }(t, i)) : i.isMeshNormalMaterial ? (e(t, i),
                function(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1)),
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate()),
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity
                }(t, i),
                i.isLineDashedMaterial && function(t, e) {
                    t.dashSize.value = e.dashSize,
                    t.totalSize.value = e.dashSize + e.gapSize,
                    t.scale.value = e.scale
                }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                    let r;
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.size.value = e.size * n,
                    t.scale.value = .5 * i,
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                    e.map ? r = e.map : e.alphaMap && (r = e.alphaMap),
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                    t.uvTransform.value.copy(r.matrix))
                }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                    let n;
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.rotation.value = e.rotation,
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap),
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    t.uvTransform.value.copy(n.matrix))
                }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color),
                t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
        }
    }
    function jd(t={}) {
        const e = void 0 !== t.canvas ? t.canvas : function() {
            const t = La("canvas");
            return t.style.display = "block",
            t
        }()
          , n = void 0 !== t.context ? t.context : null
          , i = void 0 !== t.alpha && t.alpha
          , r = void 0 === t.depth || t.depth
          , s = void 0 === t.stencil || t.stencil
          , o = void 0 !== t.antialias && t.antialias
          , a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , c = void 0 !== t.powerPreference ? t.powerPreference : "default"
          , h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
        let u = null
          , d = null;
        const p = []
          , f = [];
        this.domElement = e,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.outputEncoding = ra,
        this.physicallyCorrectLights = !1,
        this.toneMapping = 0,
        this.toneMappingExposure = 1;
        const m = this;
        let g = !1
          , v = 0
          , y = 0
          , _ = null
          , x = -1
          , b = null;
        const w = new Na
          , M = new Na;
        let S = null
          , T = e.width
          , E = e.height
          , A = 1
          , R = null
          , L = null;
        const C = new Na(0,0,T,E)
          , P = new Na(0,0,T,E);
        let D = !1;
        const I = []
          , O = new oh;
        let k = !1
          , N = !1
          , z = null;
        const B = new vl
          , F = new Ua
          , U = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function H() {
            return null === _ ? A : 1
        }
        let V, G, W, j, X, q, Y, Z, J, K, Q, $, tt, et, nt, it, rt, st, ot, at, lt, ct, ht, ut = n;
        function dt(t, n) {
            for (let i = 0; i < t.length; i++) {
                const r = t[i]
                  , s = e.getContext(r, n);
                if (null !== s)
                    return s
            }
            return null
        }
        try {
            const t = {
                alpha: i,
                depth: r,
                stencil: s,
                antialias: o,
                premultipliedAlpha: a,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: h
            };
            if (e.addEventListener("webglcontextlost", mt, !1),
            e.addEventListener("webglcontextrestored", gt, !1),
            null === ut) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === m.isWebGL1Renderer && e.shift(),
                ut = dt(e, t),
                null === ut)
                    throw dt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === ut.getShaderPrecisionFormat && (ut.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message),
            t
        }
        function pt() {
            V = new Vh(ut),
            G = new gh(ut,V,t),
            V.init(G),
            ct = new Bd(ut,V,G),
            W = new Nd(ut,V,G),
            I[0] = 1029,
            j = new jh(ut),
            X = new wd,
            q = new zd(ut,V,W,X,G,ct,j),
            Y = new yh(m),
            Z = new Hh(m),
            J = new lh(ut,G),
            ht = new fh(ut,V,J,G),
            K = new Gh(ut,J,j,ht),
            Q = new Kh(ut,K,J,j),
            ot = new Jh(ut,G,q),
            it = new vh(X),
            $ = new bd(m,Y,Z,V,G,ht,it),
            tt = new Wd(X),
            et = new Ed(X),
            nt = new Dd(V,G),
            st = new ph(m,Y,W,Q,a),
            rt = new kd(m,Q,G),
            at = new mh(ut,V,j,G),
            lt = new Wh(ut,V,j,G),
            j.programs = $.programs,
            m.capabilities = G,
            m.extensions = V,
            m.properties = X,
            m.renderLists = et,
            m.shadowMap = rt,
            m.state = W,
            m.info = j
        }
        pt();
        const ft = new Gd(m,ut);
        function mt(t) {
            t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            g = !0
        }
        function gt() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            g = !1;
            const t = j.autoReset
              , e = rt.enabled
              , n = rt.autoUpdate
              , i = rt.needsUpdate
              , r = rt.type;
            pt(),
            j.autoReset = t,
            rt.enabled = e,
            rt.autoUpdate = n,
            rt.needsUpdate = i,
            rt.type = r
        }
        function vt(t) {
            const e = t.target;
            e.removeEventListener("dispose", vt),
            function(t) {
                (function(t) {
                    const e = X.get(t).programs;
                    void 0 !== e && e.forEach((function(t) {
                        $.releaseProgram(t)
                    }
                    ))
                }
                )(t),
                X.remove(t)
            }(e)
        }
        this.xr = ft,
        this.getContext = function() {
            return ut
        }
        ,
        this.getContextAttributes = function() {
            return ut.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const t = V.get("WEBGL_lose_context");
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const t = V.get("WEBGL_lose_context");
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return A
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (A = t,
            this.setSize(T, E, !1))
        }
        ,
        this.getSize = function(t) {
            return t.set(T, E)
        }
        ,
        this.setSize = function(t, n, i) {
            ft.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t,
            E = n,
            e.width = Math.floor(t * A),
            e.height = Math.floor(n * A),
            !1 !== i && (e.style.width = t + "px",
            e.style.height = n + "px"),
            this.setViewport(0, 0, t, n))
        }
        ,
        this.getDrawingBufferSize = function(t) {
            return t.set(T * A, E * A).floor()
        }
        ,
        this.setDrawingBufferSize = function(t, n, i) {
            T = t,
            E = n,
            A = i,
            e.width = Math.floor(t * i),
            e.height = Math.floor(n * i),
            this.setViewport(0, 0, t, n)
        }
        ,
        this.getCurrentViewport = function(t) {
            return t.copy(w)
        }
        ,
        this.getViewport = function(t) {
            return t.copy(C)
        }
        ,
        this.setViewport = function(t, e, n, i) {
            t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i),
            W.viewport(w.copy(C).multiplyScalar(A).floor())
        }
        ,
        this.getScissor = function(t) {
            return t.copy(P)
        }
        ,
        this.setScissor = function(t, e, n, i) {
            t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
            W.scissor(M.copy(P).multiplyScalar(A).floor())
        }
        ,
        this.getScissorTest = function() {
            return D
        }
        ,
        this.setScissorTest = function(t) {
            W.setScissorTest(D = t)
        }
        ,
        this.setOpaqueSort = function(t) {
            R = t
        }
        ,
        this.setTransparentSort = function(t) {
            L = t
        }
        ,
        this.getClearColor = function(t) {
            return t.copy(st.getClearColor())
        }
        ,
        this.setClearColor = function() {
            st.setClearColor.apply(st, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return st.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            st.setClearAlpha.apply(st, arguments)
        }
        ,
        this.clear = function(t, e, n) {
            let i = 0;
            (void 0 === t || t) && (i |= 16384),
            (void 0 === e || e) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            ut.clear(i)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            e.removeEventListener("webglcontextlost", mt, !1),
            e.removeEventListener("webglcontextrestored", gt, !1),
            et.dispose(),
            nt.dispose(),
            X.dispose(),
            Y.dispose(),
            Z.dispose(),
            Q.dispose(),
            ht.dispose(),
            ft.dispose(),
            ft.removeEventListener("sessionstart", _t),
            ft.removeEventListener("sessionend", xt),
            z && (z.dispose(),
            z = null),
            bt.stop()
        }
        ,
        this.renderBufferDirect = function(t, e, n, i, r, s) {
            null === e && (e = U);
            const o = r.isMesh && r.matrixWorld.determinant() < 0
              , a = function(t, e, n, i, r) {
                !0 !== e.isScene && (e = U),
                q.resetTextureUnits();
                const s = e.fog
                  , o = i.isMeshStandardMaterial ? e.environment : null
                  , a = null === _ ? m.outputEncoding : _.texture.encoding
                  , l = (i.isMeshStandardMaterial ? Z : Y).get(i.envMap || o)
                  , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                  , h = !!i.normalMap && !!n.attributes.tangent
                  , u = !!n.morphAttributes.position
                  , p = !!n.morphAttributes.normal
                  , f = n.morphAttributes.position ? n.morphAttributes.position.length : 0
                  , g = X.get(i)
                  , v = d.state.lights;
                if (!0 === k && (!0 === N || t !== b)) {
                    const e = t === b && i.id === x;
                    it.setState(i, t, e)
                }
                let y = !1;
                i.version === g.__version ? g.needsLights && g.lightsStateVersion !== v.state.version || g.outputEncoding !== a || r.isInstancedMesh && !1 === g.instancing ? y = !0 : r.isInstancedMesh || !0 !== g.instancing ? r.isSkinnedMesh && !1 === g.skinning ? y = !0 : r.isSkinnedMesh || !0 !== g.skinning ? g.envMap !== l || i.fog && g.fog !== s ? y = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === it.numPlanes && g.numIntersection === it.numIntersection ? (g.vertexAlphas !== c || g.vertexTangents !== h || g.morphTargets !== u || g.morphNormals !== p || !0 === G.isWebGL2 && g.morphTargetsCount !== f) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0,
                g.__version = i.version);
                let w = g.currentProgram;
                !0 === y && (w = Et(i, e, r));
                let M = !1
                  , S = !1
                  , T = !1;
                const R = w.getUniforms()
                  , L = g.uniforms;
                if (W.useProgram(w.program) && (M = !0,
                S = !0,
                T = !0),
                i.id !== x && (x = i.id,
                S = !0),
                M || b !== t) {
                    if (R.setValue(ut, "projectionMatrix", t.projectionMatrix),
                    G.logarithmicDepthBuffer && R.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                    b !== t && (b = t,
                    S = !0,
                    T = !0),
                    i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                        const e = R.map.cameraPosition;
                        void 0 !== e && e.setValue(ut, F.setFromMatrixPosition(t.matrixWorld))
                    }
                    (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && R.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera),
                    (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && R.setValue(ut, "viewMatrix", t.matrixWorldInverse)
                }
                if (r.isSkinnedMesh) {
                    R.setOptional(ut, r, "bindMatrix"),
                    R.setOptional(ut, r, "bindMatrixInverse");
                    const t = r.skeleton;
                    t && (G.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(),
                    R.setValue(ut, "boneTexture", t.boneTexture, q),
                    R.setValue(ut, "boneTextureSize", t.boneTextureSize)) : R.setOptional(ut, t, "boneMatrices"))
                }
                var C, P;
                return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || ot.update(r, n, i, w),
                (S || g.receiveShadow !== r.receiveShadow) && (g.receiveShadow = r.receiveShadow,
                R.setValue(ut, "receiveShadow", r.receiveShadow)),
                S && (R.setValue(ut, "toneMappingExposure", m.toneMappingExposure),
                g.needsLights && (P = T,
                (C = L).ambientLightColor.needsUpdate = P,
                C.lightProbe.needsUpdate = P,
                C.directionalLights.needsUpdate = P,
                C.directionalLightShadows.needsUpdate = P,
                C.pointLights.needsUpdate = P,
                C.pointLightShadows.needsUpdate = P,
                C.spotLights.needsUpdate = P,
                C.spotLightShadows.needsUpdate = P,
                C.rectAreaLights.needsUpdate = P,
                C.hemisphereLights.needsUpdate = P),
                s && i.fog && tt.refreshFogUniforms(L, s),
                tt.refreshMaterialUniforms(L, i, A, E, z),
                td.upload(ut, g.uniformsList, L, q)),
                i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (td.upload(ut, g.uniformsList, L, q),
                i.uniformsNeedUpdate = !1),
                i.isSpriteMaterial && R.setValue(ut, "center", r.center),
                R.setValue(ut, "modelViewMatrix", r.modelViewMatrix),
                R.setValue(ut, "normalMatrix", r.normalMatrix),
                R.setValue(ut, "modelMatrix", r.matrixWorld),
                w
            }(t, e, n, i, r);
            W.setMaterial(i, o);
            let l = n.index;
            const c = n.attributes.position;
            if (null === l) {
                if (void 0 === c || 0 === c.count)
                    return
            } else if (0 === l.count)
                return;
            let h, u = 1;
            !0 === i.wireframe && (l = K.getWireframeAttribute(n),
            u = 2),
            ht.setup(r, i, a, n, l);
            let p = at;
            null !== l && (h = J.get(l),
            p = lt,
            p.setIndex(h));
            const f = null !== l ? l.count : c.count
              , g = n.drawRange.start * u
              , v = n.drawRange.count * u
              , y = null !== s ? s.start * u : 0
              , w = null !== s ? s.count * u : 1 / 0
              , M = Math.max(g, y)
              , S = Math.min(f, g + v, y + w) - 1
              , T = Math.max(0, S - M + 1);
            if (0 !== T) {
                if (r.isMesh)
                    !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * H()),
                    p.setMode(1)) : p.setMode(4);
                else if (r.isLine) {
                    let t = i.linewidth;
                    void 0 === t && (t = 1),
                    W.setLineWidth(t * H()),
                    r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                } else
                    r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                if (r.isInstancedMesh)
                    p.renderInstances(M, T, r.count);
                else if (n.isInstancedBufferGeometry) {
                    const t = Math.min(n.instanceCount, n._maxInstanceCount);
                    p.renderInstances(M, T, t)
                } else
                    p.render(M, T)
            }
        }
        ,
        this.compile = function(t, e) {
            d = nt.get(t),
            d.init(),
            f.push(d),
            t.traverseVisible((function(t) {
                t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                t.castShadow && d.pushShadow(t))
            }
            )),
            d.setupLights(m.physicallyCorrectLights),
            t.traverse((function(e) {
                const n = e.material;
                if (n)
                    if (Array.isArray(n))
                        for (let i = 0; i < n.length; i++)
                            Et(n[i], t, e);
                    else
                        Et(n, t, e)
            }
            )),
            f.pop(),
            d = null
        }
        ;
        let yt = null;
        function _t() {
            bt.stop()
        }
        function xt() {
            bt.start()
        }
        const bt = new ah;
        function wt(t, e, n, i) {
            if (!1 === t.visible)
                return;
            if (t.layers.test(e.layers))
                if (t.isGroup)
                    n = t.renderOrder;
                else if (t.isLOD)
                    !0 === t.autoUpdate && t.update(e);
                else if (t.isLight)
                    d.pushLight(t),
                    t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || O.intersectsSprite(t)) {
                        i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                        const e = Q.update(t)
                          , r = t.material;
                        r.visible && u.push(t, e, r, n, F.z, null)
                    }
                } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(),
                t.skeleton.frame = j.render.frame),
                !t.frustumCulled || O.intersectsObject(t))) {
                    i && F.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B);
                    const e = Q.update(t)
                      , r = t.material;
                    if (Array.isArray(r)) {
                        const i = e.groups;
                        for (let s = 0, o = i.length; s < o; s++) {
                            const o = i[s]
                              , a = r[o.materialIndex];
                            a && a.visible && u.push(t, e, a, n, F.z, o)
                        }
                    } else
                        r.visible && u.push(t, e, r, n, F.z, null)
                }
            const r = t.children;
            for (let t = 0, s = r.length; t < s; t++)
                wt(r[t], e, n, i)
        }
        function Mt(t, e, n, i) {
            const r = t.opaque
              , s = t.transmissive
              , a = t.transparent;
            d.setupLightsView(n),
            s.length > 0 && function(t, e, n) {
                if (null === z) {
                    const t = !0 === o && !0 === G.isWebGL2;
                    z = new (t ? Ba : za)(1024,1024,{
                        generateMipmaps: !0,
                        type: null !== ct.convert(Xo) ? Xo : Vo,
                        minFilter: Ho,
                        magFilter: zo,
                        wrapS: ko,
                        wrapT: ko
                    })
                }
                const i = m.getRenderTarget();
                m.setRenderTarget(z),
                m.clear();
                const r = m.toneMapping;
                m.toneMapping = 0,
                St(t, e, n),
                m.toneMapping = r,
                q.updateMultisampleRenderTarget(z),
                q.updateRenderTargetMipmap(z),
                m.setRenderTarget(i)
            }(r, e, n),
            i && W.viewport(w.copy(i)),
            r.length > 0 && St(r, e, n),
            s.length > 0 && St(s, e, n),
            a.length > 0 && St(a, e, n)
        }
        function St(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r]
                  , o = s.object
                  , a = s.geometry
                  , l = null === i ? s.material : i
                  , c = s.group;
                o.layers.test(n.layers) && Tt(o, e, n, a, l, c)
            }
        }
        function Tt(t, e, n, i, r, s) {
            t.onBeforeRender(m, e, n, i, r, s),
            t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            r.onBeforeRender(m, e, n, i, t, s),
            !0 === r.transparent && 2 === r.side ? (r.side = 1,
            r.needsUpdate = !0,
            m.renderBufferDirect(n, e, i, r, t, s),
            r.side = 0,
            r.needsUpdate = !0,
            m.renderBufferDirect(n, e, i, r, t, s),
            r.side = 2) : m.renderBufferDirect(n, e, i, r, t, s),
            t.onAfterRender(m, e, n, i, r, s)
        }
        function Et(t, e, n) {
            !0 !== e.isScene && (e = U);
            const i = X.get(t)
              , r = d.state.lights
              , s = d.state.shadowsArray
              , o = r.state.version
              , a = $.getParameters(t, r.state, s, e, n)
              , l = $.getProgramCacheKey(a);
            let c = i.programs;
            i.environment = t.isMeshStandardMaterial ? e.environment : null,
            i.fog = e.fog,
            i.envMap = (t.isMeshStandardMaterial ? Z : Y).get(t.envMap || i.environment),
            void 0 === c && (t.addEventListener("dispose", vt),
            c = new Map,
            i.programs = c);
            let h = c.get(l);
            if (void 0 !== h) {
                if (i.currentProgram === h && i.lightsStateVersion === o)
                    return At(t, a),
                    h
            } else
                a.uniforms = $.getUniforms(t),
                t.onBuild(n, a, m),
                t.onBeforeCompile(a, m),
                h = $.acquireProgram(a, l),
                c.set(l, h),
                i.uniforms = a.uniforms;
            const u = i.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = it.uniform),
            At(t, a),
            i.needsLights = function(t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t),
            i.lightsStateVersion = o,
            i.needsLights && (u.ambientLightColor.value = r.state.ambient,
            u.lightProbe.value = r.state.probe,
            u.directionalLights.value = r.state.directional,
            u.directionalLightShadows.value = r.state.directionalShadow,
            u.spotLights.value = r.state.spot,
            u.spotLightShadows.value = r.state.spotShadow,
            u.rectAreaLights.value = r.state.rectArea,
            u.ltc_1.value = r.state.rectAreaLTC1,
            u.ltc_2.value = r.state.rectAreaLTC2,
            u.pointLights.value = r.state.point,
            u.pointLightShadows.value = r.state.pointShadow,
            u.hemisphereLights.value = r.state.hemi,
            u.directionalShadowMap.value = r.state.directionalShadowMap,
            u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            u.spotShadowMap.value = r.state.spotShadowMap,
            u.spotShadowMatrix.value = r.state.spotShadowMatrix,
            u.pointShadowMap.value = r.state.pointShadowMap,
            u.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const p = h.getUniforms()
              , f = td.seqWithValue(p.seq, u);
            return i.currentProgram = h,
            i.uniformsList = f,
            h
        }
        function At(t, e) {
            const n = X.get(t);
            n.outputEncoding = e.outputEncoding,
            n.instancing = e.instancing,
            n.skinning = e.skinning,
            n.morphTargets = e.morphTargets,
            n.morphNormals = e.morphNormals,
            n.morphTargetsCount = e.morphTargetsCount,
            n.numClippingPlanes = e.numClippingPlanes,
            n.numIntersection = e.numClipIntersection,
            n.vertexAlphas = e.vertexAlphas,
            n.vertexTangents = e.vertexTangents
        }
        bt.setAnimationLoop((function(t) {
            yt && yt(t)
        }
        )),
        "undefined" != typeof window && bt.setContext(window),
        this.setAnimationLoop = function(t) {
            yt = t,
            ft.setAnimationLoop(t),
            null === t ? bt.stop() : bt.start()
        }
        ,
        ft.addEventListener("sessionstart", _t),
        ft.addEventListener("sessionend", xt),
        this.render = function(t, e) {
            if (void 0 !== e && !0 !== e.isCamera)
                return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === g)
                return;
            !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            !0 === ft.enabled && !0 === ft.isPresenting && (!0 === ft.cameraAutoUpdate && ft.updateCamera(e),
            e = ft.getCamera()),
            !0 === t.isScene && t.onBeforeRender(m, t, e, _),
            d = nt.get(t, f.length),
            d.init(),
            f.push(d),
            B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            O.setFromProjectionMatrix(B),
            N = this.localClippingEnabled,
            k = it.init(this.clippingPlanes, N, e),
            u = et.get(t, p.length),
            u.init(),
            p.push(u),
            wt(t, e, 0, m.sortObjects),
            u.finish(),
            !0 === m.sortObjects && u.sort(R, L),
            !0 === k && it.beginShadows();
            const n = d.state.shadowsArray;
            if (rt.render(n, t, e),
            !0 === k && it.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            st.render(u, t),
            d.setupLights(m.physicallyCorrectLights),
            e.isArrayCamera) {
                const n = e.cameras;
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    Mt(u, t, i, i.viewport)
                }
            } else
                Mt(u, t, e);
            null !== _ && (q.updateMultisampleRenderTarget(_),
            q.updateRenderTargetMipmap(_)),
            !0 === t.isScene && t.onAfterRender(m, t, e),
            W.buffers.depth.setTest(!0),
            W.buffers.depth.setMask(!0),
            W.buffers.color.setMask(!0),
            W.setPolygonOffset(!1),
            ht.resetDefaultState(),
            x = -1,
            b = null,
            f.pop(),
            d = f.length > 0 ? f[f.length - 1] : null,
            p.pop(),
            u = p.length > 0 ? p[p.length - 1] : null
        }
        ,
        this.getActiveCubeFace = function() {
            return v
        }
        ,
        this.getActiveMipmapLevel = function() {
            return y
        }
        ,
        this.getRenderTarget = function() {
            return _
        }
        ,
        this.setRenderTarget = function(t, e=0, n=0) {
            _ = t,
            v = e,
            y = n,
            t && void 0 === X.get(t).__webglFramebuffer && q.setupRenderTarget(t);
            let i = null
              , r = !1
              , s = !1;
            if (t) {
                const n = t.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                const o = X.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (i = o[e],
                r = !0) : i = t.isWebGLMultisampleRenderTarget ? X.get(t).__webglMultisampledFramebuffer : o,
                w.copy(t.viewport),
                M.copy(t.scissor),
                S = t.scissorTest
            } else
                w.copy(C).multiplyScalar(A).floor(),
                M.copy(P).multiplyScalar(A).floor(),
                S = D;
            if (W.bindFramebuffer(36160, i) && G.drawBuffers) {
                let e = !1;
                if (t)
                    if (t.isWebGLMultipleRenderTargets) {
                        const n = t.texture;
                        if (I.length !== n.length || 36064 !== I[0]) {
                            for (let t = 0, e = n.length; t < e; t++)
                                I[t] = 36064 + t;
                            I.length = n.length,
                            e = !0
                        }
                    } else
                        1 === I.length && 36064 === I[0] || (I[0] = 36064,
                        I.length = 1,
                        e = !0);
                else
                    1 === I.length && 1029 === I[0] || (I[0] = 1029,
                    I.length = 1,
                    e = !0);
                e && (G.isWebGL2 ? ut.drawBuffers(I) : V.get("WEBGL_draw_buffers").drawBuffersWEBGL(I))
            }
            if (W.viewport(w),
            W.scissor(M),
            W.setScissorTest(S),
            r) {
                const i = X.get(t.texture);
                ut.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
            } else if (s) {
                const i = X.get(t.texture)
                  , r = e || 0;
                ut.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
            }
            x = -1
        }
        ,
        this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
            if (!t || !t.isWebGLRenderTarget)
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let a = X.get(t).__webglFramebuffer;
            if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]),
            a) {
                W.bindFramebuffer(36160, a);
                try {
                    const o = t.texture
                      , a = o.format
                      , l = o.type;
                    if (a !== Zo && ct.convert(a) !== ut.getParameter(35739))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    const c = l === Xo && (V.has("EXT_color_buffer_half_float") || G.isWebGL2 && V.has("EXT_color_buffer_float"));
                    if (!(l === Vo || ct.convert(l) === ut.getParameter(35738) || l === jo && (G.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float")) || c))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    36053 === ut.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ut.readPixels(e, n, i, r, ct.convert(a), ct.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    const t = null !== _ ? X.get(_).__webglFramebuffer : null;
                    W.bindFramebuffer(36160, t)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(t, e, n=0) {
            const i = Math.pow(2, -n)
              , r = Math.floor(e.image.width * i)
              , s = Math.floor(e.image.height * i);
            let o = ct.convert(e.format);
            G.isWebGL2 && (6407 === o && (o = 32849),
            6408 === o && (o = 32856)),
            q.setTexture2D(e, 0),
            ut.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0),
            W.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(t, e, n, i=0) {
            const r = e.image.width
              , s = e.image.height
              , o = ct.convert(n.format)
              , a = ct.convert(n.type);
            q.setTexture2D(n, 0),
            ut.pixelStorei(37440, n.flipY),
            ut.pixelStorei(37441, n.premultiplyAlpha),
            ut.pixelStorei(3317, n.unpackAlignment),
            e.isDataTexture ? ut.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ut.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
            0 === i && n.generateMipmaps && ut.generateMipmap(3553),
            W.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(t, e, n, i, r=0) {
            if (m.isWebGL1Renderer)
                return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            const s = t.max.x - t.min.x + 1
              , o = t.max.y - t.min.y + 1
              , a = t.max.z - t.min.z + 1
              , l = ct.convert(i.format)
              , c = ct.convert(i.type);
            let h;
            if (i.isDataTexture3D)
                q.setTexture3D(i, 0),
                h = 32879;
            else {
                if (!i.isDataTexture2DArray)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                q.setTexture2DArray(i, 0),
                h = 35866
            }
            ut.pixelStorei(37440, i.flipY),
            ut.pixelStorei(37441, i.premultiplyAlpha),
            ut.pixelStorei(3317, i.unpackAlignment);
            const u = ut.getParameter(3314)
              , d = ut.getParameter(32878)
              , p = ut.getParameter(3316)
              , f = ut.getParameter(3315)
              , g = ut.getParameter(32877)
              , v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            ut.pixelStorei(3314, v.width),
            ut.pixelStorei(32878, v.height),
            ut.pixelStorei(3316, t.min.x),
            ut.pixelStorei(3315, t.min.y),
            ut.pixelStorei(32877, t.min.z),
            n.isDataTexture || n.isDataTexture3D ? ut.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            ut.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, v.data)) : ut.texSubImage3D(h, r, e.x, e.y, e.z, s, o, a, l, c, v),
            ut.pixelStorei(3314, u),
            ut.pixelStorei(32878, d),
            ut.pixelStorei(3316, p),
            ut.pixelStorei(3315, f),
            ut.pixelStorei(32877, g),
            0 === r && i.generateMipmaps && ut.generateMipmap(h),
            W.unbindTexture()
        }
        ,
        this.initTexture = function(t) {
            q.setTexture2D(t, 0),
            W.unbindTexture()
        }
        ,
        this.resetState = function() {
            v = 0,
            y = 0,
            _ = null,
            W.reset(),
            ht.reset()
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    jd.prototype.isWebGLRenderer = !0,
    class extends jd {
    }
    .prototype.isWebGL1Renderer = !0;
    class Xd {
        constructor(t, e=25e-5) {
            this.name = "",
            this.color = new lc(t),
            this.density = e
        }
        clone() {
            return new Xd(this.color,this.density)
        }
        toJSON() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }
    Xd.prototype.isFogExp2 = !0;
    class qd {
        constructor(t, e=1, n=1e3) {
            this.name = "",
            this.color = new lc(t),
            this.near = e,
            this.far = n
        }
        clone() {
            return new qd(this.color,this.near,this.far)
        }
        toJSON() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }
    qd.prototype.isFog = !0;
    class Yd extends Vl {
        constructor() {
            super(),
            this.type = "Scene",
            this.background = null,
            this.environment = null,
            this.fog = null,
            this.overrideMaterial = null,
            this.autoUpdate = !0,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        copy(t, e) {
            return super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment && (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        }
    }
    Yd.prototype.isScene = !0;
    class Zd {
        constructor(t, e) {
            this.array = t,
            this.stride = e,
            this.count = void 0 !== t ? t.length / e : 0,
            this.usage = ca,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.version = 0,
            this.uuid = ya()
        }
        onUploadCallback() {}
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        setUsage(t) {
            return this.usage = t,
            this
        }
        copy(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.usage = t.usage,
            this
        }
        copyAt(t, e, n) {
            t *= this.stride,
            n *= e.stride;
            for (let i = 0, r = this.stride; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        }
        set(t, e=0) {
            return this.array.set(t, e),
            this
        }
        clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ya()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
              , n = new this.constructor(e,this.stride);
            return n.setUsage(this.usage),
            n
        }
        onUpload(t) {
            return this.onUploadCallback = t,
            this
        }
        toJSON(t) {
            return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ya()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    Zd.prototype.isInterleavedBuffer = !0;
    const Jd = new Ua;
    class Kd {
        constructor(t, e, n, i=!1) {
            this.name = "",
            this.data = t,
            this.itemSize = e,
            this.offset = n,
            this.normalized = !0 === i
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(t) {
            this.data.needsUpdate = t
        }
        applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
                Jd.x = this.getX(e),
                Jd.y = this.getY(e),
                Jd.z = this.getZ(e),
                Jd.applyMatrix4(t),
                this.setXYZ(e, Jd.x, Jd.y, Jd.z);
            return this
        }
        applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
                Jd.x = this.getX(e),
                Jd.y = this.getY(e),
                Jd.z = this.getZ(e),
                Jd.applyNormalMatrix(t),
                this.setXYZ(e, Jd.x, Jd.y, Jd.z);
            return this
        }
        transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
                Jd.x = this.getX(e),
                Jd.y = this.getY(e),
                Jd.z = this.getZ(e),
                Jd.transformDirection(t),
                this.setXYZ(e, Jd.x, Jd.y, Jd.z);
            return this
        }
        setX(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        }
        setY(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        }
        setZ(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        }
        setW(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        }
        getX(t) {
            return this.data.array[t * this.data.stride + this.offset]
        }
        getY(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        }
        getZ(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        }
        getW(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        }
        setXY(t, e, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this
        }
        setXYZ(t, e, n, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this
        }
        setXYZW(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this.data.array[t + 3] = r,
            this
        }
        clone(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++)
                        t.push(this.data.array[n + e])
                }
                return new dc(new this.array.constructor(t),this.itemSize,this.normalized)
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new Kd(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
        }
        toJSON(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++)
                        t.push(this.data.array[n + e])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    Kd.prototype.isInterleavedBufferAttribute = !0;
    class Qd extends ec {
        constructor(t) {
            super(),
            this.type = "SpriteMaterial",
            this.color = new lc(16777215),
            this.map = null,
            this.alphaMap = null,
            this.rotation = 0,
            this.sizeAttenuation = !0,
            this.transparent = !0,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.rotation = t.rotation,
            this.sizeAttenuation = t.sizeAttenuation,
            this
        }
    }
    let $d;
    Qd.prototype.isSpriteMaterial = !0;
    const tp = new Ua
      , ep = new Ua
      , np = new Ua
      , ip = new Ea
      , rp = new Ea
      , sp = new vl
      , op = new Ua
      , ap = new Ua
      , lp = new Ua
      , cp = new Ea
      , hp = new Ea
      , up = new Ea;
    function dp(t, e, n, i, r, s) {
        ip.subVectors(t, n).addScalar(.5).multiply(i),
        void 0 !== r ? (rp.x = s * ip.x - r * ip.y,
        rp.y = r * ip.x + s * ip.y) : rp.copy(ip),
        t.copy(e),
        t.x += rp.x,
        t.y += rp.y,
        t.applyMatrix4(sp)
    }
    (class extends Vl {
        constructor(t) {
            if (super(),
            this.type = "Sprite",
            void 0 === $d) {
                $d = new Mc;
                const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                  , e = new Zd(t,5);
                $d.setIndex([0, 1, 2, 0, 2, 3]),
                $d.setAttribute("position", new Kd(e,3,0,!1)),
                $d.setAttribute("uv", new Kd(e,2,3,!1))
            }
            this.geometry = $d,
            this.material = void 0 !== t ? t : new Qd,
            this.center = new Ea(.5,.5)
        }
        raycast(t, e) {
            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
            ep.setFromMatrixScale(this.matrixWorld),
            sp.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
            np.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ep.multiplyScalar(-np.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && (r = Math.cos(n),
            i = Math.sin(n));
            const s = this.center;
            dp(op.set(-.5, -.5, 0), np, s, ep, i, r),
            dp(ap.set(.5, -.5, 0), np, s, ep, i, r),
            dp(lp.set(.5, .5, 0), np, s, ep, i, r),
            cp.set(0, 0),
            hp.set(1, 0),
            up.set(1, 1);
            let o = t.ray.intersectTriangle(op, ap, lp, !1, tp);
            if (null === o && (dp(ap.set(-.5, .5, 0), np, s, ep, i, r),
            hp.set(0, 1),
            o = t.ray.intersectTriangle(op, lp, ap, !1, tp),
            null === o))
                return;
            const a = t.ray.origin.distanceTo(tp);
            a < t.near || a > t.far || e.push({
                distance: a,
                point: tp.clone(),
                uv: $l.getUV(tp, op, ap, lp, cp, hp, up, new Ea),
                face: null,
                object: this
            })
        }
        copy(t) {
            return super.copy(t),
            void 0 !== t.center && this.center.copy(t.center),
            this.material = t.material,
            this
        }
    }
    ).prototype.isSprite = !0;
    const pp = new Ua
      , fp = new Na
      , mp = new Na
      , gp = new Ua
      , vp = new vl;
    class yp extends Hc {
        constructor(t, e) {
            super(t, e),
            this.type = "SkinnedMesh",
            this.bindMode = "attached",
            this.bindMatrix = new vl,
            this.bindMatrixInverse = new vl
        }
        copy(t) {
            return super.copy(t),
            this.bindMode = t.bindMode,
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            this.skeleton = t.skeleton,
            this
        }
        bind(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert()
        }
        pose() {
            this.skeleton.pose()
        }
        normalizeSkinWeights() {
            const t = new Na
              , e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
                t.x = e.getX(n),
                t.y = e.getY(n),
                t.z = e.getZ(n),
                t.w = e.getW(n);
                const i = 1 / t.manhattanLength();
                i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
            "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }
        boneTransform(t, e) {
            const n = this.skeleton
              , i = this.geometry;
            fp.fromBufferAttribute(i.attributes.skinIndex, t),
            mp.fromBufferAttribute(i.attributes.skinWeight, t),
            pp.copy(e).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
                const i = mp.getComponent(t);
                if (0 !== i) {
                    const r = fp.getComponent(t);
                    vp.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                    e.addScaledVector(gp.copy(pp).applyMatrix4(vp), i)
                }
            }
            return e.applyMatrix4(this.bindMatrixInverse)
        }
    }
    yp.prototype.isSkinnedMesh = !0;
    class _p extends Vl {
        constructor() {
            super(),
            this.type = "Bone"
        }
    }
    _p.prototype.isBone = !0;
    class xp extends Oa {
        constructor(t=null, e=1, n=1, i, r, s, o, a, l=1003, c=1003, h, u) {
            super(null, s, o, a, l, c, i, r, h, u),
            this.image = {
                data: t,
                width: e,
                height: n
            },
            this.magFilter = l,
            this.minFilter = c,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    xp.prototype.isDataTexture = !0;
    const bp = new vl
      , wp = new vl;
    class Mp {
        constructor(t=[], e=[]) {
            this.uuid = ya(),
            this.bones = t.slice(0),
            this.boneInverses = e,
            this.boneMatrices = null,
            this.boneTexture = null,
            this.boneTextureSize = 0,
            this.frame = -1,
            this.init()
        }
        init() {
            const t = this.bones
              , e = this.boneInverses;
            if (this.boneMatrices = new Float32Array(16 * t.length),
            0 === e.length)
                this.calculateInverses();
            else if (t.length !== e.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                this.boneInverses = [];
                for (let t = 0, e = this.bones.length; t < e; t++)
                    this.boneInverses.push(new vl)
            }
        }
        calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = new vl;
                this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e)
            }
        }
        pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = this.bones[t];
                e && e.matrixWorld.copy(this.boneInverses[t]).invert()
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = this.bones[t];
                e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
            }
        }
        update() {
            const t = this.bones
              , e = this.boneInverses
              , n = this.boneMatrices
              , i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
                const r = t[i] ? t[i].matrixWorld : wp;
                bp.multiplyMatrices(r, e[i]),
                bp.toArray(n, 16 * i)
            }
            null !== i && (i.needsUpdate = !0)
        }
        clone() {
            return new Mp(this.bones,this.boneInverses)
        }
        computeBoneTexture() {
            let t = Math.sqrt(4 * this.bones.length);
            t = Ma(t),
            t = Math.max(t, 4);
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new xp(e,t,t,Zo,jo);
            return this.boneMatrices = e,
            this.boneTexture = n,
            this.boneTextureSize = t,
            this
        }
        getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
                const n = this.bones[e];
                if (n.name === t)
                    return n
            }
        }
        dispose() {
            null !== this.boneTexture && (this.boneTexture.dispose(),
            this.boneTexture = null)
        }
        fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
                const i = t.bones[n];
                let r = e[i];
                void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                r = new _p),
                this.bones.push(r),
                this.boneInverses.push((new vl).fromArray(t.boneInverses[n]))
            }
            return this.init(),
            this
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            t.uuid = this.uuid;
            const e = this.bones
              , n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
                const r = e[i];
                t.bones.push(r.uuid);
                const s = n[i];
                t.boneInverses.push(s.toArray())
            }
            return t
        }
    }
    class Sp extends dc {
        constructor(t, e, n, i=1) {
            "number" == typeof n && (i = n,
            n = !1,
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
            super(t, e, n),
            this.meshPerAttribute = i
        }
        copy(t) {
            return super.copy(t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.meshPerAttribute = this.meshPerAttribute,
            t.isInstancedBufferAttribute = !0,
            t
        }
    }
    Sp.prototype.isInstancedBufferAttribute = !0;
    const Tp = new vl
      , Ep = new vl
      , Ap = []
      , Rp = new Hc;
    (class extends Hc {
        constructor(t, e, n) {
            super(t, e),
            this.instanceMatrix = new Sp(new Float32Array(16 * n),16),
            this.instanceColor = null,
            this.count = n,
            this.frustumCulled = !1
        }
        copy(t) {
            return super.copy(t),
            this.instanceMatrix.copy(t.instanceMatrix),
            null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
            this.count = t.count,
            this
        }
        getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t)
        }
        getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
        }
        raycast(t, e) {
            const n = this.matrixWorld
              , i = this.count;
            if (Rp.geometry = this.geometry,
            Rp.material = this.material,
            void 0 !== Rp.material)
                for (let r = 0; r < i; r++) {
                    this.getMatrixAt(r, Tp),
                    Ep.multiplyMatrices(n, Tp),
                    Rp.matrixWorld = Ep,
                    Rp.raycast(t, Ap);
                    for (let t = 0, n = Ap.length; t < n; t++) {
                        const n = Ap[t];
                        n.instanceId = r,
                        n.object = this,
                        e.push(n)
                    }
                    Ap.length = 0
                }
        }
        setColorAt(t, e) {
            null === this.instanceColor && (this.instanceColor = new Sp(new Float32Array(3 * this.instanceMatrix.count),3)),
            e.toArray(this.instanceColor.array, 3 * t)
        }
        setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
        }
        updateMorphTargets() {}
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    ).prototype.isInstancedMesh = !0;
    class Lp extends ec {
        constructor(t) {
            super(),
            this.type = "LineBasicMaterial",
            this.color = new lc(16777215),
            this.linewidth = 1,
            this.linecap = "round",
            this.linejoin = "round",
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.linewidth = t.linewidth,
            this.linecap = t.linecap,
            this.linejoin = t.linejoin,
            this
        }
    }
    Lp.prototype.isLineBasicMaterial = !0;
    const Cp = new Ua
      , Pp = new Ua
      , Dp = new vl
      , Ip = new gl
      , Op = new ll;
    class kp extends Vl {
        constructor(t=new Mc, e=new Lp) {
            super(),
            this.type = "Line",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        copy(t) {
            return super.copy(t),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        }
        computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [0];
                    for (let t = 1, i = e.count; t < i; t++)
                        Cp.fromBufferAttribute(e, t - 1),
                        Pp.fromBufferAttribute(e, t),
                        n[t] = n[t - 1],
                        n[t] += Cp.distanceTo(Pp);
                    t.setAttribute("lineDistance", new mc(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
        raycast(t, e) {
            const n = this.geometry
              , i = this.matrixWorld
              , r = t.params.Line.threshold
              , s = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            Op.copy(n.boundingSphere),
            Op.applyMatrix4(i),
            Op.radius += r,
            !1 === t.ray.intersectsSphere(Op))
                return;
            Dp.copy(i).invert(),
            Ip.copy(t.ray).applyMatrix4(Dp);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , a = o * o
              , l = new Ua
              , c = new Ua
              , h = new Ua
              , u = new Ua
              , d = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
                const i = n.index
                  , r = n.attributes.position;
                if (null !== i)
                    for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) {
                        const s = i.getX(n)
                          , o = i.getX(n + 1);
                        if (l.fromBufferAttribute(r, s),
                        c.fromBufferAttribute(r, o),
                        Ip.distanceSqToSegment(l, c, u, h) > a)
                            continue;
                        u.applyMatrix4(this.matrixWorld);
                        const d = t.ray.origin.distanceTo(u);
                        d < t.near || d > t.far || e.push({
                            distance: d,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                else
                    for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                        if (l.fromBufferAttribute(r, n),
                        c.fromBufferAttribute(r, n + 1),
                        Ip.distanceSqToSegment(l, c, u, h) > a)
                            continue;
                        u.applyMatrix4(this.matrixWorld);
                        const i = t.ray.origin.distanceTo(u);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            } else
                n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
        updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }
    kp.prototype.isLine = !0;
    const Np = new Ua
      , zp = new Ua;
    class Bp extends kp {
        constructor(t, e) {
            super(t, e),
            this.type = "LineSegments"
        }
        computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [];
                    for (let t = 0, i = e.count; t < i; t += 2)
                        Np.fromBufferAttribute(e, t),
                        zp.fromBufferAttribute(e, t + 1),
                        n[t] = 0 === t ? 0 : n[t - 1],
                        n[t + 1] = n[t] + Np.distanceTo(zp);
                    t.setAttribute("lineDistance", new mc(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
    }
    Bp.prototype.isLineSegments = !0;
    class Fp extends kp {
        constructor(t, e) {
            super(t, e),
            this.type = "LineLoop"
        }
    }
    Fp.prototype.isLineLoop = !0;
    class Up extends ec {
        constructor(t) {
            super(),
            this.type = "PointsMaterial",
            this.color = new lc(16777215),
            this.map = null,
            this.alphaMap = null,
            this.size = 1,
            this.sizeAttenuation = !0,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.size = t.size,
            this.sizeAttenuation = t.sizeAttenuation,
            this
        }
    }
    Up.prototype.isPointsMaterial = !0;
    const Hp = new vl
      , Vp = new gl
      , Gp = new ll
      , Wp = new Ua;
    class jp extends Vl {
        constructor(t=new Mc, e=new Up) {
            super(),
            this.type = "Points",
            this.geometry = t,
            this.material = e,
            this.updateMorphTargets()
        }
        copy(t) {
            return super.copy(t),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        }
        raycast(t, e) {
            const n = this.geometry
              , i = this.matrixWorld
              , r = t.params.Points.threshold
              , s = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            Gp.copy(n.boundingSphere),
            Gp.applyMatrix4(i),
            Gp.radius += r,
            !1 === t.ray.intersectsSphere(Gp))
                return;
            Hp.copy(i).invert(),
            Vp.copy(t.ray).applyMatrix4(Hp);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , a = o * o;
            if (n.isBufferGeometry) {
                const r = n.index
                  , o = n.attributes.position;
                if (null !== r)
                    for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                        const s = r.getX(n);
                        Wp.fromBufferAttribute(o, s),
                        Xp(Wp, s, a, i, t, e, this)
                    }
                else
                    for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++)
                        Wp.fromBufferAttribute(o, n),
                        Xp(Wp, n, a, i, t, e, this)
            } else
                console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
        updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }
    function Xp(t, e, n, i, r, s, o) {
        const a = Vp.distanceSqToPoint(t);
        if (a < n) {
            const n = new Ua;
            Vp.closestPointToPoint(t, n),
            n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far)
                return;
            s.push({
                distance: l,
                distanceToRay: Math.sqrt(a),
                point: n,
                index: e,
                face: null,
                object: o
            })
        }
    }
    jp.prototype.isPoints = !0,
    class extends Oa {
        constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l),
            this.format = void 0 !== o ? o : Yo,
            this.minFilter = void 0 !== s ? s : Uo,
            this.magFilter = void 0 !== r ? r : Uo,
            this.generateMipmaps = !1;
            const c = this;
            "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                c.needsUpdate = !0,
                t.requestVideoFrameCallback(e)
            }
            ))
        }
        clone() {
            return new this.constructor(this.image).copy(this)
        }
        update() {
            const t = this.image;
            !1 == "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }
    .prototype.isVideoTexture = !0;
    (class extends Oa {
        constructor(t, e, n, i, r, s, o, a, l, c, h, u) {
            super(null, s, o, a, l, c, i, r, h, u),
            this.image = {
                width: e,
                height: n
            },
            this.mipmaps = t,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
    }
    ).prototype.isCompressedTexture = !0,
    class extends Oa {
        constructor(t, e, n, i, r, s, o, a, l) {
            super(t, e, n, i, r, s, o, a, l),
            this.needsUpdate = !0
        }
    }
    .prototype.isCanvasTexture = !0;
    class qp extends Oa {
        constructor(t, e, n, i, r, s, o, a, l, c) {
            if ((c = void 0 !== c ? c : Jo) !== Jo && c !== Ko)
                throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && c === Jo && (n = Go),
            void 0 === n && c === Ko && (n = qo),
            super(null, i, r, s, o, a, c, n, l),
            this.image = {
                width: t,
                height: e
            },
            this.magFilter = void 0 !== o ? o : zo,
            this.minFilter = void 0 !== a ? a : zo,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
    }
    qp.prototype.isDepthTexture = !0,
    new Ua,
    new Ua,
    new Ua,
    new $l;
    class Yp {
        constructor() {
            this.type = "Curve",
            this.arcLengthDivisions = 200
        }
        getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        }
        getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        }
        getPoints(t=5) {
            const e = [];
            for (let n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return e
        }
        getSpacedPoints(t=5) {
            const e = [];
            for (let n = 0; n <= t; n++)
                e.push(this.getPointAt(n / t));
            return e
        }
        getLength() {
            const t = this.getLengths();
            return t[t.length - 1]
        }
        getLengths(t=this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n, i = this.getPoint(0), r = 0;
            e.push(0);
            for (let s = 1; s <= t; s++)
                n = this.getPoint(s / t),
                r += n.distanceTo(i),
                e.push(r),
                i = n;
            return this.cacheArcLengths = e,
            e
        }
        updateArcLengths() {
            this.needsUpdate = !0,
            this.getLengths()
        }
        getUtoTmapping(t, e) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let s;
            s = e || t * n[r - 1];
            let o, a = 0, l = r - 1;
            for (; a <= l; )
                if (i = Math.floor(a + (l - a) / 2),
                o = n[i] - s,
                o < 0)
                    a = i + 1;
                else {
                    if (!(o > 0)) {
                        l = i;
                        break
                    }
                    l = i - 1
                }
            if (i = l,
            n[i] === s)
                return i / (r - 1);
            const c = n[i];
            return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
        }
        getTangent(t, e) {
            const n = 1e-4;
            let i = t - n
              , r = t + n;
            i < 0 && (i = 0),
            r > 1 && (r = 1);
            const s = this.getPoint(i)
              , o = this.getPoint(r)
              , a = e || (s.isVector2 ? new Ea : new Ua);
            return a.copy(o).sub(s).normalize(),
            a
        }
        getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e)
        }
        computeFrenetFrames(t, e) {
            const n = new Ua
              , i = []
              , r = []
              , s = []
              , o = new Ua
              , a = new vl;
            for (let e = 0; e <= t; e++) {
                const n = e / t;
                i[e] = this.getTangentAt(n, new Ua)
            }
            r[0] = new Ua,
            s[0] = new Ua;
            let l = Number.MAX_VALUE;
            const c = Math.abs(i[0].x)
              , h = Math.abs(i[0].y)
              , u = Math.abs(i[0].z);
            c <= l && (l = c,
            n.set(1, 0, 0)),
            h <= l && (l = h,
            n.set(0, 1, 0)),
            u <= l && n.set(0, 0, 1),
            o.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], o),
            s[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
                if (r[e] = r[e - 1].clone(),
                s[e] = s[e - 1].clone(),
                o.crossVectors(i[e - 1], i[e]),
                o.length() > Number.EPSILON) {
                    o.normalize();
                    const t = Math.acos(_a(i[e - 1].dot(i[e]), -1, 1));
                    r[e].applyMatrix4(a.makeRotationAxis(o, t))
                }
                s[e].crossVectors(i[e], r[e])
            }
            if (!0 === e) {
                let e = Math.acos(_a(r[0].dot(r[t]), -1, 1));
                e /= t,
                i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let n = 1; n <= t; n++)
                    r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                    s[n].crossVectors(i[n], r[n])
            }
            return {
                tangents: i,
                normals: r,
                binormals: s
            }
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        }
        fromJSON(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }
    class Zp extends Yp {
        constructor(t=0, e=0, n=1, i=1, r=0, s=2 * Math.PI, o=!1, a=0) {
            super(),
            this.type = "EllipseCurve",
            this.aX = t,
            this.aY = e,
            this.xRadius = n,
            this.yRadius = i,
            this.aStartAngle = r,
            this.aEndAngle = s,
            this.aClockwise = o,
            this.aRotation = a
        }
        getPoint(t, e) {
            const n = e || new Ea
              , i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0; )
                r += i;
            for (; r > i; )
                r -= i;
            r < Number.EPSILON && (r = s ? 0 : i),
            !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
            const o = this.aStartAngle + t * r;
            let a = this.aX + this.xRadius * Math.cos(o)
              , l = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
                const t = Math.cos(this.aRotation)
                  , e = Math.sin(this.aRotation)
                  , n = a - this.aX
                  , i = l - this.aY;
                a = n * t - i * e + this.aX,
                l = n * e + i * t + this.aY
            }
            return n.set(a, l)
        }
        copy(t) {
            return super.copy(t),
            this.aX = t.aX,
            this.aY = t.aY,
            this.xRadius = t.xRadius,
            this.yRadius = t.yRadius,
            this.aStartAngle = t.aStartAngle,
            this.aEndAngle = t.aEndAngle,
            this.aClockwise = t.aClockwise,
            this.aRotation = t.aRotation,
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.aX = this.aX,
            t.aY = this.aY,
            t.xRadius = this.xRadius,
            t.yRadius = this.yRadius,
            t.aStartAngle = this.aStartAngle,
            t.aEndAngle = this.aEndAngle,
            t.aClockwise = this.aClockwise,
            t.aRotation = this.aRotation,
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.aX = t.aX,
            this.aY = t.aY,
            this.xRadius = t.xRadius,
            this.yRadius = t.yRadius,
            this.aStartAngle = t.aStartAngle,
            this.aEndAngle = t.aEndAngle,
            this.aClockwise = t.aClockwise,
            this.aRotation = t.aRotation,
            this
        }
    }
    Zp.prototype.isEllipseCurve = !0;
    class Jp extends Zp {
        constructor(t, e, n, i, r, s) {
            super(t, e, n, n, i, r, s),
            this.type = "ArcCurve"
        }
    }
    function Kp() {
        let t = 0
          , e = 0
          , n = 0
          , i = 0;
        function r(r, s, o, a) {
            t = r,
            e = o,
            n = -3 * r + 3 * s - 2 * o - a,
            i = 2 * r - 2 * s + o + a
        }
        return {
            initCatmullRom: function(t, e, n, i, s) {
                r(e, n, s * (n - t), s * (i - e))
            },
            initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o
                  , c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                l *= o,
                c *= o,
                r(e, n, l, c)
            },
            calc: function(r) {
                const s = r * r;
                return t + e * r + n * s + i * (s * r)
            }
        }
    }
    Jp.prototype.isArcCurve = !0;
    const Qp = new Ua
      , $p = new Kp
      , tf = new Kp
      , ef = new Kp;
    class nf extends Yp {
        constructor(t=[], e=!1, n="centripetal", i=.5) {
            super(),
            this.type = "CatmullRomCurve3",
            this.points = t,
            this.closed = e,
            this.curveType = n,
            this.tension = i
        }
        getPoint(t, e=new Ua) {
            const n = e
              , i = this.points
              , r = i.length
              , s = (r - (this.closed ? 0 : 1)) * t;
            let o, a, l = Math.floor(s), c = s - l;
            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
            c = 1),
            this.closed || l > 0 ? o = i[(l - 1) % r] : (Qp.subVectors(i[0], i[1]).add(i[0]),
            o = Qp);
            const h = i[l % r]
              , u = i[(l + 1) % r];
            if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Qp.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
            a = Qp),
            "centripetal" === this.curveType || "chordal" === this.curveType) {
                const t = "chordal" === this.curveType ? .5 : .25;
                let e = Math.pow(o.distanceToSquared(h), t)
                  , n = Math.pow(h.distanceToSquared(u), t)
                  , i = Math.pow(u.distanceToSquared(a), t);
                n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                i < 1e-4 && (i = n),
                $p.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i),
                tf.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i),
                ef.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
            } else
                "catmullrom" === this.curveType && ($p.initCatmullRom(o.x, h.x, u.x, a.x, this.tension),
                tf.initCatmullRom(o.y, h.y, u.y, a.y, this.tension),
                ef.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
            return n.set($p.calc(c), tf.calc(c), ef.calc(c)),
            n
        }
        copy(t) {
            super.copy(t),
            this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push(n.clone())
            }
            return this.closed = t.closed,
            this.curveType = t.curveType,
            this.tension = t.tension,
            this
        }
        toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
                const n = this.points[e];
                t.points.push(n.toArray())
            }
            return t.closed = this.closed,
            t.curveType = this.curveType,
            t.tension = this.tension,
            t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push((new Ua).fromArray(n))
            }
            return this.closed = t.closed,
            this.curveType = t.curveType,
            this.tension = t.tension,
            this
        }
    }
    function rf(t, e, n, i, r) {
        const s = .5 * (i - e)
          , o = .5 * (r - n)
          , a = t * t;
        return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
    }
    function sf(t, e, n, i) {
        return function(t, e) {
            const n = 1 - t;
            return n * n * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function(t, e) {
            return t * t * e
        }(t, i)
    }
    function of(t, e, n, i, r) {
        return function(t, e) {
            const n = 1 - t;
            return n * n * n * e
        }(t, e) + function(t, e) {
            const n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function(t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, i) + function(t, e) {
            return t * t * t * e
        }(t, r)
    }
    nf.prototype.isCatmullRomCurve3 = !0;
    class af extends Yp {
        constructor(t=new Ea, e=new Ea, n=new Ea, i=new Ea) {
            super(),
            this.type = "CubicBezierCurve",
            this.v0 = t,
            this.v1 = e,
            this.v2 = n,
            this.v3 = i
        }
        getPoint(t, e=new Ea) {
            const n = e
              , i = this.v0
              , r = this.v1
              , s = this.v2
              , o = this.v3;
            return n.set(of(t, i.x, r.x, s.x, o.x), of(t, i.y, r.y, s.y, o.y)),
            n
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t.v3 = this.v3.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
        }
    }
    af.prototype.isCubicBezierCurve = !0;
    class lf extends Yp {
        constructor(t=new Ua, e=new Ua, n=new Ua, i=new Ua) {
            super(),
            this.type = "CubicBezierCurve3",
            this.v0 = t,
            this.v1 = e,
            this.v2 = n,
            this.v3 = i
        }
        getPoint(t, e=new Ua) {
            const n = e
              , i = this.v0
              , r = this.v1
              , s = this.v2
              , o = this.v3;
            return n.set(of(t, i.x, r.x, s.x, o.x), of(t, i.y, r.y, s.y, o.y), of(t, i.z, r.z, s.z, o.z)),
            n
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this.v3.copy(t.v3),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t.v3 = this.v3.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this.v3.fromArray(t.v3),
            this
        }
    }
    lf.prototype.isCubicBezierCurve3 = !0;
    class cf extends Yp {
        constructor(t=new Ea, e=new Ea) {
            super(),
            this.type = "LineCurve",
            this.v1 = t,
            this.v2 = e
        }
        getPoint(t, e=new Ea) {
            const n = e;
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
            n.multiplyScalar(t).add(this.v1)),
            n
        }
        getPointAt(t, e) {
            return this.getPoint(t, e)
        }
        getTangent(t, e) {
            const n = e || new Ea;
            return n.copy(this.v2).sub(this.v1).normalize(),
            n
        }
        copy(t) {
            return super.copy(t),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
        }
    }
    cf.prototype.isLineCurve = !0;
    class hf extends Yp {
        constructor(t=new Ea, e=new Ea, n=new Ea) {
            super(),
            this.type = "QuadraticBezierCurve",
            this.v0 = t,
            this.v1 = e,
            this.v2 = n
        }
        getPoint(t, e=new Ea) {
            const n = e
              , i = this.v0
              , r = this.v1
              , s = this.v2;
            return n.set(sf(t, i.x, r.x, s.x), sf(t, i.y, r.y, s.y)),
            n
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
        }
    }
    hf.prototype.isQuadraticBezierCurve = !0;
    class uf extends Yp {
        constructor(t=new Ua, e=new Ua, n=new Ua) {
            super(),
            this.type = "QuadraticBezierCurve3",
            this.v0 = t,
            this.v1 = e,
            this.v2 = n
        }
        getPoint(t, e=new Ua) {
            const n = e
              , i = this.v0
              , r = this.v1
              , s = this.v2;
            return n.set(sf(t, i.x, r.x, s.x), sf(t, i.y, r.y, s.y), sf(t, i.z, r.z, s.z)),
            n
        }
        copy(t) {
            return super.copy(t),
            this.v0.copy(t.v0),
            this.v1.copy(t.v1),
            this.v2.copy(t.v2),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(),
            t.v1 = this.v1.toArray(),
            t.v2 = this.v2.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.v0.fromArray(t.v0),
            this.v1.fromArray(t.v1),
            this.v2.fromArray(t.v2),
            this
        }
    }
    uf.prototype.isQuadraticBezierCurve3 = !0;
    class df extends Yp {
        constructor(t=[]) {
            super(),
            this.type = "SplineCurve",
            this.points = t
        }
        getPoint(t, e=new Ea) {
            const n = e
              , i = this.points
              , r = (i.length - 1) * t
              , s = Math.floor(r)
              , o = r - s
              , a = i[0 === s ? s : s - 1]
              , l = i[s]
              , c = i[s > i.length - 2 ? i.length - 1 : s + 1]
              , h = i[s > i.length - 3 ? i.length - 1 : s + 2];
            return n.set(rf(o, a.x, l.x, c.x, h.x), rf(o, a.y, l.y, c.y, h.y)),
            n
        }
        copy(t) {
            super.copy(t),
            this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push(n.clone())
            }
            return this
        }
        toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
                const n = this.points[e];
                t.points.push(n.toArray())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push((new Ea).fromArray(n))
            }
            return this
        }
    }
    df.prototype.isSplineCurve = !0;
    var pf = Object.freeze({
        __proto__: null,
        ArcCurve: Jp,
        CatmullRomCurve3: nf,
        CubicBezierCurve: af,
        CubicBezierCurve3: lf,
        EllipseCurve: Zp,
        LineCurve: cf,
        LineCurve3: class extends Yp {
            constructor(t=new Ua, e=new Ua) {
                super(),
                this.type = "LineCurve3",
                this.isLineCurve3 = !0,
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new Ua) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
                n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        ,
        QuadraticBezierCurve: hf,
        QuadraticBezierCurve3: uf,
        SplineCurve: df
    });
    class ff extends Yp {
        constructor() {
            super(),
            this.type = "CurvePath",
            this.curves = [],
            this.autoClose = !1
        }
        add(t) {
            this.curves.push(t)
        }
        closePath() {
            const t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new cf(e,t))
        }
        getPoint(t, e) {
            const n = t * this.getLength()
              , i = this.getCurveLengths();
            let r = 0;
            for (; r < i.length; ) {
                if (i[r] >= n) {
                    const t = i[r] - n
                      , s = this.curves[r]
                      , o = s.getLength()
                      , a = 0 === o ? 0 : 1 - t / o;
                    return s.getPointAt(a, e)
                }
                r++
            }
            return null
        }
        getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1]
        }
        updateArcLengths() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        }
        getCurveLengths() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
                e += this.curves[n].getLength(),
                t.push(e);
            return this.cacheLengths = t,
            t
        }
        getSpacedPoints(t=40) {
            const e = [];
            for (let n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]),
            e
        }
        getPoints(t=12) {
            const e = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
                const s = r[i]
                  , o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
                  , a = s.getPoints(o);
                for (let t = 0; t < a.length; t++) {
                    const i = a[t];
                    n && n.equals(i) || (e.push(i),
                    n = i)
                }
            }
            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
            e
        }
        copy(t) {
            super.copy(t),
            this.curves = [];
            for (let e = 0, n = t.curves.length; e < n; e++) {
                const n = t.curves[e];
                this.curves.push(n.clone())
            }
            return this.autoClose = t.autoClose,
            this
        }
        toJSON() {
            const t = super.toJSON();
            t.autoClose = this.autoClose,
            t.curves = [];
            for (let e = 0, n = this.curves.length; e < n; e++) {
                const n = this.curves[e];
                t.curves.push(n.toJSON())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (let e = 0, n = t.curves.length; e < n; e++) {
                const n = t.curves[e];
                this.curves.push((new pf[n.type]).fromJSON(n))
            }
            return this
        }
    }
    class mf extends ff {
        constructor(t) {
            super(),
            this.type = "Path",
            this.currentPoint = new Ea,
            t && this.setFromPoints(t)
        }
        setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++)
                this.lineTo(t[e].x, t[e].y);
            return this
        }
        moveTo(t, e) {
            return this.currentPoint.set(t, e),
            this
        }
        lineTo(t, e) {
            const n = new cf(this.currentPoint.clone(),new Ea(t,e));
            return this.curves.push(n),
            this.currentPoint.set(t, e),
            this
        }
        quadraticCurveTo(t, e, n, i) {
            const r = new hf(this.currentPoint.clone(),new Ea(t,e),new Ea(n,i));
            return this.curves.push(r),
            this.currentPoint.set(n, i),
            this
        }
        bezierCurveTo(t, e, n, i, r, s) {
            const o = new af(this.currentPoint.clone(),new Ea(t,e),new Ea(n,i),new Ea(r,s));
            return this.curves.push(o),
            this.currentPoint.set(r, s),
            this
        }
        splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t)
              , n = new df(e);
            return this.curves.push(n),
            this.currentPoint.copy(t[t.length - 1]),
            this
        }
        arc(t, e, n, i, r, s) {
            const o = this.currentPoint.x
              , a = this.currentPoint.y;
            return this.absarc(t + o, e + a, n, i, r, s),
            this
        }
        absarc(t, e, n, i, r, s) {
            return this.absellipse(t, e, n, n, i, r, s),
            this
        }
        ellipse(t, e, n, i, r, s, o, a) {
            const l = this.currentPoint.x
              , c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, s, o, a),
            this
        }
        absellipse(t, e, n, i, r, s, o, a) {
            const l = new Zp(t,e,n,i,r,s,o,a);
            if (this.curves.length > 0) {
                const t = l.getPoint(0);
                t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c),
            this
        }
        copy(t) {
            return super.copy(t),
            this.currentPoint.copy(t.currentPoint),
            this
        }
        toJSON() {
            const t = super.toJSON();
            return t.currentPoint = this.currentPoint.toArray(),
            t
        }
        fromJSON(t) {
            return super.fromJSON(t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }
    class gf extends mf {
        constructor(t) {
            super(t),
            this.uuid = ya(),
            this.type = "Shape",
            this.holes = []
        }
        getPointsHoles(t) {
            const e = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
                e[n] = this.holes[n].getPoints(t);
            return e
        }
        extractPoints(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        }
        copy(t) {
            super.copy(t),
            this.holes = [];
            for (let e = 0, n = t.holes.length; e < n; e++) {
                const n = t.holes[e];
                this.holes.push(n.clone())
            }
            return this
        }
        toJSON() {
            const t = super.toJSON();
            t.uuid = this.uuid,
            t.holes = [];
            for (let e = 0, n = this.holes.length; e < n; e++) {
                const n = this.holes[e];
                t.holes.push(n.toJSON())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t),
            this.uuid = t.uuid,
            this.holes = [];
            for (let e = 0, n = t.holes.length; e < n; e++) {
                const n = t.holes[e];
                this.holes.push((new mf).fromJSON(n))
            }
            return this
        }
    }
    function vf(t, e, n, i, r) {
        let s, o;
        if (r === function(t, e, n, i) {
            let r = 0;
            for (let s = e, o = n - i; s < n; s += i)
                r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]),
                o = s;
            return r
        }(t, e, n, i) > 0)
            for (s = e; s < n; s += i)
                o = Bf(s, t[s], t[s + 1], o);
        else
            for (s = n - i; s >= e; s -= i)
                o = Bf(s, t[s], t[s + 1], o);
        return o && Df(o, o.next) && (Ff(o),
        o = o.next),
        o
    }
    function yf(t, e) {
        if (!t)
            return t;
        e || (e = t);
        let n, i = t;
        do {
            if (n = !1,
            i.steiner || !Df(i, i.next) && 0 !== Pf(i.prev, i, i.next))
                i = i.next;
            else {
                if (Ff(i),
                i = e = i.prev,
                i === i.next)
                    break;
                n = !0
            }
        } while (n || i !== e);
        return e
    }
    function _f(t, e, n, i, r, s, o) {
        if (!t)
            return;
        !o && s && function(t, e, n, i) {
            let r = t;
            do {
                null === r.z && (r.z = Af(r.x, r.y, e, n, i)),
                r.prevZ = r.prev,
                r.nextZ = r.next,
                r = r.next
            } while (r !== t);
            r.prevZ.nextZ = null,
            r.prevZ = null,
            function(t) {
                let e, n, i, r, s, o, a, l, c = 1;
                do {
                    for (n = t,
                    t = null,
                    s = null,
                    o = 0; n; ) {
                        for (o++,
                        i = n,
                        a = 0,
                        e = 0; e < c && (a++,
                        i = i.nextZ,
                        i); e++)
                            ;
                        for (l = c; a > 0 || l > 0 && i; )
                            0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n,
                            n = n.nextZ,
                            a--) : (r = i,
                            i = i.nextZ,
                            l--),
                            s ? s.nextZ = r : t = r,
                            r.prevZ = s,
                            s = r;
                        n = i
                    }
                    s.nextZ = null,
                    c *= 2
                } while (o > 1)
            }(r)
        }(t, i, r, s);
        let a, l, c = t;
        for (; t.prev !== t.next; )
            if (a = t.prev,
            l = t.next,
            s ? bf(t, i, r, s) : xf(t))
                e.push(a.i / n),
                e.push(t.i / n),
                e.push(l.i / n),
                Ff(t),
                t = l.next,
                c = l.next;
            else if ((t = l) === c) {
                o ? 1 === o ? _f(t = wf(yf(t), e, n), e, n, i, r, s, 2) : 2 === o && Mf(t, e, n, i, r, s) : _f(yf(t), e, n, i, r, s, 1);
                break
            }
    }
    function xf(t) {
        const e = t.prev
          , n = t
          , i = t.next;
        if (Pf(e, n, i) >= 0)
            return !1;
        let r = t.next.next;
        for (; r !== t.prev; ) {
            if (Lf(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Pf(r.prev, r, r.next) >= 0)
                return !1;
            r = r.next
        }
        return !0
    }
    function bf(t, e, n, i) {
        const r = t.prev
          , s = t
          , o = t.next;
        if (Pf(r, s, o) >= 0)
            return !1;
        const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x
          , l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y
          , c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x
          , h = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y
          , u = Af(a, l, e, n, i)
          , d = Af(c, h, e, n, i);
        let p = t.prevZ
          , f = t.nextZ;
        for (; p && p.z >= u && f && f.z <= d; ) {
            if (p !== t.prev && p !== t.next && Lf(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Pf(p.prev, p, p.next) >= 0)
                return !1;
            if (p = p.prevZ,
            f !== t.prev && f !== t.next && Lf(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Pf(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        for (; p && p.z >= u; ) {
            if (p !== t.prev && p !== t.next && Lf(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Pf(p.prev, p, p.next) >= 0)
                return !1;
            p = p.prevZ
        }
        for (; f && f.z <= d; ) {
            if (f !== t.prev && f !== t.next && Lf(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Pf(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        return !0
    }
    function wf(t, e, n) {
        let i = t;
        do {
            const r = i.prev
              , s = i.next.next;
            !Df(r, s) && If(r, i, i.next, s) && Nf(r, s) && Nf(s, r) && (e.push(r.i / n),
            e.push(i.i / n),
            e.push(s.i / n),
            Ff(i),
            Ff(i.next),
            i = t = s),
            i = i.next
        } while (i !== t);
        return yf(i)
    }
    function Mf(t, e, n, i, r, s) {
        let o = t;
        do {
            let t = o.next.next;
            for (; t !== o.prev; ) {
                if (o.i !== t.i && Cf(o, t)) {
                    let a = zf(o, t);
                    return o = yf(o, o.next),
                    a = yf(a, a.next),
                    _f(o, e, n, i, r, s),
                    void _f(a, e, n, i, r, s)
                }
                t = t.next
            }
            o = o.next
        } while (o !== t)
    }
    function Sf(t, e) {
        return t.x - e.x
    }
    function Tf(t, e) {
        if (e = function(t, e) {
            let n = e;
            const i = t.x
              , r = t.y;
            let s, o = -1 / 0;
            do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (t <= i && t > o) {
                        if (o = t,
                        t === i) {
                            if (r === n.y)
                                return n;
                            if (r === n.next.y)
                                return n.next
                        }
                        s = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== e);
            if (!s)
                return null;
            if (i === o)
                return s;
            const a = s
              , l = s.x
              , c = s.y;
            let h, u = 1 / 0;
            n = s;
            do {
                i >= n.x && n.x >= l && i !== n.x && Lf(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x),
                Nf(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Ef(s, n))) && (s = n,
                u = h)),
                n = n.next
            } while (n !== a);
            return s
        }(t, e),
        e) {
            const n = zf(e, t);
            yf(e, e.next),
            yf(n, n.next)
        }
    }
    function Ef(t, e) {
        return Pf(t.prev, t, e.prev) < 0 && Pf(e.next, t, t.next) < 0
    }
    function Af(t, e, n, i, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function Rf(t) {
        let e = t
          , n = t;
        do {
            (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
            e = e.next
        } while (e !== t);
        return n
    }
    function Lf(t, e, n, i, r, s, o, a) {
        return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0
    }
    function Cf(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
            let n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && If(n, n.next, t, e))
                    return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && (Nf(t, e) && Nf(e, t) && function(t, e) {
            let n = t
              , i = !1;
            const r = (t.x + e.x) / 2
              , s = (t.y + e.y) / 2;
            do {
                n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                n = n.next
            } while (n !== t);
            return i
        }(t, e) && (Pf(t.prev, t, e.prev) || Pf(t, e.prev, e)) || Df(t, e) && Pf(t.prev, t, t.next) > 0 && Pf(e.prev, e, e.next) > 0)
    }
    function Pf(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }
    function Df(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function If(t, e, n, i) {
        const r = kf(Pf(t, e, n))
          , s = kf(Pf(t, e, i))
          , o = kf(Pf(n, i, t))
          , a = kf(Pf(n, i, e));
        return r !== s && o !== a || !(0 !== r || !Of(t, n, e)) || !(0 !== s || !Of(t, i, e)) || !(0 !== o || !Of(n, t, i)) || !(0 !== a || !Of(n, e, i))
    }
    function Of(t, e, n) {
        return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
    }
    function kf(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }
    function Nf(t, e) {
        return Pf(t.prev, t, t.next) < 0 ? Pf(t, e, t.next) >= 0 && Pf(t, t.prev, e) >= 0 : Pf(t, e, t.prev) < 0 || Pf(t, t.next, e) < 0
    }
    function zf(t, e) {
        const n = new Uf(t.i,t.x,t.y)
          , i = new Uf(e.i,e.x,e.y)
          , r = t.next
          , s = e.prev;
        return t.next = e,
        e.prev = t,
        n.next = r,
        r.prev = n,
        i.next = n,
        n.prev = i,
        s.next = i,
        i.prev = s,
        i
    }
    function Bf(t, e, n, i) {
        const r = new Uf(t,e,n);
        return i ? (r.next = i.next,
        r.prev = i,
        i.next.prev = r,
        i.next = r) : (r.prev = r,
        r.next = r),
        r
    }
    function Ff(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function Uf(t, e, n) {
        this.i = t,
        this.x = e,
        this.y = n,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    class Hf {
        static area(t) {
            const e = t.length;
            let n = 0;
            for (let i = e - 1, r = 0; r < e; i = r++)
                n += t[i].x * t[r].y - t[r].x * t[i].y;
            return .5 * n
        }
        static isClockWise(t) {
            return Hf.area(t) < 0
        }
        static triangulateShape(t, e) {
            const n = []
              , i = []
              , r = [];
            Vf(t),
            Gf(n, t);
            let s = t.length;
            e.forEach(Vf);
            for (let t = 0; t < e.length; t++)
                i.push(s),
                s += e[t].length,
                Gf(n, e[t]);
            const o = function(t, e, n=2) {
                const i = e && e.length
                  , r = i ? e[0] * n : t.length;
                let s = vf(t, 0, r, n, !0);
                const o = [];
                if (!s || s.next === s.prev)
                    return o;
                let a, l, c, h, u, d, p;
                if (i && (s = function(t, e, n, i) {
                    const r = [];
                    let s, o, a, l, c;
                    for (s = 0,
                    o = e.length; s < o; s++)
                        a = e[s] * i,
                        l = s < o - 1 ? e[s + 1] * i : t.length,
                        c = vf(t, a, l, i, !1),
                        c === c.next && (c.steiner = !0),
                        r.push(Rf(c));
                    for (r.sort(Sf),
                    s = 0; s < r.length; s++)
                        Tf(r[s], n),
                        n = yf(n, n.next);
                    return n
                }(t, e, s, n)),
                t.length > 80 * n) {
                    a = c = t[0],
                    l = h = t[1];
                    for (let e = n; e < r; e += n)
                        u = t[e],
                        d = t[e + 1],
                        u < a && (a = u),
                        d < l && (l = d),
                        u > c && (c = u),
                        d > h && (h = d);
                    p = Math.max(c - a, h - l),
                    p = 0 !== p ? 1 / p : 0
                }
                return _f(s, o, n, a, l, p),
                o
            }(n, i);
            for (let t = 0; t < o.length; t += 3)
                r.push(o.slice(t, t + 3));
            return r
        }
    }
    function Vf(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }
    function Gf(t, e) {
        for (let n = 0; n < e.length; n++)
            t.push(e[n].x),
            t.push(e[n].y)
    }
    class Wf extends Mc {
        constructor(t=new gf([new Ea(.5,.5), new Ea(-.5,.5), new Ea(-.5,-.5), new Ea(.5,-.5)]), e={}) {
            super(),
            this.type = "ExtrudeGeometry",
            this.parameters = {
                shapes: t,
                options: e
            },
            t = Array.isArray(t) ? t : [t];
            const n = this
              , i = []
              , r = [];
            for (let e = 0, n = t.length; e < n; e++)
                s(t[e]);
            function s(t) {
                const s = []
                  , o = void 0 !== e.curveSegments ? e.curveSegments : 12
                  , a = void 0 !== e.steps ? e.steps : 1;
                let l = void 0 !== e.depth ? e.depth : 1
                  , c = void 0 === e.bevelEnabled || e.bevelEnabled
                  , h = void 0 !== e.bevelThickness ? e.bevelThickness : .2
                  , u = void 0 !== e.bevelSize ? e.bevelSize : h - .1
                  , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                  , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                const f = e.extrudePath
                  , m = void 0 !== e.UVGenerator ? e.UVGenerator : jf;
                void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                l = e.amount);
                let g, v, y, _, x, b = !1;
                f && (g = f.getSpacedPoints(a),
                b = !0,
                c = !1,
                v = f.computeFrenetFrames(a, !1),
                y = new Ua,
                _ = new Ua,
                x = new Ua),
                c || (p = 0,
                h = 0,
                u = 0,
                d = 0);
                const w = t.extractPoints(o);
                let M = w.shape;
                const S = w.holes;
                if (!Hf.isClockWise(M)) {
                    M = M.reverse();
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        Hf.isClockWise(e) && (S[t] = e.reverse())
                    }
                }
                const T = Hf.triangulateShape(M, S)
                  , E = M;
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    M = M.concat(e)
                }
                function A(t, e, n) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    e.clone().multiplyScalar(n).add(t)
                }
                const R = M.length
                  , L = T.length;
                function C(t, e, n) {
                    let i, r, s;
                    const o = t.x - e.x
                      , a = t.y - e.y
                      , l = n.x - t.x
                      , c = n.y - t.y
                      , h = o * o + a * a
                      , u = o * c - a * l;
                    if (Math.abs(u) > Number.EPSILON) {
                        const u = Math.sqrt(h)
                          , d = Math.sqrt(l * l + c * c)
                          , p = e.x - a / u
                          , f = e.y + o / u
                          , m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (o * c - a * l);
                        i = p + o * m - t.x,
                        r = f + a * m - t.y;
                        const g = i * i + r * r;
                        if (g <= 2)
                            return new Ea(i,r);
                        s = Math.sqrt(g / 2)
                    } else {
                        let t = !1;
                        o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0),
                        t ? (i = -a,
                        r = o,
                        s = Math.sqrt(h)) : (i = o,
                        r = a,
                        s = Math.sqrt(h / 2))
                    }
                    return new Ea(i / s,r / s)
                }
                const P = [];
                for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++,
                n++,
                i++)
                    n === e && (n = 0),
                    i === e && (i = 0),
                    P[t] = C(E[t], E[n], E[i]);
                const D = [];
                let I, O = P.concat();
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    I = [];
                    for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++,
                    i++,
                    r++)
                        i === n && (i = 0),
                        r === n && (r = 0),
                        I[t] = C(e[t], e[i], e[r]);
                    D.push(I),
                    O = O.concat(I)
                }
                for (let t = 0; t < p; t++) {
                    const e = t / p
                      , n = h * Math.cos(e * Math.PI / 2)
                      , i = u * Math.sin(e * Math.PI / 2) + d;
                    for (let t = 0, e = E.length; t < e; t++) {
                        const e = A(E[t], P[t], i);
                        z(e.x, e.y, -n)
                    }
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        I = D[t];
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = A(e[t], I[t], i);
                            z(r.x, r.y, -n)
                        }
                    }
                }
                const k = u + d;
                for (let t = 0; t < R; t++) {
                    const e = c ? A(M[t], O[t], k) : M[t];
                    b ? (_.copy(v.normals[0]).multiplyScalar(e.x),
                    y.copy(v.binormals[0]).multiplyScalar(e.y),
                    x.copy(g[0]).add(_).add(y),
                    z(x.x, x.y, x.z)) : z(e.x, e.y, 0)
                }
                for (let t = 1; t <= a; t++)
                    for (let e = 0; e < R; e++) {
                        const n = c ? A(M[e], O[e], k) : M[e];
                        b ? (_.copy(v.normals[t]).multiplyScalar(n.x),
                        y.copy(v.binormals[t]).multiplyScalar(n.y),
                        x.copy(g[t]).add(_).add(y),
                        z(x.x, x.y, x.z)) : z(n.x, n.y, l / a * t)
                    }
                for (let t = p - 1; t >= 0; t--) {
                    const e = t / p
                      , n = h * Math.cos(e * Math.PI / 2)
                      , i = u * Math.sin(e * Math.PI / 2) + d;
                    for (let t = 0, e = E.length; t < e; t++) {
                        const e = A(E[t], P[t], i);
                        z(e.x, e.y, l + n)
                    }
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        I = D[t];
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = A(e[t], I[t], i);
                            b ? z(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : z(r.x, r.y, l + n)
                        }
                    }
                }
                function N(t, e) {
                    let n = t.length;
                    for (; --n >= 0; ) {
                        const i = n;
                        let r = n - 1;
                        r < 0 && (r = t.length - 1);
                        for (let t = 0, n = a + 2 * p; t < n; t++) {
                            const n = R * t
                              , s = R * (t + 1);
                            F(e + i + n, e + r + n, e + r + s, e + i + s)
                        }
                    }
                }
                function z(t, e, n) {
                    s.push(t),
                    s.push(e),
                    s.push(n)
                }
                function B(t, e, r) {
                    U(t),
                    U(e),
                    U(r);
                    const s = i.length / 3
                      , o = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
                    H(o[0]),
                    H(o[1]),
                    H(o[2])
                }
                function F(t, e, r, s) {
                    U(t),
                    U(e),
                    U(s),
                    U(e),
                    U(r),
                    U(s);
                    const o = i.length / 3
                      , a = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                    H(a[0]),
                    H(a[1]),
                    H(a[3]),
                    H(a[1]),
                    H(a[2]),
                    H(a[3])
                }
                function U(t) {
                    i.push(s[3 * t + 0]),
                    i.push(s[3 * t + 1]),
                    i.push(s[3 * t + 2])
                }
                function H(t) {
                    r.push(t.x),
                    r.push(t.y)
                }
                !function() {
                    const t = i.length / 3;
                    if (c) {
                        let t = 0
                          , e = R * t;
                        for (let t = 0; t < L; t++) {
                            const n = T[t];
                            B(n[2] + e, n[1] + e, n[0] + e)
                        }
                        t = a + 2 * p,
                        e = R * t;
                        for (let t = 0; t < L; t++) {
                            const n = T[t];
                            B(n[0] + e, n[1] + e, n[2] + e)
                        }
                    } else {
                        for (let t = 0; t < L; t++) {
                            const e = T[t];
                            B(e[2], e[1], e[0])
                        }
                        for (let t = 0; t < L; t++) {
                            const e = T[t];
                            B(e[0] + R * a, e[1] + R * a, e[2] + R * a)
                        }
                    }
                    n.addGroup(t, i.length / 3 - t, 0)
                }(),
                function() {
                    const t = i.length / 3;
                    let e = 0;
                    N(E, e),
                    e += E.length;
                    for (let t = 0, n = S.length; t < n; t++) {
                        const n = S[t];
                        N(n, e),
                        e += n.length
                    }
                    n.addGroup(t, i.length / 3 - t, 1)
                }()
            }
            this.setAttribute("position", new mc(i,3)),
            this.setAttribute("uv", new mc(r,2)),
            this.computeVertexNormals()
        }
        toJSON() {
            const t = super.toJSON();
            return function(t, e, n) {
                if (n.shapes = [],
                Array.isArray(t))
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e];
                        n.shapes.push(i.uuid)
                    }
                else
                    n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()),
                n
            }(this.parameters.shapes, this.parameters.options, t)
        }
        static fromJSON(t, e) {
            const n = [];
            for (let i = 0, r = t.shapes.length; i < r; i++) {
                const r = e[t.shapes[i]];
                n.push(r)
            }
            const i = t.options.extrudePath;
            return void 0 !== i && (t.options.extrudePath = (new pf[i.type]).fromJSON(i)),
            new Wf(n,t.options)
        }
    }
    const jf = {
        generateTopUV: function(t, e, n, i, r) {
            const s = e[3 * n]
              , o = e[3 * n + 1]
              , a = e[3 * i]
              , l = e[3 * i + 1]
              , c = e[3 * r]
              , h = e[3 * r + 1];
            return [new Ea(s,o), new Ea(a,l), new Ea(c,h)]
        },
        generateSideWallUV: function(t, e, n, i, r, s) {
            const o = e[3 * n]
              , a = e[3 * n + 1]
              , l = e[3 * n + 2]
              , c = e[3 * i]
              , h = e[3 * i + 1]
              , u = e[3 * i + 2]
              , d = e[3 * r]
              , p = e[3 * r + 1]
              , f = e[3 * r + 2]
              , m = e[3 * s]
              , g = e[3 * s + 1]
              , v = e[3 * s + 2];
            return Math.abs(a - h) < Math.abs(o - c) ? [new Ea(o,1 - l), new Ea(c,1 - u), new Ea(d,1 - f), new Ea(m,1 - v)] : [new Ea(a,1 - l), new Ea(h,1 - u), new Ea(p,1 - f), new Ea(g,1 - v)]
        }
    };
    class Xf extends Mc {
        constructor(t=new gf([new Ea(0,.5), new Ea(-.5,-.5), new Ea(.5,-.5)]), e=12) {
            super(),
            this.type = "ShapeGeometry",
            this.parameters = {
                shapes: t,
                curveSegments: e
            };
            const n = []
              , i = []
              , r = []
              , s = [];
            let o = 0
              , a = 0;
            if (!1 === Array.isArray(t))
                l(t);
            else
                for (let e = 0; e < t.length; e++)
                    l(t[e]),
                    this.addGroup(o, a, e),
                    o += a,
                    a = 0;
            function l(t) {
                const o = i.length / 3
                  , l = t.extractPoints(e);
                let c = l.shape;
                const h = l.holes;
                !1 === Hf.isClockWise(c) && (c = c.reverse());
                for (let t = 0, e = h.length; t < e; t++) {
                    const e = h[t];
                    !0 === Hf.isClockWise(e) && (h[t] = e.reverse())
                }
                const u = Hf.triangulateShape(c, h);
                for (let t = 0, e = h.length; t < e; t++) {
                    const e = h[t];
                    c = c.concat(e)
                }
                for (let t = 0, e = c.length; t < e; t++) {
                    const e = c[t];
                    i.push(e.x, e.y, 0),
                    r.push(0, 0, 1),
                    s.push(e.x, e.y)
                }
                for (let t = 0, e = u.length; t < e; t++) {
                    const e = u[t]
                      , i = e[0] + o
                      , r = e[1] + o
                      , s = e[2] + o;
                    n.push(i, r, s),
                    a += 3
                }
            }
            this.setIndex(n),
            this.setAttribute("position", new mc(i,3)),
            this.setAttribute("normal", new mc(r,3)),
            this.setAttribute("uv", new mc(s,2))
        }
        toJSON() {
            const t = super.toJSON();
            return function(t, e) {
                if (e.shapes = [],
                Array.isArray(t))
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.shapes.push(i.uuid)
                    }
                else
                    e.shapes.push(t.uuid);
                return e
            }(this.parameters.shapes, t)
        }
        static fromJSON(t, e) {
            const n = [];
            for (let i = 0, r = t.shapes.length; i < r; i++) {
                const r = e[t.shapes[i]];
                n.push(r)
            }
            return new Xf(n,t.curveSegments)
        }
    }
    class qf extends Mc {
        constructor(t=1, e=32, n=16, i=0, r=2 * Math.PI, s=0, o=Math.PI) {
            super(),
            this.type = "SphereGeometry",
            this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: s,
                thetaLength: o
            },
            e = Math.max(3, Math.floor(e)),
            n = Math.max(2, Math.floor(n));
            const a = Math.min(s + o, Math.PI);
            let l = 0;
            const c = []
              , h = new Ua
              , u = new Ua
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let d = 0; d <= n; d++) {
                const g = []
                  , v = d / n;
                let y = 0;
                0 == d && 0 == s ? y = .5 / e : d == n && a == Math.PI && (y = -.5 / e);
                for (let n = 0; n <= e; n++) {
                    const a = n / e;
                    h.x = -t * Math.cos(i + a * r) * Math.sin(s + v * o),
                    h.y = t * Math.cos(s + v * o),
                    h.z = t * Math.sin(i + a * r) * Math.sin(s + v * o),
                    p.push(h.x, h.y, h.z),
                    u.copy(h).normalize(),
                    f.push(u.x, u.y, u.z),
                    m.push(a + y, 1 - v),
                    g.push(l++)
                }
                c.push(g)
            }
            for (let t = 0; t < n; t++)
                for (let i = 0; i < e; i++) {
                    const e = c[t][i + 1]
                      , r = c[t][i]
                      , o = c[t + 1][i]
                      , l = c[t + 1][i + 1];
                    (0 !== t || s > 0) && d.push(e, r, l),
                    (t !== n - 1 || a < Math.PI) && d.push(r, o, l)
                }
            this.setIndex(d),
            this.setAttribute("position", new mc(p,3)),
            this.setAttribute("normal", new mc(f,3)),
            this.setAttribute("uv", new mc(m,2))
        }
        static fromJSON(t) {
            return new qf(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)
        }
    }
    (class extends ec {
        constructor(t) {
            super(),
            this.type = "ShadowMaterial",
            this.color = new lc(0),
            this.transparent = !0,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this
        }
    }
    ).prototype.isShadowMaterial = !0;
    class Yf extends ec {
        constructor(t) {
            super(),
            this.defines = {
                STANDARD: ""
            },
            this.type = "MeshStandardMaterial",
            this.color = new lc(16777215),
            this.roughness = 1,
            this.metalness = 0,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new lc(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = 0,
            this.normalScale = new Ea(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.roughnessMap = null,
            this.metalnessMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.envMapIntensity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.defines = {
                STANDARD: ""
            },
            this.color.copy(t.color),
            this.roughness = t.roughness,
            this.metalness = t.metalness,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.roughnessMap = t.roughnessMap,
            this.metalnessMap = t.metalnessMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.envMapIntensity = t.envMapIntensity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.flatShading = t.flatShading,
            this
        }
    }
    Yf.prototype.isMeshStandardMaterial = !0;
    class Zf extends Yf {
        constructor(t) {
            super(),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.type = "MeshPhysicalMaterial",
            this.clearcoatMap = null,
            this.clearcoatRoughness = 0,
            this.clearcoatRoughnessMap = null,
            this.clearcoatNormalScale = new Ea(1,1),
            this.clearcoatNormalMap = null,
            this.ior = 1.5,
            Object.defineProperty(this, "reflectivity", {
                get: function() {
                    return _a(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                },
                set: function(t) {
                    this.ior = (1 + .4 * t) / (1 - .4 * t)
                }
            }),
            this.sheenColor = new lc(0),
            this.sheenColorMap = null,
            this.sheenRoughness = 1,
            this.sheenRoughnessMap = null,
            this.transmissionMap = null,
            this.thickness = .01,
            this.thicknessMap = null,
            this.attenuationDistance = 0,
            this.attenuationColor = new lc(1,1,1),
            this.specularIntensity = 1,
            this.specularIntensityMap = null,
            this.specularColor = new lc(1,1,1),
            this.specularColorMap = null,
            this._sheen = 0,
            this._clearcoat = 0,
            this._transmission = 0,
            this.setValues(t)
        }
        get sheen() {
            return this._sheen
        }
        set sheen(t) {
            this._sheen > 0 != t > 0 && this.version++,
            this._sheen = t
        }
        get clearcoat() {
            return this._clearcoat
        }
        set clearcoat(t) {
            this._clearcoat > 0 != t > 0 && this.version++,
            this._clearcoat = t
        }
        get transmission() {
            return this._transmission
        }
        set transmission(t) {
            this._transmission > 0 != t > 0 && this.version++,
            this._transmission = t
        }
        copy(t) {
            return super.copy(t),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.clearcoat = t.clearcoat,
            this.clearcoatMap = t.clearcoatMap,
            this.clearcoatRoughness = t.clearcoatRoughness,
            this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
            this.clearcoatNormalMap = t.clearcoatNormalMap,
            this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
            this.ior = t.ior,
            this.sheen = t.sheen,
            this.sheenColor.copy(t.sheenColor),
            this.sheenColorMap = t.sheenColorMap,
            this.sheenRoughness = t.sheenRoughness,
            this.sheenRoughnessMap = t.sheenRoughnessMap,
            this.transmission = t.transmission,
            this.transmissionMap = t.transmissionMap,
            this.thickness = t.thickness,
            this.thicknessMap = t.thicknessMap,
            this.attenuationDistance = t.attenuationDistance,
            this.attenuationColor.copy(t.attenuationColor),
            this.specularIntensity = t.specularIntensity,
            this.specularIntensityMap = t.specularIntensityMap,
            this.specularColor.copy(t.specularColor),
            this.specularColorMap = t.specularColorMap,
            this
        }
    }
    Zf.prototype.isMeshPhysicalMaterial = !0;
    (class extends ec {
        constructor(t) {
            super(),
            this.type = "MeshPhongMaterial",
            this.color = new lc(16777215),
            this.specular = new lc(1118481),
            this.shininess = 30,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new lc(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = 0,
            this.normalScale = new Ea(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = 0,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            this.shininess = t.shininess,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.flatShading = t.flatShading,
            this
        }
    }
    ).prototype.isMeshPhongMaterial = !0;
    (class extends ec {
        constructor(t) {
            super(),
            this.defines = {
                TOON: ""
            },
            this.type = "MeshToonMaterial",
            this.color = new lc(16777215),
            this.map = null,
            this.gradientMap = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new lc(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = 0,
            this.normalScale = new Ea(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.alphaMap = null,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.gradientMap = t.gradientMap,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.alphaMap = t.alphaMap,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this
        }
    }
    ).prototype.isMeshToonMaterial = !0;
    (class extends ec {
        constructor(t) {
            super(),
            this.type = "MeshNormalMaterial",
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = 0,
            this.normalScale = new Ea(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.flatShading = t.flatShading,
            this
        }
    }
    ).prototype.isMeshNormalMaterial = !0;
    (class extends ec {
        constructor(t) {
            super(),
            this.type = "MeshLambertMaterial",
            this.color = new lc(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new lc(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = 0,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this
        }
    }
    ).prototype.isMeshLambertMaterial = !0;
    (class extends ec {
        constructor(t) {
            super(),
            this.defines = {
                MATCAP: ""
            },
            this.type = "MeshMatcapMaterial",
            this.color = new lc(16777215),
            this.matcap = null,
            this.map = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalMapType = 0,
            this.normalScale = new Ea(1,1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.alphaMap = null,
            this.flatShading = !1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.defines = {
                MATCAP: ""
            },
            this.color.copy(t.color),
            this.matcap = t.matcap,
            this.map = t.map,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalMapType = t.normalMapType,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.alphaMap = t.alphaMap,
            this.flatShading = t.flatShading,
            this
        }
    }
    ).prototype.isMeshMatcapMaterial = !0;
    (class extends Lp {
        constructor(t) {
            super(),
            this.type = "LineDashedMaterial",
            this.scale = 1,
            this.dashSize = 3,
            this.gapSize = 1,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.scale = t.scale,
            this.dashSize = t.dashSize,
            this.gapSize = t.gapSize,
            this
        }
    }
    ).prototype.isLineDashedMaterial = !0;
    const Jf = {
        arraySlice: function(t, e, n) {
            return Jf.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            const e = t.length
              , n = new Array(e);
            for (let t = 0; t !== e; ++t)
                n[t] = t;
            return n.sort((function(e, n) {
                return t[e] - t[n]
            }
            )),
            n
        },
        sortedArray: function(t, e, n) {
            const i = t.length
              , r = new t.constructor(i);
            for (let s = 0, o = 0; o !== i; ++s) {
                const i = n[s] * e;
                for (let n = 0; n !== e; ++n)
                    r[o++] = t[i + n]
            }
            return r
        },
        flattenJSON: function(t, e, n, i) {
            let r = 1
              , s = t[0];
            for (; void 0 !== s && void 0 === s[i]; )
                s = t[r++];
            if (void 0 === s)
                return;
            let o = s[i];
            if (void 0 !== o)
                if (Array.isArray(o))
                    do {
                        o = s[i],
                        void 0 !== o && (e.push(s.time),
                        n.push.apply(n, o)),
                        s = t[r++]
                    } while (void 0 !== s);
                else if (void 0 !== o.toArray)
                    do {
                        o = s[i],
                        void 0 !== o && (e.push(s.time),
                        o.toArray(n, n.length)),
                        s = t[r++]
                    } while (void 0 !== s);
                else
                    do {
                        o = s[i],
                        void 0 !== o && (e.push(s.time),
                        n.push(o)),
                        s = t[r++]
                    } while (void 0 !== s)
        },
        subclip: function(t, e, n, i, r=30) {
            const s = t.clone();
            s.name = e;
            const o = [];
            for (let t = 0; t < s.tracks.length; ++t) {
                const e = s.tracks[t]
                  , a = e.getValueSize()
                  , l = []
                  , c = [];
                for (let t = 0; t < e.times.length; ++t) {
                    const s = e.times[t] * r;
                    if (!(s < n || s >= i)) {
                        l.push(e.times[t]);
                        for (let n = 0; n < a; ++n)
                            c.push(e.values[t * a + n])
                    }
                }
                0 !== l.length && (e.times = Jf.convertArray(l, e.times.constructor),
                e.values = Jf.convertArray(c, e.values.constructor),
                o.push(e))
            }
            s.tracks = o;
            let a = 1 / 0;
            for (let t = 0; t < s.tracks.length; ++t)
                a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
            for (let t = 0; t < s.tracks.length; ++t)
                s.tracks[t].shift(-1 * a);
            return s.resetDuration(),
            s
        },
        makeClipAdditive: function(t, e=0, n=t, i=30) {
            i <= 0 && (i = 30);
            const r = n.tracks.length
              , s = e / i;
            for (let e = 0; e < r; ++e) {
                const i = n.tracks[e]
                  , r = i.ValueTypeName;
                if ("bool" === r || "string" === r)
                    continue;
                const o = t.tracks.find((function(t) {
                    return t.name === i.name && t.ValueTypeName === r
                }
                ));
                if (void 0 === o)
                    continue;
                let a = 0;
                const l = i.getValueSize();
                i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                let c = 0;
                const h = o.getValueSize();
                o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                const u = i.times.length - 1;
                let d;
                if (s <= i.times[0]) {
                    const t = a
                      , e = l - a;
                    d = Jf.arraySlice(i.values, t, e)
                } else if (s >= i.times[u]) {
                    const t = u * l + a
                      , e = t + l - a;
                    d = Jf.arraySlice(i.values, t, e)
                } else {
                    const t = i.createInterpolant()
                      , e = a
                      , n = l - a;
                    t.evaluate(s),
                    d = Jf.arraySlice(t.resultBuffer, e, n)
                }
                "quaternion" === r && (new Fa).fromArray(d).normalize().conjugate().toArray(d);
                const p = o.times.length;
                for (let t = 0; t < p; ++t) {
                    const e = t * h + c;
                    if ("quaternion" === r)
                        Fa.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                    else {
                        const t = h - 2 * c;
                        for (let n = 0; n < t; ++n)
                            o.values[e + n] -= d[n]
                    }
                }
            }
            return t.blendMode = 2501,
            t
        }
    };
    class Kf {
        constructor(t, e, n, i) {
            this.parameterPositions = t,
            this._cachedIndex = 0,
            this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
            this.sampleValues = e,
            this.valueSize = n,
            this.settings = null,
            this.DefaultSettings_ = {}
        }
        evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex
              , i = e[n]
              , r = e[n - 1];
            t: {
                e: {
                    let s;
                    n: {
                        i: if (!(t < i)) {
                            for (let s = n + 2; ; ) {
                                if (void 0 === i) {
                                    if (t < r)
                                        break i;
                                    return n = e.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, t, r)
                                }
                                if (n === s)
                                    break;
                                if (r = i,
                                i = e[++n],
                                t < i)
                                    break e
                            }
                            s = e.length;
                            break n
                        }
                        if (t >= r)
                            break t;
                        {
                            const o = e[1];
                            t < o && (n = 2,
                            r = o);
                            for (let s = n - 2; ; ) {
                                if (void 0 === r)
                                    return this._cachedIndex = 0,
                                    this.beforeStart_(0, t, i);
                                if (n === s)
                                    break;
                                if (i = r,
                                r = e[--n - 1],
                                t >= r)
                                    break e
                            }
                            s = n,
                            n = 0
                        }
                    }
                    for (; n < s; ) {
                        const i = n + s >>> 1;
                        t < e[i] ? s = i : n = i + 1
                    }
                    if (i = e[n],
                    r = e[n - 1],
                    void 0 === r)
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, i);
                    if (void 0 === i)
                        return n = e.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(t) {
            const e = this.resultBuffer
              , n = this.sampleValues
              , i = this.valueSize
              , r = t * i;
            for (let t = 0; t !== i; ++t)
                e[t] = n[r + t];
            return e
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() {}
    }
    Kf.prototype.beforeStart_ = Kf.prototype.copySampleValue_,
    Kf.prototype.afterEnd_ = Kf.prototype.copySampleValue_;
    class Qf extends Kf {
        constructor(t, e, n, i) {
            super(t, e, n, i),
            this._weightPrev = -0,
            this._offsetPrev = -0,
            this._weightNext = -0,
            this._offsetNext = -0,
            this.DefaultSettings_ = {
                endingStart: ea,
                endingEnd: ea
            }
        }
        intervalChanged_(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2
              , s = t + 1
              , o = i[r]
              , a = i[s];
            if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                case na:
                    r = t,
                    o = 2 * e - n;
                    break;
                case ia:
                    r = i.length - 2,
                    o = e + i[r] - i[r + 1];
                    break;
                default:
                    r = t,
                    o = n
                }
            if (void 0 === a)
                switch (this.getSettings_().endingEnd) {
                case na:
                    s = t,
                    a = 2 * n - e;
                    break;
                case ia:
                    s = 1,
                    a = n + i[1] - i[0];
                    break;
                default:
                    s = t - 1,
                    a = e
                }
            const l = .5 * (n - e)
              , c = this.valueSize;
            this._weightPrev = l / (e - o),
            this._weightNext = l / (a - n),
            this._offsetPrev = r * c,
            this._offsetNext = s * c
        }
        interpolate_(t, e, n, i) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , o = this.valueSize
              , a = t * o
              , l = a - o
              , c = this._offsetPrev
              , h = this._offsetNext
              , u = this._weightPrev
              , d = this._weightNext
              , p = (n - e) / (i - e)
              , f = p * p
              , m = f * p
              , g = -u * m + 2 * u * f - u * p
              , v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1
              , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
              , _ = d * m - d * f;
            for (let t = 0; t !== o; ++t)
                r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + _ * s[h + t];
            return r
        }
    }
    class $f extends Kf {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        interpolate_(t, e, n, i) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , o = this.valueSize
              , a = t * o
              , l = a - o
              , c = (n - e) / (i - e)
              , h = 1 - c;
            for (let t = 0; t !== o; ++t)
                r[t] = s[l + t] * h + s[a + t] * c;
            return r
        }
    }
    class tm extends Kf {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        interpolate_(t) {
            return this.copySampleValue_(t - 1)
        }
    }
    class em {
        constructor(t, e, n, i) {
            if (void 0 === t)
                throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
                throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t,
            this.times = Jf.convertArray(e, this.TimeBufferType),
            this.values = Jf.convertArray(n, this.ValueBufferType),
            this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON)
                n = e.toJSON(t);
            else {
                n = {
                    name: t.name,
                    times: Jf.convertArray(t.times, Array),
                    values: Jf.convertArray(t.values, Array)
                };
                const e = t.getInterpolation();
                e !== t.DefaultInterpolation && (n.interpolation = e)
            }
            return n.type = t.ValueTypeName,
            n
        }
        InterpolantFactoryMethodDiscrete(t) {
            return new tm(this.times,this.values,this.getValueSize(),t)
        }
        InterpolantFactoryMethodLinear(t) {
            return new $f(this.times,this.values,this.getValueSize(),t)
        }
        InterpolantFactoryMethodSmooth(t) {
            return new Qf(this.times,this.values,this.getValueSize(),t)
        }
        setInterpolation(t) {
            let e;
            switch (t) {
            case Qo:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case $o:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case ta:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw new Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", e),
                this
            }
            return this.createInterpolant = e,
            this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return Qo;
            case this.InterpolantFactoryMethodLinear:
                return $o;
            case this.InterpolantFactoryMethodSmooth:
                return ta
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(t) {
            if (0 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n)
                    e[n] += t
            }
            return this
        }
        scale(t) {
            if (1 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n)
                    e[n] *= t
            }
            return this
        }
        trim(t, e) {
            const n = this.times
              , i = n.length;
            let r = 0
              , s = i - 1;
            for (; r !== i && n[r] < t; )
                ++r;
            for (; -1 !== s && n[s] > e; )
                --s;
            if (++s,
            0 !== r || s !== i) {
                r >= s && (s = Math.max(s, 1),
                r = s - 1);
                const t = this.getValueSize();
                this.times = Jf.arraySlice(n, r, s),
                this.values = Jf.arraySlice(this.values, r * t, s * t)
            }
            return this
        }
        validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            t = !1);
            const n = this.times
              , i = this.values
              , r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            t = !1);
            let s = null;
            for (let e = 0; e !== r; e++) {
                const i = n[e];
                if ("number" == typeof i && isNaN(i)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                    t = !1;
                    break
                }
                if (null !== s && s > i) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s),
                    t = !1;
                    break
                }
                s = i
            }
            if (void 0 !== i && Jf.isTypedArray(i))
                for (let e = 0, n = i.length; e !== n; ++e) {
                    const n = i[e];
                    if (isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                        t = !1;
                        break
                    }
                }
            return t
        }
        optimize() {
            const t = Jf.arraySlice(this.times)
              , e = Jf.arraySlice(this.values)
              , n = this.getValueSize()
              , i = this.getInterpolation() === ta
              , r = t.length - 1;
            let s = 1;
            for (let o = 1; o < r; ++o) {
                let r = !1;
                const a = t[o];
                if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                    if (i)
                        r = !0;
                    else {
                        const t = o * n
                          , i = t - n
                          , s = t + n;
                        for (let o = 0; o !== n; ++o) {
                            const n = e[t + o];
                            if (n !== e[i + o] || n !== e[s + o]) {
                                r = !0;
                                break
                            }
                        }
                    }
                if (r) {
                    if (o !== s) {
                        t[s] = t[o];
                        const i = o * n
                          , r = s * n;
                        for (let t = 0; t !== n; ++t)
                            e[r + t] = e[i + t]
                    }
                    ++s
                }
            }
            if (r > 0) {
                t[s] = t[r];
                for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
                    e[i + o] = e[t + o];
                ++s
            }
            return s !== t.length ? (this.times = Jf.arraySlice(t, 0, s),
            this.values = Jf.arraySlice(e, 0, s * n)) : (this.times = t,
            this.values = e),
            this
        }
        clone() {
            const t = Jf.arraySlice(this.times, 0)
              , e = Jf.arraySlice(this.values, 0)
              , n = new (0,
            this.constructor)(this.name,t,e);
            return n.createInterpolant = this.createInterpolant,
            n
        }
    }
    em.prototype.TimeBufferType = Float32Array,
    em.prototype.ValueBufferType = Float32Array,
    em.prototype.DefaultInterpolation = $o;
    class nm extends em {
    }
    nm.prototype.ValueTypeName = "bool",
    nm.prototype.ValueBufferType = Array,
    nm.prototype.DefaultInterpolation = Qo,
    nm.prototype.InterpolantFactoryMethodLinear = void 0,
    nm.prototype.InterpolantFactoryMethodSmooth = void 0;
    class im extends em {
    }
    im.prototype.ValueTypeName = "color";
    class rm extends em {
    }
    rm.prototype.ValueTypeName = "number";
    class sm extends Kf {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        interpolate_(t, e, n, i) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , o = this.valueSize
              , a = (n - e) / (i - e);
            let l = t * o;
            for (let t = l + o; l !== t; l += 4)
                Fa.slerpFlat(r, 0, s, l - o, s, l, a);
            return r
        }
    }
    class om extends em {
        InterpolantFactoryMethodLinear(t) {
            return new sm(this.times,this.values,this.getValueSize(),t)
        }
    }
    om.prototype.ValueTypeName = "quaternion",
    om.prototype.DefaultInterpolation = $o,
    om.prototype.InterpolantFactoryMethodSmooth = void 0;
    class am extends em {
    }
    am.prototype.ValueTypeName = "string",
    am.prototype.ValueBufferType = Array,
    am.prototype.DefaultInterpolation = Qo,
    am.prototype.InterpolantFactoryMethodLinear = void 0,
    am.prototype.InterpolantFactoryMethodSmooth = void 0;
    class lm extends em {
    }
    lm.prototype.ValueTypeName = "vector";
    class cm {
        constructor(t, e=-1, n, i=2500) {
            this.name = t,
            this.tracks = n,
            this.duration = e,
            this.blendMode = i,
            this.uuid = ya(),
            this.duration < 0 && this.resetDuration()
        }
        static parse(t) {
            const e = []
              , n = t.tracks
              , i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t)
                e.push(hm(n[t]).scale(i));
            const r = new this(t.name,t.duration,e,t.blendMode);
            return r.uuid = t.uuid,
            r
        }
        static toJSON(t) {
            const e = []
              , n = t.tracks
              , i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
            for (let t = 0, i = n.length; t !== i; ++t)
                e.push(em.toJSON(n[t]));
            return i
        }
        static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length
              , s = [];
            for (let t = 0; t < r; t++) {
                let o = []
                  , a = [];
                o.push((t + r - 1) % r, t, (t + 1) % r),
                a.push(0, 1, 0);
                const l = Jf.getKeyframeOrder(o);
                o = Jf.sortedArray(o, 1, l),
                a = Jf.sortedArray(a, 1, l),
                i || 0 !== o[0] || (o.push(r),
                a.push(a[0])),
                s.push(new rm(".morphTargetInfluences[" + e[t].name + "]",o,a).scale(1 / n))
            }
            return new this(t,-1,s)
        }
        static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
                const e = t;
                n = e.geometry && e.geometry.animations || e.animations
            }
            for (let t = 0; t < n.length; t++)
                if (n[t].name === e)
                    return n[t];
            return null
        }
        static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {}
              , r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e]
                  , s = n.name.match(r);
                if (s && s.length > 1) {
                    const t = s[1];
                    let e = i[t];
                    e || (i[t] = e = []),
                    e.push(n)
                }
            }
            const s = [];
            for (const t in i)
                s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
            return s
        }
        static parseAnimation(t, e) {
            if (!t)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            const n = function(t, e, n, i, r) {
                if (0 !== n.length) {
                    const s = []
                      , o = [];
                    Jf.flattenJSON(n, s, o, i),
                    0 !== s.length && r.push(new t(e,s,o))
                }
            }
              , i = []
              , r = t.name || "default"
              , s = t.fps || 30
              , o = t.blendMode;
            let a = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
                const r = l[t].keys;
                if (r && 0 !== r.length)
                    if (r[0].morphTargets) {
                        const t = {};
                        let e;
                        for (e = 0; e < r.length; e++)
                            if (r[e].morphTargets)
                                for (let n = 0; n < r[e].morphTargets.length; n++)
                                    t[r[e].morphTargets[n]] = -1;
                        for (const n in t) {
                            const t = []
                              , s = [];
                            for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                const i = r[e];
                                t.push(i.time),
                                s.push(i.morphTarget === n ? 1 : 0)
                            }
                            i.push(new rm(".morphTargetInfluence[" + n + "]",t,s))
                        }
                        a = t.length * (s || 1)
                    } else {
                        const s = ".bones[" + e[t].name + "]";
                        n(lm, s + ".position", r, "pos", i),
                        n(om, s + ".quaternion", r, "rot", i),
                        n(lm, s + ".scale", r, "scl", i)
                    }
            }
            return 0 === i.length ? null : new this(r,a,i,o)
        }
        resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                const n = this.tracks[e];
                t = Math.max(t, n.times[n.times.length - 1])
            }
            return this.duration = t,
            this
        }
        trim() {
            for (let t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        }
        validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
                t = t && this.tracks[e].validate();
            return t
        }
        optimize() {
            for (let t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        }
        clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
                t.push(this.tracks[e].clone());
            return new this.constructor(this.name,this.duration,t,this.blendMode)
        }
        toJSON() {
            return this.constructor.toJSON(this)
        }
    }
    function hm(t) {
        if (void 0 === t.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = function(t) {
            switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return rm;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return lm;
            case "color":
                return im;
            case "quaternion":
                return om;
            case "bool":
            case "boolean":
                return nm;
            case "string":
                return am
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            const e = []
              , n = [];
            Jf.flattenJSON(t.keys, e, n, "value"),
            t.times = e,
            t.values = n
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
    }
    const um = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    };
    class dm {
        constructor(t, e, n) {
            const i = this;
            let r, s = !1, o = 0, a = 0;
            const l = [];
            this.onStart = void 0,
            this.onLoad = t,
            this.onProgress = e,
            this.onError = n,
            this.itemStart = function(t) {
                a++,
                !1 === s && void 0 !== i.onStart && i.onStart(t, o, a),
                s = !0
            }
            ,
            this.itemEnd = function(t) {
                o++,
                void 0 !== i.onProgress && i.onProgress(t, o, a),
                o === a && (s = !1,
                void 0 !== i.onLoad && i.onLoad())
            }
            ,
            this.itemError = function(t) {
                void 0 !== i.onError && i.onError(t)
            }
            ,
            this.resolveURL = function(t) {
                return r ? r(t) : t
            }
            ,
            this.setURLModifier = function(t) {
                return r = t,
                this
            }
            ,
            this.addHandler = function(t, e) {
                return l.push(t, e),
                this
            }
            ,
            this.removeHandler = function(t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2),
                this
            }
            ,
            this.getHandler = function(t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                    const n = l[e]
                      , i = l[e + 1];
                    if (n.global && (n.lastIndex = 0),
                    n.test(t))
                        return i
                }
                return null
            }
        }
    }
    const pm = new dm;
    class fm {
        constructor(t) {
            this.manager = void 0 !== t ? t : pm,
            this.crossOrigin = "anonymous",
            this.withCredentials = !1,
            this.path = "",
            this.resourcePath = "",
            this.requestHeader = {}
        }
        load() {}
        loadAsync(t, e) {
            const n = this;
            return new Promise((function(i, r) {
                n.load(t, i, e, r)
            }
            ))
        }
        parse() {}
        setCrossOrigin(t) {
            return this.crossOrigin = t,
            this
        }
        setWithCredentials(t) {
            return this.withCredentials = t,
            this
        }
        setPath(t) {
            return this.path = t,
            this
        }
        setResourcePath(t) {
            return this.resourcePath = t,
            this
        }
        setRequestHeader(t) {
            return this.requestHeader = t,
            this
        }
    }
    const mm = {};
    class gm extends fm {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = um.get(t);
            if (void 0 !== r)
                return this.manager.itemStart(t),
                setTimeout((()=>{
                    e && e(r),
                    this.manager.itemEnd(t)
                }
                ), 0),
                r;
            if (void 0 !== mm[t])
                return void mm[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
            mm[t] = [],
            mm[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            });
            const s = new Request(t,{
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            });
            fetch(s).then((e=>{
                if (200 === e.status || 0 === e.status) {
                    0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                    const n = mm[t]
                      , i = e.body.getReader()
                      , r = e.headers.get("Content-Length")
                      , s = r ? parseInt(r) : 0
                      , o = 0 !== s;
                    let a = 0;
                    return new ReadableStream({
                        start(t) {
                            !function e() {
                                i.read().then((({done: i, value: r})=>{
                                    if (i)
                                        t.close();
                                    else {
                                        a += r.byteLength;
                                        const i = new ProgressEvent("progress",{
                                            lengthComputable: o,
                                            loaded: a,
                                            total: s
                                        });
                                        for (let t = 0, e = n.length; t < e; t++) {
                                            const e = n[t];
                                            e.onProgress && e.onProgress(i)
                                        }
                                        t.enqueue(r),
                                        e()
                                    }
                                }
                                ))
                            }()
                        }
                    })
                }
                throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
            }
            )).then((t=>{
                const e = new Response(t);
                switch (this.responseType) {
                case "arraybuffer":
                    return e.arrayBuffer();
                case "blob":
                    return e.blob();
                case "document":
                    return e.text().then((t=>(new DOMParser).parseFromString(t, this.mimeType)));
                case "json":
                    return e.json();
                default:
                    return e.text()
                }
            }
            )).then((e=>{
                um.add(t, e);
                const n = mm[t];
                delete mm[t];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onLoad && i.onLoad(e)
                }
                this.manager.itemEnd(t)
            }
            )).catch((e=>{
                const n = mm[t];
                delete mm[t];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onError && i.onError(e)
                }
                this.manager.itemError(t),
                this.manager.itemEnd(t)
            }
            )),
            this.manager.itemStart(t)
        }
        setResponseType(t) {
            return this.responseType = t,
            this
        }
        setMimeType(t) {
            return this.mimeType = t,
            this
        }
    }
    class vm extends fm {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , s = um.get(t);
            if (void 0 !== s)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(s),
                    r.manager.itemEnd(t)
                }
                ), 0),
                s;
            const o = La("img");
            function a() {
                c(),
                um.add(t, this),
                e && e(this),
                r.manager.itemEnd(t)
            }
            function l(e) {
                c(),
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            function c() {
                o.removeEventListener("load", a, !1),
                o.removeEventListener("error", l, !1)
            }
            return o.addEventListener("load", a, !1),
            o.addEventListener("error", l, !1),
            "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            o.src = t,
            o
        }
    }
    class ym extends fm {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            const r = new Qc
              , s = new vm(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            let o = 0;
            function a(n) {
                s.load(t[n], (function(t) {
                    r.images[n] = t,
                    o++,
                    6 === o && (r.needsUpdate = !0,
                    e && e(r))
                }
                ), void 0, i)
            }
            for (let e = 0; e < t.length; ++e)
                a(e);
            return r
        }
    }
    class _m extends fm {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            const r = this
              , s = new xp
              , o = new gm(this.manager);
            return o.setResponseType("arraybuffer"),
            o.setRequestHeader(this.requestHeader),
            o.setPath(this.path),
            o.setWithCredentials(r.withCredentials),
            o.load(t, (function(t) {
                const n = r.parse(t);
                n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width,
                s.image.height = n.height,
                s.image.data = n.data),
                s.wrapS = void 0 !== n.wrapS ? n.wrapS : ko,
                s.wrapT = void 0 !== n.wrapT ? n.wrapT : ko,
                s.magFilter = void 0 !== n.magFilter ? n.magFilter : Uo,
                s.minFilter = void 0 !== n.minFilter ? n.minFilter : Uo,
                s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.encoding && (s.encoding = n.encoding),
                void 0 !== n.flipY && (s.flipY = n.flipY),
                void 0 !== n.format && (s.format = n.format),
                void 0 !== n.type && (s.type = n.type),
                void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps,
                s.minFilter = Ho),
                1 === n.mipmapCount && (s.minFilter = Uo),
                void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                s.needsUpdate = !0,
                e && e(s, n))
            }
            ), n, i),
            s
        }
    }
    class xm extends fm {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            const r = new Oa
              , s = new vm(this.manager);
            return s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(t, (function(t) {
                r.image = t,
                r.needsUpdate = !0,
                void 0 !== e && e(r)
            }
            ), n, i),
            r
        }
    }
    class bm extends Vl {
        constructor(t, e=1) {
            super(),
            this.type = "Light",
            this.color = new lc(t),
            this.intensity = e
        }
        dispose() {}
        copy(t) {
            return super.copy(t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
        }
    }
    bm.prototype.isLight = !0;
    (class extends bm {
        constructor(t, e, n) {
            super(t, n),
            this.type = "HemisphereLight",
            this.position.copy(Vl.DefaultUp),
            this.updateMatrix(),
            this.groundColor = new lc(e)
        }
        copy(t) {
            return bm.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }
    ).prototype.isHemisphereLight = !0;
    const wm = new vl
      , Mm = new Ua
      , Sm = new Ua;
    class Tm {
        constructor(t) {
            this.camera = t,
            this.bias = 0,
            this.normalBias = 0,
            this.radius = 1,
            this.blurSamples = 8,
            this.mapSize = new Ea(512,512),
            this.map = null,
            this.mapPass = null,
            this.matrix = new vl,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this._frustum = new oh,
            this._frameExtents = new Ea(1,1),
            this._viewportCount = 1,
            this._viewports = [new Na(0,0,1,1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(t) {
            const e = this.camera
              , n = this.matrix;
            Mm.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(Mm),
            Sm.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(Sm),
            e.updateMatrixWorld(),
            wm.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(wm),
            n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse)
        }
        getViewport(t) {
            return this._viewports[t]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose()
        }
        copy(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }
    class Em extends Tm {
        constructor() {
            super(new Zc(50,1,.5,500)),
            this.focus = 1
        }
        updateMatrices(t) {
            const e = this.camera
              , n = 2 * ma * t.angle * this.focus
              , i = this.mapSize.width / this.mapSize.height
              , r = t.distance || e.far;
            n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
            e.aspect = i,
            e.far = r,
            e.updateProjectionMatrix()),
            super.updateMatrices(t)
        }
        copy(t) {
            return super.copy(t),
            this.focus = t.focus,
            this
        }
    }
    Em.prototype.isSpotLightShadow = !0;
    class Am extends bm {
        constructor(t, e, n=0, i=Math.PI / 3, r=0, s=1) {
            super(t, e),
            this.type = "SpotLight",
            this.position.copy(Vl.DefaultUp),
            this.updateMatrix(),
            this.target = new Vl,
            this.distance = n,
            this.angle = i,
            this.penumbra = r,
            this.decay = s,
            this.shadow = new Em
        }
        get power() {
            return this.intensity * Math.PI
        }
        set power(t) {
            this.intensity = t / Math.PI
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t) {
            return super.copy(t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }
    Am.prototype.isSpotLight = !0;
    const Rm = new vl
      , Lm = new Ua
      , Cm = new Ua;
    class Pm extends Tm {
        constructor() {
            super(new Zc(90,1,.5,500)),
            this._frameExtents = new Ea(4,2),
            this._viewportCount = 6,
            this._viewports = [new Na(2,1,1,1), new Na(0,1,1,1), new Na(3,1,1,1), new Na(1,1,1,1), new Na(3,0,1,1), new Na(1,0,1,1)],
            this._cubeDirections = [new Ua(1,0,0), new Ua(-1,0,0), new Ua(0,0,1), new Ua(0,0,-1), new Ua(0,1,0), new Ua(0,-1,0)],
            this._cubeUps = [new Ua(0,1,0), new Ua(0,1,0), new Ua(0,1,0), new Ua(0,1,0), new Ua(0,0,1), new Ua(0,0,-1)]
        }
        updateMatrices(t, e=0) {
            const n = this.camera
              , i = this.matrix
              , r = t.distance || n.far;
            r !== n.far && (n.far = r,
            n.updateProjectionMatrix()),
            Lm.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(Lm),
            Cm.copy(n.position),
            Cm.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(Cm),
            n.updateMatrixWorld(),
            i.makeTranslation(-Lm.x, -Lm.y, -Lm.z),
            Rm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Rm)
        }
    }
    Pm.prototype.isPointLightShadow = !0;
    class Dm extends bm {
        constructor(t, e, n=0, i=1) {
            super(t, e),
            this.type = "PointLight",
            this.distance = n,
            this.decay = i,
            this.shadow = new Pm
        }
        get power() {
            return 4 * this.intensity * Math.PI
        }
        set power(t) {
            this.intensity = t / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t) {
            return super.copy(t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }
    Dm.prototype.isPointLight = !0;
    class Im extends Tm {
        constructor() {
            super(new _h(-5,5,5,-5,.5,500))
        }
    }
    Im.prototype.isDirectionalLightShadow = !0;
    class Om extends bm {
        constructor(t, e) {
            super(t, e),
            this.type = "DirectionalLight",
            this.position.copy(Vl.DefaultUp),
            this.updateMatrix(),
            this.target = new Vl,
            this.shadow = new Im
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t) {
            return super.copy(t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }
    Om.prototype.isDirectionalLight = !0;
    (class extends bm {
        constructor(t, e) {
            super(t, e),
            this.type = "AmbientLight"
        }
    }
    ).prototype.isAmbientLight = !0;
    (class extends bm {
        constructor(t, e, n=10, i=10) {
            super(t, e),
            this.type = "RectAreaLight",
            this.width = n,
            this.height = i
        }
        get power() {
            return this.intensity * this.width * this.height * Math.PI
        }
        set power(t) {
            this.intensity = t / (this.width * this.height * Math.PI)
        }
        copy(t) {
            return super.copy(t),
            this.width = t.width,
            this.height = t.height,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.width = this.width,
            e.object.height = this.height,
            e
        }
    }
    ).prototype.isRectAreaLight = !0;
    class km {
        constructor() {
            this.coefficients = [];
            for (let t = 0; t < 9; t++)
                this.coefficients.push(new Ua)
        }
        set(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].copy(t[e]);
            return this
        }
        zero() {
            for (let t = 0; t < 9; t++)
                this.coefficients[t].set(0, 0, 0);
            return this
        }
        getAt(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z
              , s = this.coefficients;
            return e.copy(s[0]).multiplyScalar(.282095),
            e.addScaledVector(s[1], .488603 * i),
            e.addScaledVector(s[2], .488603 * r),
            e.addScaledVector(s[3], .488603 * n),
            e.addScaledVector(s[4], n * i * 1.092548),
            e.addScaledVector(s[5], i * r * 1.092548),
            e.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
            e.addScaledVector(s[7], n * r * 1.092548),
            e.addScaledVector(s[8], .546274 * (n * n - i * i)),
            e
        }
        getIrradianceAt(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z
              , s = this.coefficients;
            return e.copy(s[0]).multiplyScalar(.886227),
            e.addScaledVector(s[1], 1.023328 * i),
            e.addScaledVector(s[2], 1.023328 * r),
            e.addScaledVector(s[3], 1.023328 * n),
            e.addScaledVector(s[4], .858086 * n * i),
            e.addScaledVector(s[5], .858086 * i * r),
            e.addScaledVector(s[6], .743125 * r * r - .247708),
            e.addScaledVector(s[7], .858086 * n * r),
            e.addScaledVector(s[8], .429043 * (n * n - i * i)),
            e
        }
        add(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].add(t.coefficients[e]);
            return this
        }
        addScaledSH(t, e) {
            for (let n = 0; n < 9; n++)
                this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this
        }
        scale(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].multiplyScalar(t);
            return this
        }
        lerp(t, e) {
            for (let n = 0; n < 9; n++)
                this.coefficients[n].lerp(t.coefficients[n], e);
            return this
        }
        equals(t) {
            for (let e = 0; e < 9; e++)
                if (!this.coefficients[e].equals(t.coefficients[e]))
                    return !1;
            return !0
        }
        copy(t) {
            return this.set(t.coefficients)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        fromArray(t, e=0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++)
                n[i].fromArray(t, e + 3 * i);
            return this
        }
        toArray(t=[], e=0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++)
                n[i].toArray(t, e + 3 * i);
            return t
        }
        static getBasisAt(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z;
            e[0] = .282095,
            e[1] = .488603 * i,
            e[2] = .488603 * r,
            e[3] = .488603 * n,
            e[4] = 1.092548 * n * i,
            e[5] = 1.092548 * i * r,
            e[6] = .315392 * (3 * r * r - 1),
            e[7] = 1.092548 * n * r,
            e[8] = .546274 * (n * n - i * i)
        }
    }
    km.prototype.isSphericalHarmonics3 = !0;
    class Nm extends bm {
        constructor(t=new km, e=1) {
            super(void 0, e),
            this.sh = t
        }
        copy(t) {
            return super.copy(t),
            this.sh.copy(t.sh),
            this
        }
        fromJSON(t) {
            return this.intensity = t.intensity,
            this.sh.fromArray(t.sh),
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.sh = this.sh.toArray(),
            e
        }
    }
    Nm.prototype.isLightProbe = !0;
    class zm {
        static decodeText(t) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(t);
            let e = "";
            for (let n = 0, i = t.length; n < i; n++)
                e += String.fromCharCode(t[n]);
            try {
                return decodeURIComponent(escape(e))
            } catch (t) {
                return e
            }
        }
        static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
        static resolveURL(t, e) {
            return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
        }
    }
    (class extends Mc {
        constructor() {
            super(),
            this.type = "InstancedBufferGeometry",
            this.instanceCount = 1 / 0
        }
        copy(t) {
            return super.copy(t),
            this.instanceCount = t.instanceCount,
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const t = super.toJSON(this);
            return t.instanceCount = this.instanceCount,
            t.isInstancedBufferGeometry = !0,
            t
        }
    }
    ).prototype.isInstancedBufferGeometry = !0;
    class Bm extends fm {
        constructor(t) {
            super(t),
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
            "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            this.options = {
                premultiplyAlpha: "none"
            }
        }
        setOptions(t) {
            return this.options = t,
            this
        }
        load(t, e, n, i) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , s = um.get(t);
            if (void 0 !== s)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(s),
                    r.manager.itemEnd(t)
                }
                ), 0),
                s;
            const o = {};
            o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
            o.headers = this.requestHeader,
            fetch(t, o).then((function(t) {
                return t.blob()
            }
            )).then((function(t) {
                return createImageBitmap(t, Object.assign(r.options, {
                    colorSpaceConversion: "none"
                }))
            }
            )).then((function(n) {
                um.add(t, n),
                e && e(n),
                r.manager.itemEnd(t)
            }
            )).catch((function(e) {
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            )),
            r.manager.itemStart(t)
        }
    }
    let Fm;
    Bm.prototype.isImageBitmapLoader = !0;
    const Um = function() {
        return void 0 === Fm && (Fm = new (window.AudioContext || window.webkitAudioContext)),
        Fm
    };
    class Hm extends fm {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            const r = this
              , s = new gm(this.manager);
            s.setResponseType("arraybuffer"),
            s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(t, (function(n) {
                try {
                    const t = n.slice(0);
                    Um().decodeAudioData(t, (function(t) {
                        e(t)
                    }
                    ))
                } catch (e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t)
                }
            }
            ), n, i)
        }
    }
    (class extends Nm {
        constructor(t, e, n=1) {
            super(void 0, n);
            const i = (new lc).set(t)
              , r = (new lc).set(e)
              , s = new Ua(i.r,i.g,i.b)
              , o = new Ua(r.r,r.g,r.b)
              , a = Math.sqrt(Math.PI)
              , l = a * Math.sqrt(.75);
            this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
            this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
        }
    }
    ).prototype.isHemisphereLightProbe = !0,
    class extends Nm {
        constructor(t, e=1) {
            super(void 0, e);
            const n = (new lc).set(t);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
    }
    .prototype.isAmbientLightProbe = !0;
    class Vm {
        constructor(t=!0) {
            this.autoStart = t,
            this.startTime = 0,
            this.oldTime = 0,
            this.elapsedTime = 0,
            this.running = !1
        }
        start() {
            this.startTime = Gm(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        }
        stop() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        }
        getElapsedTime() {
            return this.getDelta(),
            this.elapsedTime
        }
        getDelta() {
            let t = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                const e = Gm();
                t = (e - this.oldTime) / 1e3,
                this.oldTime = e,
                this.elapsedTime += t
            }
            return t
        }
    }
    function Gm() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }
    const Wm = new Ua
      , jm = new Fa
      , Xm = new Ua
      , qm = new Ua;
    class Ym extends Vl {
        constructor() {
            super(),
            this.type = "AudioListener",
            this.context = Um(),
            this.gain = this.context.createGain(),
            this.gain.connect(this.context.destination),
            this.filter = null,
            this.timeDelta = 0,
            this._clock = new Vm
        }
        getInput() {
            return this.gain
        }
        removeFilter() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        }
        getFilter() {
            return this.filter
        }
        setFilter(t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        }
        getMasterVolume() {
            return this.gain.gain.value
        }
        setMasterVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t);
            const e = this.context.listener
              , n = this.up;
            if (this.timeDelta = this._clock.getDelta(),
            this.matrixWorld.decompose(Wm, jm, Xm),
            qm.set(0, 0, -1).applyQuaternion(jm),
            e.positionX) {
                const t = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(Wm.x, t),
                e.positionY.linearRampToValueAtTime(Wm.y, t),
                e.positionZ.linearRampToValueAtTime(Wm.z, t),
                e.forwardX.linearRampToValueAtTime(qm.x, t),
                e.forwardY.linearRampToValueAtTime(qm.y, t),
                e.forwardZ.linearRampToValueAtTime(qm.z, t),
                e.upX.linearRampToValueAtTime(n.x, t),
                e.upY.linearRampToValueAtTime(n.y, t),
                e.upZ.linearRampToValueAtTime(n.z, t)
            } else
                e.setPosition(Wm.x, Wm.y, Wm.z),
                e.setOrientation(qm.x, qm.y, qm.z, n.x, n.y, n.z)
        }
    }
    class Zm extends Vl {
        constructor(t) {
            super(),
            this.type = "Audio",
            this.listener = t,
            this.context = t.context,
            this.gain = this.context.createGain(),
            this.gain.connect(t.getInput()),
            this.autoplay = !1,
            this.buffer = null,
            this.detune = 0,
            this.loop = !1,
            this.loopStart = 0,
            this.loopEnd = 0,
            this.offset = 0,
            this.duration = void 0,
            this.playbackRate = 1,
            this.isPlaying = !1,
            this.hasPlaybackControl = !0,
            this.source = null,
            this.sourceType = "empty",
            this._startedAt = 0,
            this._progress = 0,
            this._connected = !1,
            this.filters = []
        }
        getOutput() {
            return this.gain
        }
        setNodeSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        }
        setMediaElementSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(t),
            this.connect(),
            this
        }
        setMediaStreamSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaStreamNode",
            this.source = this.context.createMediaStreamSource(t),
            this.connect(),
            this
        }
        setBuffer(t) {
            return this.buffer = t,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        }
        play(t=0) {
            if (!0 === this.isPlaying)
                return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl)
                return void console.warn("THREE.Audio: this Audio has no playback control.");
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return e.buffer = this.buffer,
            e.loop = this.loop,
            e.loopStart = this.loopStart,
            e.loopEnd = this.loopEnd,
            e.onended = this.onEnded.bind(this),
            e.start(this._startedAt, this._progress + this.offset, this.duration),
            this.isPlaying = !0,
            this.source = e,
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
        }
        pause() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        stop() {
            if (!1 !== this.hasPlaybackControl)
                return this._progress = 0,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this._connected = !0,
            this
        }
        disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
        getFilters() {
            return this.filters
        }
        setFilters(t) {
            return t || (t = []),
            !0 === this._connected ? (this.disconnect(),
            this.filters = t.slice(),
            this.connect()) : this.filters = t.slice(),
            this
        }
        setDetune(t) {
            if (this.detune = t,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        }
        getDetune() {
            return this.detune
        }
        getFilter() {
            return this.getFilters()[0]
        }
        setFilter(t) {
            return this.setFilters(t ? [t] : [])
        }
        setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        getPlaybackRate() {
            return this.playbackRate
        }
        onEnded() {
            this.isPlaying = !1
        }
        getLoop() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        }
        setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        setLoopStart(t) {
            return this.loopStart = t,
            this
        }
        setLoopEnd(t) {
            return this.loopEnd = t,
            this
        }
        getVolume() {
            return this.gain.gain.value
        }
        setVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
    }
    class Jm {
        constructor(t, e, n) {
            let i, r, s;
            switch (this.binding = t,
            this.valueSize = n,
            e) {
            case "quaternion":
                i = this._slerp,
                r = this._slerpAdditive,
                s = this._setAdditiveIdentityQuaternion,
                this.buffer = new Float64Array(6 * n),
                this._workIndex = 5;
                break;
            case "string":
            case "bool":
                i = this._select,
                r = this._select,
                s = this._setAdditiveIdentityOther,
                this.buffer = new Array(5 * n);
                break;
            default:
                i = this._lerp,
                r = this._lerpAdditive,
                s = this._setAdditiveIdentityNumeric,
                this.buffer = new Float64Array(5 * n)
            }
            this._mixBufferRegion = i,
            this._mixBufferRegionAdditive = r,
            this._setIdentity = s,
            this._origIndex = 3,
            this._addIndex = 4,
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            this.useCount = 0,
            this.referenceCount = 0
        }
        accumulate(t, e) {
            const n = this.buffer
              , i = this.valueSize
              , r = t * i + i;
            let s = this.cumulativeWeight;
            if (0 === s) {
                for (let t = 0; t !== i; ++t)
                    n[r + t] = n[t];
                s = e
            } else {
                s += e;
                const t = e / s;
                this._mixBufferRegion(n, r, 0, t, i)
            }
            this.cumulativeWeight = s
        }
        accumulateAdditive(t) {
            const e = this.buffer
              , n = this.valueSize
              , i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, i, 0, t, n),
            this.cumulativeWeightAdditive += t
        }
        apply(t) {
            const e = this.valueSize
              , n = this.buffer
              , i = t * e + e
              , r = this.cumulativeWeight
              , s = this.cumulativeWeightAdditive
              , o = this.binding;
            if (this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            r < 1) {
                const t = e * this._origIndex;
                this._mixBufferRegion(n, i, t, 1 - r, e)
            }
            s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
                if (n[t] !== n[t + e]) {
                    o.setValue(n, i);
                    break
                }
        }
        saveOriginalState() {
            const t = this.binding
              , e = this.buffer
              , n = this.valueSize
              , i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t)
                e[t] = e[i + t % n];
            this._setIdentity(),
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0
        }
        restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        }
        _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize
              , e = t + this.valueSize;
            for (let n = t; n < e; n++)
                this.buffer[n] = 0
        }
        _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
            this.buffer[this._addIndex * this.valueSize + 3] = 1
        }
        _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize
              , e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
                this.buffer[e + n] = this.buffer[t + n]
        }
        _select(t, e, n, i, r) {
            if (i >= .5)
                for (let i = 0; i !== r; ++i)
                    t[e + i] = t[n + i]
        }
        _slerp(t, e, n, i) {
            Fa.slerpFlat(t, e, t, e, t, n, i)
        }
        _slerpAdditive(t, e, n, i, r) {
            const s = this._workIndex * r;
            Fa.multiplyQuaternionsFlat(t, s, t, e, t, n),
            Fa.slerpFlat(t, e, t, e, t, s, i)
        }
        _lerp(t, e, n, i, r) {
            const s = 1 - i;
            for (let o = 0; o !== r; ++o) {
                const r = e + o;
                t[r] = t[r] * s + t[n + o] * i
            }
        }
        _lerpAdditive(t, e, n, i, r) {
            for (let s = 0; s !== r; ++s) {
                const r = e + s;
                t[r] = t[r] + t[n + s] * i
            }
        }
    }
    const Km = new RegExp("[\\[\\]\\.:\\/]","g")
      , Qm = "[^\\[\\]\\.:\\/]"
      , $m = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
      , tg = /((?:WC+[\/:])*)/.source.replace("WC", Qm)
      , eg = /(WCOD+)?/.source.replace("WCOD", $m)
      , ng = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Qm)
      , ig = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Qm)
      , rg = new RegExp("^" + tg + eg + ng + ig + "$")
      , sg = ["material", "materials", "bones"];
    class og {
        constructor(t, e, n) {
            this.path = e,
            this.parsedPath = n || og.parseTrackName(e),
            this.node = og.findNode(t, this.parsedPath.nodeName) || t,
            this.rootNode = t,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
        static create(t, e, n) {
            return t && t.isAnimationObjectGroup ? new og.Composite(t,e,n) : new og(t,e,n)
        }
        static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(Km, "")
        }
        static parseTrackName(t) {
            const e = rg.exec(t);
            if (!e)
                throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            }
              , i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const t = n.nodeName.substring(i + 1);
                -1 !== sg.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                n.objectName = t)
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n
        }
        static findNode(t, e) {
            if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e);
                if (void 0 !== n)
                    return n
            }
            if (t.children) {
                const n = function(t) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        if (r.name === e || r.uuid === e)
                            return r;
                        const s = n(r.children);
                        if (s)
                            return s
                    }
                    return null
                }
                  , i = n(t.children);
                if (i)
                    return i
            }
            return null
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName]
        }
        _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                t[e++] = n[i]
        }
        _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        _setValue_direct_setNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++]
        }
        _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(t, e) {
            this.bind(),
            this.getValue(t, e)
        }
        _setValue_unbound(t, e) {
            this.bind(),
            this.setValue(t, e)
        }
        bind() {
            let t = this.node;
            const e = this.parsedPath
              , n = e.objectName
              , i = e.propertyName;
            let r = e.propertyIndex;
            if (t || (t = og.findNode(this.rootNode, e.nodeName) || this.rootNode,
            this.node = t),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            !t)
                return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (n) {
                let i = e.objectIndex;
                switch (n) {
                case "materials":
                    if (!t.material)
                        return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.materials)
                        return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    t = t.material.materials;
                    break;
                case "bones":
                    if (!t.skeleton)
                        return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    t = t.skeleton.bones;
                    for (let e = 0; e < t.length; e++)
                        if (t[e].name === i) {
                            i = e;
                            break
                        }
                    break;
                default:
                    if (void 0 === t[n])
                        return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    t = t[n]
                }
                if (void 0 !== i) {
                    if (void 0 === t[i])
                        return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    t = t[i]
                }
            }
            const s = t[i];
            if (void 0 === s) {
                const n = e.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
            }
            let o = this.Versioning.None;
            this.targetObject = t,
            void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
            let a = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!t.geometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!t.geometry.isBufferGeometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!t.geometry.morphAttributes)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                }
                a = this.BindingType.ArrayElement,
                this.resolvedProperty = s,
                this.propertyIndex = r
            } else
                void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray,
                this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray,
                this.resolvedProperty = s) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[a],
            this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
        }
        unbind() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }
    og.Composite = class {
        constructor(t, e, n) {
            const i = n || og.parseTrackName(e);
            this._targetGroup = t,
            this._bindings = t.subscribe_(e, i)
        }
        getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_
              , i = this._bindings[n];
            void 0 !== i && i.getValue(t, e)
        }
        setValue(t, e) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                n[i].setValue(t, e)
        }
        bind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].bind()
        }
        unbind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].unbind()
        }
    }
    ,
    og.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    og.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    og.prototype.GetterByBindingType = [og.prototype._getValue_direct, og.prototype._getValue_array, og.prototype._getValue_arrayElement, og.prototype._getValue_toArray],
    og.prototype.SetterByBindingTypeAndVersioning = [[og.prototype._setValue_direct, og.prototype._setValue_direct_setNeedsUpdate, og.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [og.prototype._setValue_array, og.prototype._setValue_array_setNeedsUpdate, og.prototype._setValue_array_setMatrixWorldNeedsUpdate], [og.prototype._setValue_arrayElement, og.prototype._setValue_arrayElement_setNeedsUpdate, og.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [og.prototype._setValue_fromArray, og.prototype._setValue_fromArray_setNeedsUpdate, og.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
    class ag {
        constructor(t, e, n=null, i=e.blendMode) {
            this._mixer = t,
            this._clip = e,
            this._localRoot = n,
            this.blendMode = i;
            const r = e.tracks
              , s = r.length
              , o = new Array(s)
              , a = {
                endingStart: ea,
                endingEnd: ea
            };
            for (let t = 0; t !== s; ++t) {
                const e = r[t].createInterpolant(null);
                o[t] = e,
                e.settings = a
            }
            this._interpolantSettings = a,
            this._interpolants = o,
            this._propertyBindings = new Array(s),
            this._cacheIndex = null,
            this._byClipCacheIndex = null,
            this._timeScaleInterpolant = null,
            this._weightInterpolant = null,
            this.loop = 2201,
            this._loopCount = -1,
            this._startTime = null,
            this.time = 0,
            this.timeScale = 1,
            this._effectiveTimeScale = 1,
            this.weight = 1,
            this._effectiveWeight = 1,
            this.repetitions = 1 / 0,
            this.paused = !1,
            this.enabled = !0,
            this.clampWhenFinished = !1,
            this.zeroSlopeAtStart = !0,
            this.zeroSlopeAtEnd = !0
        }
        play() {
            return this._mixer._activateAction(this),
            this
        }
        stop() {
            return this._mixer._deactivateAction(this),
            this.reset()
        }
        reset() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        }
        isRunning() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }
        isScheduled() {
            return this._mixer._isActiveAction(this)
        }
        startAt(t) {
            return this._startTime = t,
            this
        }
        setLoop(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        }
        setEffectiveWeight(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        }
        getEffectiveWeight() {
            return this._effectiveWeight
        }
        fadeIn(t) {
            return this._scheduleFading(t, 0, 1)
        }
        fadeOut(t) {
            return this._scheduleFading(t, 1, 0)
        }
        crossFadeFrom(t, e, n) {
            if (t.fadeOut(e),
            this.fadeIn(e),
            n) {
                const n = this._clip.duration
                  , i = t._clip.duration
                  , r = i / n
                  , s = n / i;
                t.warp(1, r, e),
                this.warp(s, 1, e)
            }
            return this
        }
        crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        }
        stopFading() {
            const t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        }
        setEffectiveTimeScale(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale
        }
        setDuration(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        }
        syncWith(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        }
        halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        }
        warp(t, e, n) {
            const i = this._mixer
              , r = i.time
              , s = this.timeScale;
            let o = this._timeScaleInterpolant;
            null === o && (o = i._lendControlInterpolant(),
            this._timeScaleInterpolant = o);
            const a = o.parameterPositions
              , l = o.sampleValues;
            return a[0] = r,
            a[1] = r + n,
            l[0] = t / s,
            l[1] = e / s,
            this
        }
        stopWarping() {
            const t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        }
        getMixer() {
            return this._mixer
        }
        getClip() {
            return this._clip
        }
        getRoot() {
            return this._localRoot || this._mixer._root
        }
        _update(t, e, n, i) {
            if (!this.enabled)
                return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
                const i = (t - r) * n;
                if (i < 0 || 0 === n)
                    return;
                this._startTime = null,
                e = n * i
            }
            e *= this._updateTimeScale(t);
            const s = this._updateTime(e)
              , o = this._updateWeight(t);
            if (o > 0) {
                const t = this._interpolants
                  , e = this._propertyBindings;
                if (2501 === this.blendMode)
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n].evaluate(s),
                        e[n].accumulateAdditive(o);
                else
                    for (let n = 0, r = t.length; n !== r; ++n)
                        t[n].evaluate(s),
                        e[n].accumulate(i, o)
            }
        }
        _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
                e = this.weight;
                const n = this._weightInterpolant;
                if (null !== n) {
                    const i = n.evaluate(t)[0];
                    e *= i,
                    t > n.parameterPositions[1] && (this.stopFading(),
                    0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e,
            e
        }
        _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
                e = this.timeScale;
                const n = this._timeScaleInterpolant;
                null !== n && (e *= n.evaluate(t)[0],
                t > n.parameterPositions[1] && (this.stopWarping(),
                0 === e ? this.paused = !0 : this.timeScale = e))
            }
            return this._effectiveTimeScale = e,
            e
        }
        _updateTime(t) {
            const e = this._clip.duration
              , n = this.loop;
            let i = this.time + t
              , r = this._loopCount;
            const s = 2202 === n;
            if (0 === t)
                return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
            if (2200 === n) {
                -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                t: {
                    if (i >= e)
                        i = e;
                    else {
                        if (!(i < 0)) {
                            this.time = i;
                            break t
                        }
                        i = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (t >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                i >= e || i < 0) {
                    const n = Math.floor(i / e);
                    i -= e * n,
                    r += Math.abs(n);
                    const o = this.repetitions - r;
                    if (o <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        i = t > 0 ? e : 0,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                    else {
                        if (1 === o) {
                            const e = t < 0;
                            this._setEndings(e, !e, s)
                        } else
                            this._setEndings(!1, !1, s);
                        this._loopCount = r,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: n
                        })
                    }
                } else
                    this.time = i;
                if (s && 1 == (1 & r))
                    return e - i
            }
            return i
        }
        _setEndings(t, e, n) {
            const i = this._interpolantSettings;
            n ? (i.endingStart = na,
            i.endingEnd = na) : (i.endingStart = t ? this.zeroSlopeAtStart ? na : ea : ia,
            i.endingEnd = e ? this.zeroSlopeAtEnd ? na : ea : ia)
        }
        _scheduleFading(t, e, n) {
            const i = this._mixer
              , r = i.time;
            let s = this._weightInterpolant;
            null === s && (s = i._lendControlInterpolant(),
            this._weightInterpolant = s);
            const o = s.parameterPositions
              , a = s.sampleValues;
            return o[0] = r,
            a[0] = e,
            o[1] = r + t,
            a[1] = n,
            this
        }
    }
    class lg extends da {
        constructor(t) {
            super(),
            this._root = t,
            this._initMemoryManager(),
            this._accuIndex = 0,
            this.time = 0,
            this.timeScale = 1
        }
        _bindAction(t, e) {
            const n = t._localRoot || this._root
              , i = t._clip.tracks
              , r = i.length
              , s = t._propertyBindings
              , o = t._interpolants
              , a = n.uuid
              , l = this._bindingsByRootAndName;
            let c = l[a];
            void 0 === c && (c = {},
            l[a] = c);
            for (let t = 0; t !== r; ++t) {
                const r = i[t]
                  , l = r.name;
                let h = c[l];
                if (void 0 !== h)
                    s[t] = h;
                else {
                    if (h = s[t],
                    void 0 !== h) {
                        null === h._cacheIndex && (++h.referenceCount,
                        this._addInactiveBinding(h, a, l));
                        continue
                    }
                    const i = e && e._propertyBindings[t].binding.parsedPath;
                    h = new Jm(og.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                    ++h.referenceCount,
                    this._addInactiveBinding(h, a, l),
                    s[t] = h
                }
                o[t].resultBuffer = h.buffer
            }
        }
        _activateAction(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    const e = (t._localRoot || this._root).uuid
                      , n = t._clip.uuid
                      , i = this._actionsByClip[n];
                    this._bindAction(t, i && i.knownActions[0]),
                    this._addInactiveAction(t, n, e)
                }
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == n.useCount++ && (this._lendBinding(n),
                    n.saveOriginalState())
                }
                this._lendAction(t)
            }
        }
        _deactivateAction(t) {
            if (this._isActiveAction(t)) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.useCount && (n.restoreOriginalState(),
                    this._takeBackBinding(n))
                }
                this._takeBackAction(t)
            }
        }
        _initMemoryManager() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            const t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        }
        _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        }
        _addInactiveAction(t, e, n) {
            const i = this._actions
              , r = this._actionsByClip;
            let s = r[e];
            if (void 0 === s)
                s = {
                    knownActions: [t],
                    actionByRoot: {}
                },
                t._byClipCacheIndex = 0,
                r[e] = s;
            else {
                const e = s.knownActions;
                t._byClipCacheIndex = e.length,
                e.push(t)
            }
            t._cacheIndex = i.length,
            i.push(t),
            s.actionByRoot[n] = t
        }
        _removeInactiveAction(t) {
            const e = this._actions
              , n = e[e.length - 1]
              , i = t._cacheIndex;
            n._cacheIndex = i,
            e[i] = n,
            e.pop(),
            t._cacheIndex = null;
            const r = t._clip.uuid
              , s = this._actionsByClip
              , o = s[r]
              , a = o.knownActions
              , l = a[a.length - 1]
              , c = t._byClipCacheIndex;
            l._byClipCacheIndex = c,
            a[c] = l,
            a.pop(),
            t._byClipCacheIndex = null,
            delete o.actionByRoot[(t._localRoot || this._root).uuid],
            0 === a.length && delete s[r],
            this._removeInactiveBindingsForAction(t)
        }
        _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        }
        _lendAction(t) {
            const e = this._actions
              , n = t._cacheIndex
              , i = this._nActiveActions++
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        }
        _takeBackAction(t) {
            const e = this._actions
              , n = t._cacheIndex
              , i = --this._nActiveActions
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        }
        _addInactiveBinding(t, e, n) {
            const i = this._bindingsByRootAndName
              , r = this._bindings;
            let s = i[e];
            void 0 === s && (s = {},
            i[e] = s),
            s[n] = t,
            t._cacheIndex = r.length,
            r.push(t)
        }
        _removeInactiveBinding(t) {
            const e = this._bindings
              , n = t.binding
              , i = n.rootNode.uuid
              , r = n.path
              , s = this._bindingsByRootAndName
              , o = s[i]
              , a = e[e.length - 1]
              , l = t._cacheIndex;
            a._cacheIndex = l,
            e[l] = a,
            e.pop(),
            delete o[r],
            0 === Object.keys(o).length && delete s[i]
        }
        _lendBinding(t) {
            const e = this._bindings
              , n = t._cacheIndex
              , i = this._nActiveBindings++
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        }
        _takeBackBinding(t) {
            const e = this._bindings
              , n = t._cacheIndex
              , i = --this._nActiveBindings
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        }
        _lendControlInterpolant() {
            const t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++;
            let n = t[e];
            return void 0 === n && (n = new $f(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
            n.__cacheIndex = e,
            t[e] = n),
            n
        }
        _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants
              , n = t.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , r = e[i];
            t.__cacheIndex = i,
            e[i] = t,
            r.__cacheIndex = n,
            e[n] = r
        }
        clipAction(t, e, n) {
            const i = e || this._root
              , r = i.uuid;
            let s = "string" == typeof t ? cm.findByName(i, t) : t;
            const o = null !== s ? s.uuid : t
              , a = this._actionsByClip[o];
            let l = null;
            if (void 0 === n && (n = null !== s ? s.blendMode : 2500),
            void 0 !== a) {
                const t = a.actionByRoot[r];
                if (void 0 !== t && t.blendMode === n)
                    return t;
                l = a.knownActions[0],
                null === s && (s = l._clip)
            }
            if (null === s)
                return null;
            const c = new ag(this,s,e,n);
            return this._bindAction(c, l),
            this._addInactiveAction(c, o, r),
            c
        }
        existingAction(t, e) {
            const n = e || this._root
              , i = n.uuid
              , r = "string" == typeof t ? cm.findByName(n, t) : t
              , s = r ? r.uuid : t
              , o = this._actionsByClip[s];
            return void 0 !== o && o.actionByRoot[i] || null
        }
        stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e)
                t[e].stop();
            return this
        }
        update(t) {
            t *= this.timeScale;
            const e = this._actions
              , n = this._nActiveActions
              , i = this.time += t
              , r = Math.sign(t)
              , s = this._accuIndex ^= 1;
            for (let o = 0; o !== n; ++o)
                e[o]._update(i, t, r, s);
            const o = this._bindings
              , a = this._nActiveBindings;
            for (let t = 0; t !== a; ++t)
                o[t].apply(s);
            return this
        }
        setTime(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
                this._actions[t].time = 0;
            return this.update(t)
        }
        getRoot() {
            return this._root
        }
        uncacheClip(t) {
            const e = this._actions
              , n = t.uuid
              , i = this._actionsByClip
              , r = i[n];
            if (void 0 !== r) {
                const t = r.knownActions;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    const i = t[n];
                    this._deactivateAction(i);
                    const r = i._cacheIndex
                      , s = e[e.length - 1];
                    i._cacheIndex = null,
                    i._byClipCacheIndex = null,
                    s._cacheIndex = r,
                    e[r] = s,
                    e.pop(),
                    this._removeInactiveBindingsForAction(i)
                }
                delete i[n]
            }
        }
        uncacheRoot(t) {
            const e = t.uuid
              , n = this._actionsByClip;
            for (const t in n) {
                const i = n[t].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
            const i = this._bindingsByRootAndName[e];
            if (void 0 !== i)
                for (const t in i) {
                    const e = i[t];
                    e.restoreOriginalState(),
                    this._removeInactiveBinding(e)
                }
        }
        uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n),
            this._removeInactiveAction(n))
        }
    }
    lg.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    class cg {
        constructor(t) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            t = arguments[1]),
            this.value = t
        }
        clone() {
            return new cg(void 0 === this.value.clone ? this.value : this.value.clone())
        }
    }
    (class extends Zd {
        constructor(t, e, n=1) {
            super(t, e),
            this.meshPerAttribute = n
        }
        copy(t) {
            return super.copy(t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
        clone(t) {
            const e = super.clone(t);
            return e.meshPerAttribute = this.meshPerAttribute,
            e
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.isInstancedInterleavedBuffer = !0,
            e.meshPerAttribute = this.meshPerAttribute,
            e
        }
    }
    ).prototype.isInstancedInterleavedBuffer = !0;
    class hg {
        constructor(t, e, n=0, i=1 / 0) {
            this.ray = new gl(t,e),
            this.near = n,
            this.far = i,
            this.camera = null,
            this.layers = new Rl,
            this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }
        }
        set(t, e) {
            this.ray.set(t, e)
        }
        setFromCamera(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
            this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
            this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
        }
        intersectObject(t, e=!0, n=[]) {
            return dg(t, this, n, e),
            n.sort(ug),
            n
        }
        intersectObjects(t, e=!0, n=[]) {
            for (let i = 0, r = t.length; i < r; i++)
                dg(t[i], this, n, e);
            return n.sort(ug),
            n
        }
    }
    function ug(t, e) {
        return t.distance - e.distance
    }
    function dg(t, e, n, i) {
        if (t.layers.test(e.layers) && t.raycast(e, n),
        !0 === i) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++)
                dg(i[t], e, n, !0)
        }
    }
    class pg {
        constructor(t=1, e=0, n=0) {
            return this.radius = t,
            this.phi = e,
            this.theta = n,
            this
        }
        set(t, e, n) {
            return this.radius = t,
            this.phi = e,
            this.theta = n,
            this
        }
        copy(t) {
            return this.radius = t.radius,
            this.phi = t.phi,
            this.theta = t.theta,
            this
        }
        makeSafe() {
            const t = 1e-6;
            return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
            this
        }
        setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        }
        setFromCartesianCoords(t, e, n) {
            return this.radius = Math.sqrt(t * t + e * e + n * n),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(t, n),
            this.phi = Math.acos(_a(e / this.radius, -1, 1))),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const fg = new Ea;
    class mg {
        constructor(t=new Ea(1 / 0,1 / 0), e=new Ea(-1 / 0,-1 / 0)) {
            this.min = t,
            this.max = e
        }
        set(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        }
        setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        }
        setFromCenterAndSize(t, e) {
            const n = fg.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n),
            this.max.copy(t).add(n),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }
        getCenter(t) {
            return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(t) {
            return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        }
        expandByVector(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        }
        expandByScalar(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        }
        containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        }
        getParameter(t, e) {
            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        }
        intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        }
        clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
            return fg.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        intersect(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this
        }
        union(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        }
        translate(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }
    mg.prototype.isBox2 = !0;
    const gg = new Ua
      , vg = new vl
      , yg = new vl;
    function _g(t) {
        const e = [];
        t && t.isBone && e.push(t);
        for (let n = 0; n < t.children.length; n++)
            e.push.apply(e, _g(t.children[n]));
        return e
    }
    const xg = new Float32Array(1)
      , bg = new Int32Array(xg.buffer);
    class wg {
        static toHalfFloat(t) {
            t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."),
            t = 65504),
            xg[0] = t;
            const e = bg[0];
            let n = e >> 16 & 32768
              , i = e >> 12 & 2047;
            const r = e >> 23 & 255;
            return r < 103 ? n : r > 142 ? (n |= 31744,
            n |= (255 == r ? 0 : 1) && 8388607 & e,
            n) : r < 113 ? (i |= 2048,
            n |= (i >> 114 - r) + (i >> 113 - r & 1),
            n) : (n |= r - 112 << 10 | i >> 1,
            n += 1 & i,
            n)
        }
    }
    Yp.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"),
        t.prototype = Object.create(Yp.prototype),
        t.prototype.constructor = t,
        t.prototype.getPoint = e,
        t
    }
    ,
    mf.prototype.fromPoints = function(t) {
        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
        this.setFromPoints(t)
    }
    ,
    class extends Bp {
        constructor(t=10, e=10, n=4473924, i=8947848) {
            n = new lc(n),
            i = new lc(i);
            const r = e / 2
              , s = t / e
              , o = t / 2
              , a = []
              , l = [];
            for (let t = 0, c = 0, h = -o; t <= e; t++,
            h += s) {
                a.push(-o, 0, h, o, 0, h),
                a.push(h, 0, -o, h, 0, o);
                const e = t === r ? n : i;
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3
            }
            const c = new Mc;
            c.setAttribute("position", new mc(a,3)),
            c.setAttribute("color", new mc(l,3)),
            super(c, new Lp({
                vertexColors: !0,
                toneMapped: !1
            })),
            this.type = "GridHelper"
        }
    }
    .prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    class extends Bp {
        constructor(t) {
            const e = _g(t)
              , n = new Mc
              , i = []
              , r = []
              , s = new lc(0,0,1)
              , o = new lc(0,1,0);
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                n.parent && n.parent.isBone && (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(s.r, s.g, s.b),
                r.push(o.r, o.g, o.b))
            }
            n.setAttribute("position", new mc(i,3)),
            n.setAttribute("color", new mc(r,3)),
            super(n, new Lp({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            })),
            this.type = "SkeletonHelper",
            this.isSkeletonHelper = !0,
            this.root = t,
            this.bones = e,
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        updateMatrixWorld(t) {
            const e = this.bones
              , n = this.geometry
              , i = n.getAttribute("position");
            yg.copy(this.root.matrixWorld).invert();
            for (let t = 0, n = 0; t < e.length; t++) {
                const r = e[t];
                r.parent && r.parent.isBone && (vg.multiplyMatrices(yg, r.matrixWorld),
                gg.setFromMatrixPosition(vg),
                i.setXYZ(n, gg.x, gg.y, gg.z),
                vg.multiplyMatrices(yg, r.parent.matrixWorld),
                gg.setFromMatrixPosition(vg),
                i.setXYZ(n + 1, gg.x, gg.y, gg.z),
                n += 2)
            }
            n.getAttribute("position").needsUpdate = !0,
            super.updateMatrixWorld(t)
        }
    }
    .prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    fm.prototype.extractUrlBase = function(t) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
        zm.extractUrlBase(t)
    }
    ,
    fm.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    },
    mg.prototype.center = function(t) {
        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
    }
    ,
    mg.prototype.empty = function() {
        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    mg.prototype.isIntersectionBox = function(t) {
        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(t)
    }
    ,
    mg.prototype.size = function(t) {
        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
        this.getSize(t)
    }
    ,
    Ga.prototype.center = function(t) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
    }
    ,
    Ga.prototype.empty = function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    Ga.prototype.isIntersectionBox = function(t) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(t)
    }
    ,
    Ga.prototype.isIntersectionSphere = function(t) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
        this.intersectsSphere(t)
    }
    ,
    Ga.prototype.size = function(t) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
        this.getSize(t)
    }
    ,
    ll.prototype.empty = function() {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    oh.prototype.setFromMatrix = function(t) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
        this.setFromProjectionMatrix(t)
    }
    ,
    Aa.prototype.flattenToArrayOffset = function(t, e) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
        this.toArray(t, e)
    }
    ,
    Aa.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
        t.applyMatrix3(this)
    }
    ,
    Aa.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    }
    ,
    Aa.prototype.applyToBufferAttribute = function(t) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
        t.applyMatrix3(this)
    }
    ,
    Aa.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }
    ,
    Aa.prototype.getInverse = function(t) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
        this.copy(t).invert()
    }
    ,
    vl.prototype.extractPosition = function(t) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
        this.copyPosition(t)
    }
    ,
    vl.prototype.flattenToArrayOffset = function(t, e) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
        this.toArray(t, e)
    }
    ,
    vl.prototype.getPosition = function() {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
        (new Ua).setFromMatrixColumn(this, 3)
    }
    ,
    vl.prototype.setRotationFromQuaternion = function(t) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
        this.makeRotationFromQuaternion(t)
    }
    ,
    vl.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    }
    ,
    vl.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    vl.prototype.multiplyVector4 = function(t) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    vl.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    }
    ,
    vl.prototype.rotateAxis = function(t) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
        t.transformDirection(this)
    }
    ,
    vl.prototype.crossVector = function(t) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    vl.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.")
    }
    ,
    vl.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.")
    }
    ,
    vl.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.")
    }
    ,
    vl.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.")
    }
    ,
    vl.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    }
    ,
    vl.prototype.applyToBufferAttribute = function(t) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
        t.applyMatrix4(this)
    }
    ,
    vl.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    }
    ,
    vl.prototype.makeFrustum = function(t, e, n, i, r, s) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
        this.makePerspective(t, e, i, n, r, s)
    }
    ,
    vl.prototype.getInverse = function(t) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
        this.copy(t).invert()
    }
    ,
    ih.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(t)
    }
    ,
    Fa.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        t.applyQuaternion(this)
    }
    ,
    Fa.prototype.inverse = function() {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
        this.invert()
    }
    ,
    gl.prototype.isIntersectionBox = function(t) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(t)
    }
    ,
    gl.prototype.isIntersectionPlane = function(t) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
        this.intersectsPlane(t)
    }
    ,
    gl.prototype.isIntersectionSphere = function(t) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
        this.intersectsSphere(t)
    }
    ,
    $l.prototype.area = function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
        this.getArea()
    }
    ,
    $l.prototype.barycoordFromPoint = function(t, e) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
        this.getBarycoord(t, e)
    }
    ,
    $l.prototype.midpoint = function(t) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
        this.getMidpoint(t)
    }
    ,
    $l.prototypenormal = function(t) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
        this.getNormal(t)
    }
    ,
    $l.prototype.plane = function(t) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
        this.getPlane(t)
    }
    ,
    $l.barycoordFromPoint = function(t, e, n, i, r) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
        $l.getBarycoord(t, e, n, i, r)
    }
    ,
    $l.normal = function(t, e, n, i) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
        $l.getNormal(t, e, n, i)
    }
    ,
    gf.prototype.extractAllPoints = function(t) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
        this.extractPoints(t)
    }
    ,
    gf.prototype.extrude = function(t) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
        new Wf(this,t)
    }
    ,
    gf.prototype.makeGeometry = function(t) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
        new Xf(this,t)
    }
    ,
    Ea.prototype.fromAttribute = function(t, e, n) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(t, e, n)
    }
    ,
    Ea.prototype.distanceToManhattan = function(t) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
        this.manhattanDistanceTo(t)
    }
    ,
    Ea.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Ua.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    }
    ,
    Ua.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    }
    ,
    Ua.prototype.getPositionFromMatrix = function(t) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
        this.setFromMatrixPosition(t)
    }
    ,
    Ua.prototype.getScaleFromMatrix = function(t) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
        this.setFromMatrixScale(t)
    }
    ,
    Ua.prototype.getColumnFromMatrix = function(t, e) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
        this.setFromMatrixColumn(e, t)
    }
    ,
    Ua.prototype.applyProjection = function(t) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
        this.applyMatrix4(t)
    }
    ,
    Ua.prototype.fromAttribute = function(t, e, n) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(t, e, n)
    }
    ,
    Ua.prototype.distanceToManhattan = function(t) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
        this.manhattanDistanceTo(t)
    }
    ,
    Ua.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Na.prototype.fromAttribute = function(t, e, n) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(t, e, n)
    }
    ,
    Na.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Vl.prototype.getChildByName = function(t) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
        this.getObjectByName(t)
    }
    ,
    Vl.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    }
    ,
    Vl.prototype.translate = function(t, e) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
        this.translateOnAxis(e, t)
    }
    ,
    Vl.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }
    ,
    Vl.prototype.applyMatrix = function(t) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
        this.applyMatrix4(t)
    }
    ,
    Object.defineProperties(Vl.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Hc.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
    }
    ,
    Object.defineProperties(Hc.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }),
    yp.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Zc.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(bm.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(dc.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.usage === ha
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.setUsage(ha)
            }
        }
    }),
    dc.prototype.setDynamic = function(t) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
        this.setUsage(!0 === t ? ha : ca),
        this
    }
    ,
    dc.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }
    ,
    dc.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }
    ,
    Mc.prototype.addIndex = function(t) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
        this.setIndex(t)
    }
    ,
    Mc.prototype.addAttribute = function(t, e) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
        e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
        this.setIndex(e),
        this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
        this.setAttribute(t, new dc(arguments[1],arguments[2])))
    }
    ,
    Mc.prototype.addDrawCall = function(t, e, n) {
        void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
        this.addGroup(t, e)
    }
    ,
    Mc.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
        this.clearGroups()
    }
    ,
    Mc.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }
    ,
    Mc.prototype.removeAttribute = function(t) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
        this.deleteAttribute(t)
    }
    ,
    Mc.prototype.applyMatrix = function(t) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
        this.applyMatrix4(t)
    }
    ,
    Object.defineProperties(Mc.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Zd.prototype.setDynamic = function(t) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
        this.setUsage(!0 === t ? ha : ca),
        this
    }
    ,
    Zd.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }
    ,
    Wf.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
    }
    ,
    Wf.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
    }
    ,
    Wf.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
    }
    ,
    Yd.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.")
    }
    ,
    cg.prototype.onUpdate = function() {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
        this
    }
    ,
    Object.defineProperties(ec.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new lc
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === t
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask = t
            }
        },
        vertexTangents: {
            get: function() {
                console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
            },
            set: function() {
                console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
            }
        }
    }),
    Object.defineProperties(qc.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = t
            }
        }
    }),
    jd.prototype.clearTarget = function(t, e, n, i) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
        this.setRenderTarget(t),
        this.clear(e, n, i)
    }
    ,
    jd.prototype.animate = function(t) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
        this.setAnimationLoop(t)
    }
    ,
    jd.prototype.getCurrentRenderTarget = function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
        this.getRenderTarget()
    }
    ,
    jd.prototype.getMaxAnisotropy = function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
        this.capabilities.getMaxAnisotropy()
    }
    ,
    jd.prototype.getPrecision = function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
        this.capabilities.precision
    }
    ,
    jd.prototype.resetGLState = function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
        this.state.reset()
    }
    ,
    jd.prototype.supportsFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
        this.extensions.get("OES_texture_float")
    }
    ,
    jd.prototype.supportsHalfFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
        this.extensions.get("OES_texture_half_float")
    }
    ,
    jd.prototype.supportsStandardDerivatives = function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
        this.extensions.get("OES_standard_derivatives")
    }
    ,
    jd.prototype.supportsCompressedTextureS3TC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
        this.extensions.get("WEBGL_compressed_texture_s3tc")
    }
    ,
    jd.prototype.supportsCompressedTexturePVRTC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
        this.extensions.get("WEBGL_compressed_texture_pvrtc")
    }
    ,
    jd.prototype.supportsBlendMinMax = function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
        this.extensions.get("EXT_blend_minmax")
    }
    ,
    jd.prototype.supportsVertexTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
        this.capabilities.vertexTextures
    }
    ,
    jd.prototype.supportsInstancedArrays = function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
        this.extensions.get("ANGLE_instanced_arrays")
    }
    ,
    jd.prototype.enableScissorTest = function(t) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
        this.setScissorTest(t)
    }
    ,
    jd.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    }
    ,
    jd.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    }
    ,
    jd.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    }
    ,
    jd.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    }
    ,
    jd.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    }
    ,
    jd.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
    }
    ,
    jd.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
    }
    ,
    jd.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
    }
    ,
    jd.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
    }
    ,
    jd.prototype.getActiveMipMapLevel = function() {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
        this.getActiveMipmapLevel()
    }
    ,
    Object.defineProperties(jd.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                !1
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                this.outputEncoding = !0 === t ? sa : ra
            }
        },
        toneMappingWhitePoint: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }),
    Object.defineProperties(kd.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(za.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = t
            }
        }
    }),
    Zm.prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const e = this;
        return (new Hm).load(t, (function(t) {
            e.setBuffer(t)
        }
        )),
        this
    }
    ,
    Kc.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(t, e)
    }
    ,
    Kc.prototype.clear = function(t, e, n, i) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
        this.renderTarget.clear(t, e, n, i)
    }
    ,
    Da.crossOrigin = void 0,
    Da.loadTexture = function(t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r = new xm;
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(t, n, void 0, i);
        return e && (s.mapping = e),
        s
    }
    ,
    Da.loadTextureCube = function(t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r = new ym;
        r.setCrossOrigin(this.crossOrigin);
        const s = r.load(t, n, void 0, i);
        return e && (s.mapping = e),
        s
    }
    ,
    Da.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    Da.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: "134"
        }
    })),
    "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "134");
    const Mg = {
        type: "change"
    }
      , Sg = {
        type: "start"
    }
      , Tg = {
        type: "end"
    };
    class Eg extends fm {
        constructor(t) {
            super(t),
            this.dracoLoader = null,
            this.ktx2Loader = null,
            this.meshoptDecoder = null,
            this.pluginCallbacks = [],
            this.register((function(t) {
                return new Pg(t)
            }
            )),
            this.register((function(t) {
                return new zg(t)
            }
            )),
            this.register((function(t) {
                return new Bg(t)
            }
            )),
            this.register((function(t) {
                return new Dg(t)
            }
            )),
            this.register((function(t) {
                return new Ig(t)
            }
            )),
            this.register((function(t) {
                return new Og(t)
            }
            )),
            this.register((function(t) {
                return new kg(t)
            }
            )),
            this.register((function(t) {
                return new Ng(t)
            }
            )),
            this.register((function(t) {
                return new Lg(t)
            }
            )),
            this.register((function(t) {
                return new Fg(t)
            }
            ))
        }
        load(t, e, n, i) {
            const r = this;
            let s;
            s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : zm.extractUrlBase(t),
            this.manager.itemStart(t);
            const o = function(e) {
                i ? i(e) : console.error(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
              , a = new gm(this.manager);
            a.setPath(this.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(t, (function(n) {
                try {
                    r.parse(n, s, (function(n) {
                        e(n),
                        r.manager.itemEnd(t)
                    }
                    ), o)
                } catch (t) {
                    o(t)
                }
            }
            ), n, o)
        }
        setDRACOLoader(t) {
            return this.dracoLoader = t,
            this
        }
        setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
        }
        setKTX2Loader(t) {
            return this.ktx2Loader = t,
            this
        }
        setMeshoptDecoder(t) {
            return this.meshoptDecoder = t,
            this
        }
        register(t) {
            return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
            this
        }
        unregister(t) {
            return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
            this
        }
        parse(t, e, n, i) {
            let r;
            const s = {}
              , o = {};
            if ("string" == typeof t)
                r = t;
            else if (zm.decodeText(new Uint8Array(t,0,4)) === Ug) {
                try {
                    s[Rg.KHR_BINARY_GLTF] = new Hg(t)
                } catch (t) {
                    return void (i && i(t))
                }
                r = s[Rg.KHR_BINARY_GLTF].content
            } else
                r = zm.decodeText(new Uint8Array(t));
            const a = JSON.parse(r);
            if (void 0 === a.asset || a.asset.version[0] < 2)
                return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const l = new cv(a,{
                path: e || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            l.fileLoader.setRequestHeader(this.requestHeader);
            for (let t = 0; t < this.pluginCallbacks.length; t++) {
                const e = this.pluginCallbacks[t](l);
                o[e.name] = e,
                s[e.name] = !0
            }
            if (a.extensionsUsed)
                for (let t = 0; t < a.extensionsUsed.length; ++t) {
                    const e = a.extensionsUsed[t]
                      , n = a.extensionsRequired || [];
                    switch (e) {
                    case Rg.KHR_MATERIALS_UNLIT:
                        s[e] = new Cg;
                        break;
                    case Rg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                        s[e] = new jg;
                        break;
                    case Rg.KHR_DRACO_MESH_COMPRESSION:
                        s[e] = new Vg(a,this.dracoLoader);
                        break;
                    case Rg.KHR_TEXTURE_TRANSFORM:
                        s[e] = new Gg;
                        break;
                    case Rg.KHR_MESH_QUANTIZATION:
                        s[e] = new Xg;
                        break;
                    default:
                        n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                    }
                }
            l.setExtensions(s),
            l.setPlugins(o),
            l.parse(n, i)
        }
    }
    function Ag() {
        let t = {};
        return {
            get: function(e) {
                return t[e]
            },
            add: function(e, n) {
                t[e] = n
            },
            remove: function(e) {
                delete t[e]
            },
            removeAll: function() {
                t = {}
            }
        }
    }
    const Rg = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };
    class Lg {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_LIGHTS_PUNCTUAL,
            this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const t = this.parser
              , e = this.parser.json.nodes || [];
            for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n];
                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
            }
        }
        _loadLight(t) {
            const e = this.parser
              , n = "light:" + t;
            let i = e.cache.get(n);
            if (i)
                return i;
            const r = e.json
              , s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
            let o;
            const a = new lc(16777215);
            void 0 !== s.color && a.fromArray(s.color);
            const l = void 0 !== s.range ? s.range : 0;
            switch (s.type) {
            case "directional":
                o = new Om(a),
                o.target.position.set(0, 0, -1),
                o.add(o.target);
                break;
            case "point":
                o = new Dm(a),
                o.distance = l;
                break;
            case "spot":
                o = new Am(a),
                o.distance = l,
                s.spot = s.spot || {},
                s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                o.angle = s.spot.outerConeAngle,
                o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                o.target.position.set(0, 0, -1),
                o.add(o.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
            }
            return o.position.set(0, 0, 0),
            o.decay = 2,
            void 0 !== s.intensity && (o.intensity = s.intensity),
            o.name = e.createUniqueName(s.name || "light_" + t),
            i = Promise.resolve(o),
            e.cache.add(n, i),
            i
        }
        createNodeAttachment(t) {
            const e = this
              , n = this.parser
              , i = n.json.nodes[t]
              , r = (i.extensions && i.extensions[this.name] || {}).light;
            return void 0 === r ? null : this._loadLight(r).then((function(t) {
                return n._getNodeRef(e.cache, r, t)
            }
            ))
        }
    }
    class Cg {
        constructor() {
            this.name = Rg.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return cc
        }
        extendParams(t, e, n) {
            const i = [];
            t.color = new lc(1,1,1),
            t.opacity = 1;
            const r = e.pbrMetallicRoughness;
            if (r) {
                if (Array.isArray(r.baseColorFactor)) {
                    const e = r.baseColorFactor;
                    t.color.fromArray(e),
                    t.opacity = e[3]
                }
                void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture))
            }
            return Promise.all(i)
        }
    }
    class Pg {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? Zf : null
        }
        extendMaterialParams(t, e) {
            const n = this.parser
              , i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
                return Promise.resolve();
            const r = []
              , s = i.extensions[this.name];
            if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
            void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
            void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
            void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
            void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)),
            void 0 !== s.clearcoatNormalTexture.scale)) {
                const t = s.clearcoatNormalTexture.scale;
                e.clearcoatNormalScale = new Ea(t,t)
            }
            return Promise.all(r)
        }
    }
    class Dg {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_MATERIALS_SHEEN
        }
        getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? Zf : null
        }
        extendMaterialParams(t, e) {
            const n = this.parser
              , i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
                return Promise.resolve();
            const r = [];
            e.sheenColor = new lc(0,0,0),
            e.sheenRoughness = 0,
            e.sheen = 1;
            const s = i.extensions[this.name];
            return void 0 !== s.sheenColorFactor && e.sheenColor.fromArray(s.sheenColorFactor),
            void 0 !== s.sheenRoughnessFactor && (e.sheenRoughness = s.sheenRoughnessFactor),
            void 0 !== s.sheenColorTexture && r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture)),
            void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)),
            Promise.all(r)
        }
    }
    class Ig {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? Zf : null
        }
        extendMaterialParams(t, e) {
            const n = this.parser
              , i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
                return Promise.resolve();
            const r = []
              , s = i.extensions[this.name];
            return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
            void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
            Promise.all(r)
        }
    }
    class Og {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_MATERIALS_VOLUME
        }
        getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? Zf : null
        }
        extendMaterialParams(t, e) {
            const n = this.parser
              , i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
                return Promise.resolve();
            const r = []
              , s = i.extensions[this.name];
            e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
            void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
            e.attenuationDistance = s.attenuationDistance || 0;
            const o = s.attenuationColor || [1, 1, 1];
            return e.attenuationColor = new lc(o[0],o[1],o[2]),
            Promise.all(r)
        }
    }
    class kg {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_MATERIALS_IOR
        }
        getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? Zf : null
        }
        extendMaterialParams(t, e) {
            const n = this.parser.json.materials[t];
            if (!n.extensions || !n.extensions[this.name])
                return Promise.resolve();
            const i = n.extensions[this.name];
            return e.ior = void 0 !== i.ior ? i.ior : 1.5,
            Promise.resolve()
        }
    }
    class Ng {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? Zf : null
        }
        extendMaterialParams(t, e) {
            const n = this.parser
              , i = n.json.materials[t];
            if (!i.extensions || !i.extensions[this.name])
                return Promise.resolve();
            const r = []
              , s = i.extensions[this.name];
            e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
            void 0 !== s.specularTexture && r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
            const o = s.specularColorFactor || [1, 1, 1];
            return e.specularColor = new lc(o[0],o[1],o[2]),
            void 0 !== s.specularColorTexture && r.push(n.assignTexture(e, "specularColorMap", s.specularColorTexture).then((function(t) {
                t.encoding = sa
            }
            ))),
            Promise.all(r)
        }
    }
    class zg {
        constructor(t) {
            this.parser = t,
            this.name = Rg.KHR_TEXTURE_BASISU
        }
        loadTexture(t) {
            const e = this.parser
              , n = e.json
              , i = n.textures[t];
            if (!i.extensions || !i.extensions[this.name])
                return null;
            const r = i.extensions[this.name]
              , s = n.images[r.source]
              , o = e.options.ktx2Loader;
            if (!o) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return e.loadTextureImage(t, s, o)
        }
    }
    class Bg {
        constructor(t) {
            this.parser = t,
            this.name = Rg.EXT_TEXTURE_WEBP,
            this.isSupported = null
        }
        loadTexture(t) {
            const e = this.name
              , n = this.parser
              , i = n.json
              , r = i.textures[t];
            if (!r.extensions || !r.extensions[e])
                return null;
            const s = r.extensions[e]
              , o = i.images[s.source];
            let a = n.textureLoader;
            if (o.uri) {
                const t = n.options.manager.getHandler(o.uri);
                null !== t && (a = t)
            }
            return this.detectSupport().then((function(r) {
                if (r)
                    return n.loadTextureImage(t, o, a);
                if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                    throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(t)
            }
            ))
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function(t) {
                const e = new Image;
                e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                e.onload = e.onerror = function() {
                    t(1 === e.height)
                }
            }
            ))),
            this.isSupported
        }
    }
    class Fg {
        constructor(t) {
            this.name = Rg.EXT_MESHOPT_COMPRESSION,
            this.parser = t
        }
        loadBufferView(t) {
            const e = this.parser.json
              , n = e.bufferViews[t];
            if (n.extensions && n.extensions[this.name]) {
                const t = n.extensions[this.name]
                  , i = this.parser.getDependency("buffer", t.buffer)
                  , r = this.parser.options.meshoptDecoder;
                if (!r || !r.supported) {
                    if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return Promise.all([i, r.ready]).then((function(e) {
                    const n = t.byteOffset || 0
                      , i = t.byteLength || 0
                      , s = t.count
                      , o = t.byteStride
                      , a = new ArrayBuffer(s * o)
                      , l = new Uint8Array(e[0],n,i);
                    return r.decodeGltfBuffer(new Uint8Array(a), s, o, l, t.mode, t.filter),
                    a
                }
                ))
            }
            return null
        }
    }
    const Ug = "glTF";
    class Hg {
        constructor(t) {
            this.name = Rg.KHR_BINARY_GLTF,
            this.content = null,
            this.body = null;
            const e = new DataView(t,0,12);
            if (this.header = {
                magic: zm.decodeText(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0)
            },
            this.header.magic !== Ug)
                throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2)
                throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - 12
              , i = new DataView(t,12);
            let r = 0;
            for (; r < n; ) {
                const e = i.getUint32(r, !0);
                r += 4;
                const n = i.getUint32(r, !0);
                if (r += 4,
                1313821514 === n) {
                    const n = new Uint8Array(t,12 + r,e);
                    this.content = zm.decodeText(n)
                } else if (5130562 === n) {
                    const n = 12 + r;
                    this.body = t.slice(n, n + e)
                }
                r += e
            }
            if (null === this.content)
                throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class Vg {
        constructor(t, e) {
            if (!e)
                throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = Rg.KHR_DRACO_MESH_COMPRESSION,
            this.json = t,
            this.dracoLoader = e,
            this.dracoLoader.preload()
        }
        decodePrimitive(t, e) {
            const n = this.json
              , i = this.dracoLoader
              , r = t.extensions[this.name].bufferView
              , s = t.extensions[this.name].attributes
              , o = {}
              , a = {}
              , l = {};
            for (const t in s) {
                const e = tv[t] || t.toLowerCase();
                o[e] = s[t]
            }
            for (const e in t.attributes) {
                const i = tv[e] || e.toLowerCase();
                if (void 0 !== s[e]) {
                    const r = n.accessors[t.attributes[e]]
                      , s = Jg[r.componentType];
                    l[i] = s,
                    a[i] = !0 === r.normalized
                }
            }
            return e.getDependency("bufferView", r).then((function(t) {
                return new Promise((function(e) {
                    i.decodeDracoFile(t, (function(t) {
                        for (const e in t.attributes) {
                            const n = t.attributes[e]
                              , i = a[e];
                            void 0 !== i && (n.normalized = i)
                        }
                        e(t)
                    }
                    ), o, l)
                }
                ))
            }
            ))
        }
    }
    class Gg {
        constructor() {
            this.name = Rg.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(t, e) {
            return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
            void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(),
            void 0 !== e.offset && t.offset.fromArray(e.offset),
            void 0 !== e.rotation && (t.rotation = e.rotation),
            void 0 !== e.scale && t.repeat.fromArray(e.scale),
            t.needsUpdate = !0),
            t
        }
    }
    class Wg extends Yf {
        constructor(t) {
            super(),
            this.isGLTFSpecularGlossinessMaterial = !0;
            const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
              , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
              , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
              , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
              , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
              , o = {
                specular: {
                    value: (new lc).setHex(16777215)
                },
                glossiness: {
                    value: 1
                },
                specularMap: {
                    value: null
                },
                glossinessMap: {
                    value: null
                }
            };
            this._extraUniforms = o,
            this.onBeforeCompile = function(t) {
                for (const e in o)
                    t.uniforms[e] = o[e];
                t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
            }
            ,
            Object.defineProperties(this, {
                specular: {
                    get: function() {
                        return o.specular.value
                    },
                    set: function(t) {
                        o.specular.value = t
                    }
                },
                specularMap: {
                    get: function() {
                        return o.specularMap.value
                    },
                    set: function(t) {
                        o.specularMap.value = t,
                        t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                    }
                },
                glossiness: {
                    get: function() {
                        return o.glossiness.value
                    },
                    set: function(t) {
                        o.glossiness.value = t
                    }
                },
                glossinessMap: {
                    get: function() {
                        return o.glossinessMap.value
                    },
                    set: function(t) {
                        o.glossinessMap.value = t,
                        t ? (this.defines.USE_GLOSSINESSMAP = "",
                        this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                        delete this.defines.USE_UV)
                    }
                }
            }),
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this.setValues(t)
        }
        copy(t) {
            return super.copy(t),
            this.specularMap = t.specularMap,
            this.specular.copy(t.specular),
            this.glossinessMap = t.glossinessMap,
            this.glossiness = t.glossiness,
            delete this.metalness,
            delete this.roughness,
            delete this.metalnessMap,
            delete this.roughnessMap,
            this
        }
    }
    class jg {
        constructor() {
            this.name = Rg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
            this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
        }
        getMaterialType() {
            return Wg
        }
        extendParams(t, e, n) {
            const i = e.extensions[this.name];
            t.color = new lc(1,1,1),
            t.opacity = 1;
            const r = [];
            if (Array.isArray(i.diffuseFactor)) {
                const e = i.diffuseFactor;
                t.color.fromArray(e),
                t.opacity = e[3]
            }
            if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture)),
            t.emissive = new lc(0,0,0),
            t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1,
            t.specular = new lc(1,1,1),
            Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor),
            void 0 !== i.specularGlossinessTexture) {
                const e = i.specularGlossinessTexture;
                r.push(n.assignTexture(t, "glossinessMap", e)),
                r.push(n.assignTexture(t, "specularMap", e))
            }
            return Promise.all(r)
        }
        createMaterial(t) {
            const e = new Wg(t);
            return e.fog = !0,
            e.color = t.color,
            e.map = void 0 === t.map ? null : t.map,
            e.lightMap = null,
            e.lightMapIntensity = 1,
            e.aoMap = void 0 === t.aoMap ? null : t.aoMap,
            e.aoMapIntensity = 1,
            e.emissive = t.emissive,
            e.emissiveIntensity = 1,
            e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap,
            e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap,
            e.bumpScale = 1,
            e.normalMap = void 0 === t.normalMap ? null : t.normalMap,
            e.normalMapType = 0,
            t.normalScale && (e.normalScale = t.normalScale),
            e.displacementMap = null,
            e.displacementScale = 1,
            e.displacementBias = 0,
            e.specularMap = void 0 === t.specularMap ? null : t.specularMap,
            e.specular = t.specular,
            e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap,
            e.glossiness = t.glossiness,
            e.alphaMap = null,
            e.envMap = void 0 === t.envMap ? null : t.envMap,
            e.envMapIntensity = 1,
            e.refractionRatio = .98,
            e
        }
    }
    class Xg {
        constructor() {
            this.name = Rg.KHR_MESH_QUANTIZATION
        }
    }
    class qg extends Kf {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        copySampleValue_(t) {
            const e = this.resultBuffer
              , n = this.sampleValues
              , i = this.valueSize
              , r = t * i * 3 + i;
            for (let t = 0; t !== i; t++)
                e[t] = n[r + t];
            return e
        }
    }
    qg.prototype.beforeStart_ = qg.prototype.copySampleValue_,
    qg.prototype.afterEnd_ = qg.prototype.copySampleValue_,
    qg.prototype.interpolate_ = function(t, e, n, i) {
        const r = this.resultBuffer
          , s = this.sampleValues
          , o = this.valueSize
          , a = 2 * o
          , l = 3 * o
          , c = i - e
          , h = (n - e) / c
          , u = h * h
          , d = u * h
          , p = t * l
          , f = p - l
          , m = -2 * d + 3 * u
          , g = d - u
          , v = 1 - m
          , y = g - u + h;
        for (let t = 0; t !== o; t++) {
            const e = s[f + t + o]
              , n = s[f + t + a] * c
              , i = s[p + t + o]
              , l = s[p + t] * c;
            r[t] = v * e + y * n + m * i + g * l
        }
        return r
    }
    ;
    const Yg = new Fa;
    class Zg extends qg {
        interpolate_(t, e, n, i) {
            const r = super.interpolate_(t, e, n, i);
            return Yg.fromArray(r).normalize().toArray(r),
            r
        }
    }
    const Jg = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    }
      , Kg = {
        9728: zo,
        9729: Uo,
        9984: Bo,
        9985: 1007,
        9986: Fo,
        9987: Ho
    }
      , Qg = {
        33071: ko,
        33648: No,
        10497: Oo
    }
      , $g = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    }
      , tv = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }
      , ev = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    }
      , nv = {
        CUBICSPLINE: void 0,
        LINEAR: $o,
        STEP: Qo
    };
    function iv(t, e, n) {
        for (const i in n.extensions)
            void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
            e.userData.gltfExtensions[i] = n.extensions[i])
    }
    function rv(t, e) {
        void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
    }
    function sv(t, e) {
        if (t.updateMorphTargets(),
        void 0 !== e.weights)
            for (let n = 0, i = e.weights.length; n < i; n++)
                t.morphTargetInfluences[n] = e.weights[n];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
            const n = e.extras.targetNames;
            if (t.morphTargetInfluences.length === n.length) {
                t.morphTargetDictionary = {};
                for (let e = 0, i = n.length; e < i; e++)
                    t.morphTargetDictionary[n[e]] = e
            } else
                console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }
    function ov(t) {
        const e = t.extensions && t.extensions[Rg.KHR_DRACO_MESH_COMPRESSION];
        let n;
        return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + av(e.attributes) : t.indices + ":" + av(t.attributes) + ":" + t.mode,
        n
    }
    function av(t) {
        let e = "";
        const n = Object.keys(t).sort();
        for (let i = 0, r = n.length; i < r; i++)
            e += n[i] + ":" + t[n[i]] + ";";
        return e
    }
    function lv(t) {
        switch (t) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }
    class cv {
        constructor(t={}, e={}) {
            this.json = t,
            this.extensions = {},
            this.plugins = {},
            this.options = e,
            this.cache = new Ag,
            this.associations = new Map,
            this.primitiveCache = {},
            this.meshCache = {
                refs: {},
                uses: {}
            },
            this.cameraCache = {
                refs: {},
                uses: {}
            },
            this.lightCache = {
                refs: {},
                uses: {}
            },
            this.textureCache = {},
            this.nodeNamesUsed = {},
            "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Bm(this.options.manager) : this.textureLoader = new xm(this.options.manager),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            this.fileLoader = new gm(this.options.manager),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(t) {
            this.extensions = t
        }
        setPlugins(t) {
            this.plugins = t
        }
        parse(t, e) {
            const n = this
              , i = this.json
              , r = this.extensions;
            this.cache.removeAll(),
            this._invokeAll((function(t) {
                return t._markDefs && t._markDefs()
            }
            )),
            Promise.all(this._invokeAll((function(t) {
                return t.beforeRoot && t.beforeRoot()
            }
            ))).then((function() {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            }
            )).then((function(e) {
                const s = {
                    scene: e[0][i.scene || 0],
                    scenes: e[0],
                    animations: e[1],
                    cameras: e[2],
                    asset: i.asset,
                    parser: n,
                    userData: {}
                };
                iv(r, s, i),
                rv(s, i),
                Promise.all(n._invokeAll((function(t) {
                    return t.afterRoot && t.afterRoot(s)
                }
                ))).then((function() {
                    t(s)
                }
                ))
            }
            )).catch(e)
        }
        _markDefs() {
            const t = this.json.nodes || []
              , e = this.json.skins || []
              , n = this.json.meshes || [];
            for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n].joints;
                for (let e = 0, n = i.length; e < n; e++)
                    t[i[e]].isBone = !0
            }
            for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
            }
        }
        _addNodeRef(t, e) {
            void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
            t.refs[e]++)
        }
        _getNodeRef(t, e, n) {
            if (t.refs[e] <= 1)
                return n;
            const i = n.clone()
              , r = (t,e)=>{
                const n = this.associations.get(t);
                null != n && this.associations.set(e, n);
                for (const [n,i] of t.children.entries())
                    r(i, e.children[n])
            }
            ;
            return r(n, i),
            i.name += "_instance_" + t.uses[e]++,
            i
        }
        _invokeOne(t) {
            const e = Object.values(this.plugins);
            e.push(this);
            for (let n = 0; n < e.length; n++) {
                const i = t(e[n]);
                if (i)
                    return i
            }
            return null
        }
        _invokeAll(t) {
            const e = Object.values(this.plugins);
            e.unshift(this);
            const n = [];
            for (let i = 0; i < e.length; i++) {
                const r = t(e[i]);
                r && n.push(r)
            }
            return n
        }
        getDependency(t, e) {
            const n = t + ":" + e;
            let i = this.cache.get(n);
            if (!i) {
                switch (t) {
                case "scene":
                    i = this.loadScene(e);
                    break;
                case "node":
                    i = this.loadNode(e);
                    break;
                case "mesh":
                    i = this._invokeOne((function(t) {
                        return t.loadMesh && t.loadMesh(e)
                    }
                    ));
                    break;
                case "accessor":
                    i = this.loadAccessor(e);
                    break;
                case "bufferView":
                    i = this._invokeOne((function(t) {
                        return t.loadBufferView && t.loadBufferView(e)
                    }
                    ));
                    break;
                case "buffer":
                    i = this.loadBuffer(e);
                    break;
                case "material":
                    i = this._invokeOne((function(t) {
                        return t.loadMaterial && t.loadMaterial(e)
                    }
                    ));
                    break;
                case "texture":
                    i = this._invokeOne((function(t) {
                        return t.loadTexture && t.loadTexture(e)
                    }
                    ));
                    break;
                case "skin":
                    i = this.loadSkin(e);
                    break;
                case "animation":
                    i = this.loadAnimation(e);
                    break;
                case "camera":
                    i = this.loadCamera(e);
                    break;
                default:
                    throw new Error("Unknown type: " + t)
                }
                this.cache.add(n, i)
            }
            return i
        }
        getDependencies(t) {
            let e = this.cache.get(t);
            if (!e) {
                const n = this
                  , i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                e = Promise.all(i.map((function(e, i) {
                    return n.getDependency(t, i)
                }
                ))),
                this.cache.add(t, e)
            }
            return e
        }
        loadBuffer(t) {
            const e = this.json.buffers[t]
              , n = this.fileLoader;
            if (e.type && "arraybuffer" !== e.type)
                throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
            if (void 0 === e.uri && 0 === t)
                return Promise.resolve(this.extensions[Rg.KHR_BINARY_GLTF].body);
            const i = this.options;
            return new Promise((function(t, r) {
                n.load(zm.resolveURL(e.uri, i.path), t, void 0, (function() {
                    r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                }
                ))
            }
            ))
        }
        loadBufferView(t) {
            const e = this.json.bufferViews[t];
            return this.getDependency("buffer", e.buffer).then((function(t) {
                const n = e.byteLength || 0
                  , i = e.byteOffset || 0;
                return t.slice(i, i + n)
            }
            ))
        }
        loadAccessor(t) {
            const e = this
              , n = this.json
              , i = this.json.accessors[t];
            if (void 0 === i.bufferView && void 0 === i.sparse)
                return Promise.resolve(null);
            const r = [];
            return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
            void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
            r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
            Promise.all(r).then((function(t) {
                const r = t[0]
                  , s = $g[i.type]
                  , o = Jg[i.componentType]
                  , a = o.BYTES_PER_ELEMENT
                  , l = a * s
                  , c = i.byteOffset || 0
                  , h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
                  , u = !0 === i.normalized;
                let d, p;
                if (h && h !== l) {
                    const t = Math.floor(c / h)
                      , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                    let l = e.cache.get(n);
                    l || (d = new o(r,t * h,i.count * h / a),
                    l = new Zd(d,h / a),
                    e.cache.add(n, l)),
                    p = new Kd(l,s,c % h / a,u)
                } else
                    d = null === r ? new o(i.count * s) : new o(r,c,i.count * s),
                    p = new dc(d,s,u);
                if (void 0 !== i.sparse) {
                    const e = $g.SCALAR
                      , n = Jg[i.sparse.indices.componentType]
                      , a = i.sparse.indices.byteOffset || 0
                      , l = i.sparse.values.byteOffset || 0
                      , c = new n(t[1],a,i.sparse.count * e)
                      , h = new o(t[2],l,i.sparse.count * s);
                    null !== r && (p = new dc(p.array.slice(),p.itemSize,p.normalized));
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        if (p.setX(e, h[t * s]),
                        s >= 2 && p.setY(e, h[t * s + 1]),
                        s >= 3 && p.setZ(e, h[t * s + 2]),
                        s >= 4 && p.setW(e, h[t * s + 3]),
                        s >= 5)
                            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return p
            }
            ))
        }
        loadTexture(t) {
            const e = this.json
              , n = this.options
              , i = e.textures[t]
              , r = e.images[i.source];
            let s = this.textureLoader;
            if (r.uri) {
                const t = n.manager.getHandler(r.uri);
                null !== t && (s = t)
            }
            return this.loadTextureImage(t, r, s)
        }
        loadTextureImage(t, e, n) {
            const i = this
              , r = this.json
              , s = this.options
              , o = r.textures[t]
              , a = (e.uri || e.bufferView) + ":" + o.sampler;
            if (this.textureCache[a])
                return this.textureCache[a];
            const l = self.URL || self.webkitURL;
            let c = e.uri || ""
              , h = !1;
            if (void 0 !== e.bufferView)
                c = i.getDependency("bufferView", e.bufferView).then((function(t) {
                    h = !0;
                    const n = new Blob([t],{
                        type: e.mimeType
                    });
                    return c = l.createObjectURL(n),
                    c
                }
                ));
            else if (void 0 === e.uri)
                throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
            const u = Promise.resolve(c).then((function(t) {
                return new Promise((function(e, i) {
                    let r = e;
                    !0 === n.isImageBitmapLoader && (r = function(t) {
                        const n = new Oa(t);
                        n.needsUpdate = !0,
                        e(n)
                    }
                    ),
                    n.load(zm.resolveURL(t, s.path), r, void 0, i)
                }
                ))
            }
            )).then((function(e) {
                !0 === h && l.revokeObjectURL(c),
                e.flipY = !1,
                o.name && (e.name = o.name);
                const n = (r.samplers || {})[o.sampler] || {};
                return e.magFilter = Kg[n.magFilter] || Uo,
                e.minFilter = Kg[n.minFilter] || Ho,
                e.wrapS = Qg[n.wrapS] || Oo,
                e.wrapT = Qg[n.wrapT] || Oo,
                i.associations.set(e, {
                    textures: t
                }),
                e
            }
            )).catch((function() {
                return console.error("THREE.GLTFLoader: Couldn't load texture", c),
                null
            }
            ));
            return this.textureCache[a] = u,
            u
        }
        assignTexture(t, e, n) {
            const i = this;
            return this.getDependency("texture", n.index).then((function(r) {
                if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."),
                i.extensions[Rg.KHR_TEXTURE_TRANSFORM]) {
                    const t = void 0 !== n.extensions ? n.extensions[Rg.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (t) {
                        const e = i.associations.get(r);
                        r = i.extensions[Rg.KHR_TEXTURE_TRANSFORM].extendTexture(r, t),
                        i.associations.set(r, e)
                    }
                }
                return t[e] = r,
                r
            }
            ))
        }
        assignFinalMaterial(t) {
            const e = t.geometry;
            let n = t.material;
            const i = void 0 === e.attributes.tangent
              , r = void 0 !== e.attributes.color
              , s = void 0 === e.attributes.normal;
            if (t.isPoints) {
                const t = "PointsMaterial:" + n.uuid;
                let e = this.cache.get(t);
                e || (e = new Up,
                ec.prototype.copy.call(e, n),
                e.color.copy(n.color),
                e.map = n.map,
                e.sizeAttenuation = !1,
                this.cache.add(t, e)),
                n = e
            } else if (t.isLine) {
                const t = "LineBasicMaterial:" + n.uuid;
                let e = this.cache.get(t);
                e || (e = new Lp,
                ec.prototype.copy.call(e, n),
                e.color.copy(n.color),
                this.cache.add(t, e)),
                n = e
            }
            if (i || r || s) {
                let t = "ClonedMaterial:" + n.uuid + ":";
                n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
                i && (t += "derivative-tangents:"),
                r && (t += "vertex-colors:"),
                s && (t += "flat-shading:");
                let e = this.cache.get(t);
                e || (e = n.clone(),
                r && (e.vertexColors = !0),
                s && (e.flatShading = !0),
                i && (e.normalScale && (e.normalScale.y *= -1),
                e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                this.cache.add(t, e),
                this.associations.set(e, this.associations.get(n))),
                n = e
            }
            n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv),
            t.material = n
        }
        getMaterialType() {
            return Yf
        }
        loadMaterial(t) {
            const e = this
              , n = this.json
              , i = this.extensions
              , r = n.materials[t];
            let s;
            const o = {}
              , a = r.extensions || {}
              , l = [];
            if (a[Rg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                const t = i[Rg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                s = t.getMaterialType(),
                l.push(t.extendParams(o, r, e))
            } else if (a[Rg.KHR_MATERIALS_UNLIT]) {
                const t = i[Rg.KHR_MATERIALS_UNLIT];
                s = t.getMaterialType(),
                l.push(t.extendParams(o, r, e))
            } else {
                const n = r.pbrMetallicRoughness || {};
                if (o.color = new lc(1,1,1),
                o.opacity = 1,
                Array.isArray(n.baseColorFactor)) {
                    const t = n.baseColorFactor;
                    o.color.fromArray(t),
                    o.opacity = t[3]
                }
                void 0 !== n.baseColorTexture && l.push(e.assignTexture(o, "map", n.baseColorTexture)),
                o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                void 0 !== n.metallicRoughnessTexture && (l.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)),
                l.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))),
                s = this._invokeOne((function(e) {
                    return e.getMaterialType && e.getMaterialType(t)
                }
                )),
                l.push(Promise.all(this._invokeAll((function(e) {
                    return e.extendMaterialParams && e.extendMaterialParams(t, o)
                }
                ))))
            }
            !0 === r.doubleSided && (o.side = 2);
            const c = r.alphaMode || "OPAQUE";
            if ("BLEND" === c ? (o.transparent = !0,
            o.depthWrite = !1) : (o.format = Yo,
            o.transparent = !1,
            "MASK" === c && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
            void 0 !== r.normalTexture && s !== cc && (l.push(e.assignTexture(o, "normalMap", r.normalTexture)),
            o.normalScale = new Ea(1,1),
            void 0 !== r.normalTexture.scale)) {
                const t = r.normalTexture.scale;
                o.normalScale.set(t, t)
            }
            return void 0 !== r.occlusionTexture && s !== cc && (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)),
            void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)),
            void 0 !== r.emissiveFactor && s !== cc && (o.emissive = (new lc).fromArray(r.emissiveFactor)),
            void 0 !== r.emissiveTexture && s !== cc && l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture)),
            Promise.all(l).then((function() {
                let n;
                return n = s === Wg ? i[Rg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o),
                r.name && (n.name = r.name),
                n.map && (n.map.encoding = sa),
                n.emissiveMap && (n.emissiveMap.encoding = sa),
                rv(n, r),
                e.associations.set(n, {
                    materials: t
                }),
                r.extensions && iv(i, n, r),
                n
            }
            ))
        }
        createUniqueName(t) {
            const e = og.sanitizeNodeName(t || "");
            let n = e;
            for (let t = 1; this.nodeNamesUsed[n]; ++t)
                n = e + "_" + t;
            return this.nodeNamesUsed[n] = !0,
            n
        }
        loadGeometries(t) {
            const e = this
              , n = this.extensions
              , i = this.primitiveCache;
            function r(t) {
                return n[Rg.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                    return uv(n, t, e)
                }
                ))
            }
            const s = [];
            for (let n = 0, o = t.length; n < o; n++) {
                const o = t[n]
                  , a = ov(o)
                  , l = i[a];
                if (l)
                    s.push(l.promise);
                else {
                    let t;
                    t = o.extensions && o.extensions[Rg.KHR_DRACO_MESH_COMPRESSION] ? r(o) : uv(new Mc, o, e),
                    i[a] = {
                        primitive: o,
                        promise: t
                    },
                    s.push(t)
                }
            }
            return Promise.all(s)
        }
        loadMesh(t) {
            const e = this
              , n = this.json
              , i = this.extensions
              , r = n.meshes[t]
              , s = r.primitives
              , o = [];
            for (let t = 0, e = s.length; t < e; t++) {
                const e = void 0 === s[t].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new Yf({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: 0
                })),
                a.DefaultMaterial) : this.getDependency("material", s[t].material);
                o.push(e)
            }
            var a;
            return o.push(e.loadGeometries(s)),
            Promise.all(o).then((function(n) {
                const o = n.slice(0, n.length - 1)
                  , a = n[n.length - 1]
                  , l = [];
                for (let n = 0, c = a.length; n < c; n++) {
                    const c = a[n]
                      , h = s[n];
                    let u;
                    const d = o[n];
                    if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode)
                        u = !0 === r.isSkinnedMesh ? new yp(c,d) : new Hc(c,d),
                        !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(),
                        5 === h.mode ? u.geometry = dv(u.geometry, 1) : 6 === h.mode && (u.geometry = dv(u.geometry, 2));
                    else if (1 === h.mode)
                        u = new Bp(c,d);
                    else if (3 === h.mode)
                        u = new kp(c,d);
                    else if (2 === h.mode)
                        u = new Fp(c,d);
                    else {
                        if (0 !== h.mode)
                            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                        u = new jp(c,d)
                    }
                    Object.keys(u.geometry.morphAttributes).length > 0 && sv(u, r),
                    u.name = e.createUniqueName(r.name || "mesh_" + t),
                    rv(u, r),
                    h.extensions && iv(i, u, h),
                    e.assignFinalMaterial(u),
                    l.push(u)
                }
                for (let n = 0, i = l.length; n < i; n++)
                    e.associations.set(l[n], {
                        meshes: t,
                        primitives: n
                    });
                if (1 === l.length)
                    return l[0];
                const c = new Ud;
                e.associations.set(c, {
                    meshes: t
                });
                for (let t = 0, e = l.length; t < e; t++)
                    c.add(l[t]);
                return c
            }
            ))
        }
        loadCamera(t) {
            let e;
            const n = this.json.cameras[t]
              , i = n[n.type];
            if (i)
                return "perspective" === n.type ? e = new Zc(Ta.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (e = new _h(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                n.name && (e.name = this.createUniqueName(n.name)),
                rv(e, n),
                Promise.resolve(e);
            console.warn("THREE.GLTFLoader: Missing camera parameters.")
        }
        loadSkin(t) {
            const e = this.json.skins[t]
              , n = {
                joints: e.joints
            };
            return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                return n.inverseBindMatrices = t,
                n
            }
            ))
        }
        loadAnimation(t) {
            const e = this.json.animations[t]
              , n = []
              , i = []
              , r = []
              , s = []
              , o = [];
            for (let t = 0, a = e.channels.length; t < a; t++) {
                const a = e.channels[t]
                  , l = e.samplers[a.sampler]
                  , c = a.target
                  , h = void 0 !== c.node ? c.node : c.id
                  , u = void 0 !== e.parameters ? e.parameters[l.input] : l.input
                  , d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                n.push(this.getDependency("node", h)),
                i.push(this.getDependency("accessor", u)),
                r.push(this.getDependency("accessor", d)),
                s.push(l),
                o.push(c)
            }
            return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function(n) {
                const i = n[0]
                  , r = n[1]
                  , s = n[2]
                  , o = n[3]
                  , a = n[4]
                  , l = [];
                for (let t = 0, e = i.length; t < e; t++) {
                    const e = i[t]
                      , n = r[t]
                      , c = s[t]
                      , h = o[t]
                      , u = a[t];
                    if (void 0 === e)
                        continue;
                    let d;
                    switch (e.updateMatrix(),
                    e.matrixAutoUpdate = !0,
                    ev[u.path]) {
                    case ev.weights:
                        d = rm;
                        break;
                    case ev.rotation:
                        d = om;
                        break;
                    default:
                        d = lm
                    }
                    const p = e.name ? e.name : e.uuid
                      , f = void 0 !== h.interpolation ? nv[h.interpolation] : $o
                      , m = [];
                    ev[u.path] === ev.weights ? e.traverse((function(t) {
                        !0 === t.isMesh && t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid)
                    }
                    )) : m.push(p);
                    let g = c.array;
                    if (c.normalized) {
                        const t = lv(g.constructor)
                          , e = new Float32Array(g.length);
                        for (let n = 0, i = g.length; n < i; n++)
                            e[n] = g[n] * t;
                        g = e
                    }
                    for (let t = 0, e = m.length; t < e; t++) {
                        const e = new d(m[t] + "." + ev[u.path],n.array,g,f);
                        "CUBICSPLINE" === h.interpolation && (e.createInterpolant = function(t) {
                            return new (this instanceof om ? Zg : qg)(this.times,this.values,this.getValueSize() / 3,t)
                        }
                        ,
                        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                        l.push(e)
                    }
                }
                const c = e.name ? e.name : "animation_" + t;
                return new cm(c,void 0,l)
            }
            ))
        }
        createNodeMesh(t) {
            const e = this.json
              , n = this
              , i = e.nodes[t];
            return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
                const e = n._getNodeRef(n.meshCache, i.mesh, t);
                return void 0 !== i.weights && e.traverse((function(t) {
                    if (t.isMesh)
                        for (let e = 0, n = i.weights.length; e < n; e++)
                            t.morphTargetInfluences[e] = i.weights[e]
                }
                )),
                e
            }
            ))
        }
        loadNode(t) {
            const e = this.json
              , n = this.extensions
              , i = this
              , r = e.nodes[t]
              , s = r.name ? i.createUniqueName(r.name) : "";
            return function() {
                const e = []
                  , n = i._invokeOne((function(e) {
                    return e.createNodeMesh && e.createNodeMesh(t)
                }
                ));
                return n && e.push(n),
                void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then((function(t) {
                    return i._getNodeRef(i.cameraCache, r.camera, t)
                }
                ))),
                i._invokeAll((function(e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t)
                }
                )).forEach((function(t) {
                    e.push(t)
                }
                )),
                Promise.all(e)
            }().then((function(e) {
                let o;
                if (o = !0 === r.isBone ? new _p : e.length > 1 ? new Ud : 1 === e.length ? e[0] : new Vl,
                o !== e[0])
                    for (let t = 0, n = e.length; t < n; t++)
                        o.add(e[t]);
                if (r.name && (o.userData.name = r.name,
                o.name = s),
                rv(o, r),
                r.extensions && iv(n, o, r),
                void 0 !== r.matrix) {
                    const t = new vl;
                    t.fromArray(r.matrix),
                    o.applyMatrix4(t)
                } else
                    void 0 !== r.translation && o.position.fromArray(r.translation),
                    void 0 !== r.rotation && o.quaternion.fromArray(r.rotation),
                    void 0 !== r.scale && o.scale.fromArray(r.scale);
                return i.associations.has(o) || i.associations.set(o, {}),
                i.associations.get(o).nodes = t,
                o
            }
            ))
        }
        loadScene(t) {
            const e = this.json
              , n = this.extensions
              , i = this.json.scenes[t]
              , r = this
              , s = new Ud;
            i.name && (s.name = r.createUniqueName(i.name)),
            rv(s, i),
            i.extensions && iv(n, s, i);
            const o = i.nodes || []
              , a = [];
            for (let t = 0, n = o.length; t < n; t++)
                a.push(hv(o[t], s, e, r));
            return Promise.all(a).then((function() {
                return r.associations = (t=>{
                    const e = new Map;
                    for (const [t,n] of r.associations)
                        (t instanceof ec || t instanceof Oa) && e.set(t, n);
                    return t.traverse((t=>{
                        const n = r.associations.get(t);
                        null != n && e.set(t, n)
                    }
                    )),
                    e
                }
                )(s),
                s
            }
            ))
        }
    }
    function hv(t, e, n, i) {
        const r = n.nodes[t];
        return i.getDependency("node", t).then((function(t) {
            if (void 0 === r.skin)
                return t;
            let e;
            return i.getDependency("skin", r.skin).then((function(t) {
                e = t;
                const n = [];
                for (let t = 0, r = e.joints.length; t < r; t++)
                    n.push(i.getDependency("node", e.joints[t]));
                return Promise.all(n)
            }
            )).then((function(n) {
                return t.traverse((function(t) {
                    if (!t.isMesh)
                        return;
                    const i = []
                      , r = [];
                    for (let t = 0, s = n.length; t < s; t++) {
                        const s = n[t];
                        if (s) {
                            i.push(s);
                            const n = new vl;
                            void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t),
                            r.push(n)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                    }
                    t.bind(new Mp(i,r), t.matrixWorld)
                }
                )),
                t
            }
            ))
        }
        )).then((function(t) {
            e.add(t);
            const s = [];
            if (r.children) {
                const e = r.children;
                for (let r = 0, o = e.length; r < o; r++) {
                    const o = e[r];
                    s.push(hv(o, t, n, i))
                }
            }
            return Promise.all(s)
        }
        ))
    }
    function uv(t, e, n) {
        const i = e.attributes
          , r = [];
        function s(e, i) {
            return n.getDependency("accessor", e).then((function(e) {
                t.setAttribute(i, e)
            }
            ))
        }
        for (const e in i) {
            const n = tv[e] || e.toLowerCase();
            n in t.attributes || r.push(s(i[e], n))
        }
        if (void 0 !== e.indices && !t.index) {
            const i = n.getDependency("accessor", e.indices).then((function(e) {
                t.setIndex(e)
            }
            ));
            r.push(i)
        }
        return rv(t, e),
        function(t, e, n) {
            const i = e.attributes
              , r = new Ga;
            if (void 0 === i.POSITION)
                return;
            {
                const t = n.json.accessors[i.POSITION]
                  , e = t.min
                  , s = t.max;
                if (void 0 === e || void 0 === s)
                    return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                if (r.set(new Ua(e[0],e[1],e[2]), new Ua(s[0],s[1],s[2])),
                t.normalized) {
                    const e = lv(Jg[t.componentType]);
                    r.min.multiplyScalar(e),
                    r.max.multiplyScalar(e)
                }
            }
            const s = e.targets;
            if (void 0 !== s) {
                const t = new Ua
                  , e = new Ua;
                for (let i = 0, r = s.length; i < r; i++) {
                    const r = s[i];
                    if (void 0 !== r.POSITION) {
                        const i = n.json.accessors[r.POSITION]
                          , s = i.min
                          , o = i.max;
                        if (void 0 !== s && void 0 !== o) {
                            if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                            e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                            e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                            i.normalized) {
                                const t = lv(Jg[i.componentType]);
                                e.multiplyScalar(t)
                            }
                            t.max(e)
                        } else
                            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                    }
                }
                r.expandByVector(t)
            }
            t.boundingBox = r;
            const o = new ll;
            r.getCenter(o.center),
            o.radius = r.min.distanceTo(r.max) / 2,
            t.boundingSphere = o
        }(t, e, n),
        Promise.all(r).then((function() {
            return void 0 !== e.targets ? function(t, e, n) {
                let i = !1
                  , r = !1;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t];
                    if (void 0 !== n.POSITION && (i = !0),
                    void 0 !== n.NORMAL && (r = !0),
                    i && r)
                        break
                }
                if (!i && !r)
                    return Promise.resolve(t);
                const s = []
                  , o = [];
                for (let a = 0, l = e.length; a < l; a++) {
                    const l = e[a];
                    if (i) {
                        const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                        s.push(e)
                    }
                    if (r) {
                        const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                        o.push(e)
                    }
                }
                return Promise.all([Promise.all(s), Promise.all(o)]).then((function(e) {
                    const n = e[0]
                      , s = e[1];
                    return i && (t.morphAttributes.position = n),
                    r && (t.morphAttributes.normal = s),
                    t.morphTargetsRelative = !0,
                    t
                }
                ))
            }(t, e.targets, n) : t
        }
        ))
    }
    function dv(t, e) {
        let n = t.getIndex();
        if (null === n) {
            const e = []
              , i = t.getAttribute("position");
            if (void 0 === i)
                return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                t;
            for (let t = 0; t < i.count; t++)
                e.push(t);
            t.setIndex(e),
            n = t.getIndex()
        }
        const i = n.count - 2
          , r = [];
        if (2 === e)
            for (let t = 1; t <= i; t++)
                r.push(n.getX(0)),
                r.push(n.getX(t)),
                r.push(n.getX(t + 1));
        else
            for (let t = 0; t < i; t++)
                t % 2 == 0 ? (r.push(n.getX(t)),
                r.push(n.getX(t + 1)),
                r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)),
                r.push(n.getX(t + 1)),
                r.push(n.getX(t)));
        r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = t.clone();
        return s.setIndex(r),
        s
    }
    const pv = new WeakMap;
    function fv() {
        let t, e;
        function n(t, e, n, i, r, s) {
            const o = s.num_components()
              , a = n.num_points() * o
              , l = a * r.BYTES_PER_ELEMENT
              , c = function(t, e) {
                switch (e) {
                case Float32Array:
                    return t.DT_FLOAT32;
                case Int8Array:
                    return t.DT_INT8;
                case Int16Array:
                    return t.DT_INT16;
                case Int32Array:
                    return t.DT_INT32;
                case Uint8Array:
                    return t.DT_UINT8;
                case Uint16Array:
                    return t.DT_UINT16;
                case Uint32Array:
                    return t.DT_UINT32
                }
            }(t, r)
              , h = t._malloc(l);
            e.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
            const u = new r(t.HEAPF32.buffer,h,a).slice();
            return t._free(h),
            {
                name: i,
                array: u,
                itemSize: o
            }
        }
        onmessage = function(i) {
            const r = i.data;
            switch (r.type) {
            case "init":
                t = r.decoderConfig,
                e = new Promise((function(e) {
                    t.onModuleLoaded = function(t) {
                        e({
                            draco: t
                        })
                    }
                    ,
                    DracoDecoderModule(t)
                }
                ));
                break;
            case "decode":
                const i = r.buffer
                  , s = r.taskConfig;
                e.then((t=>{
                    const e = t.draco
                      , o = new e.Decoder
                      , a = new e.DecoderBuffer;
                    a.Init(new Int8Array(i), i.byteLength);
                    try {
                        const t = function(t, e, i, r) {
                            const s = r.attributeIDs
                              , o = r.attributeTypes;
                            let a, l;
                            const c = e.GetEncodedGeometryType(i);
                            if (c === t.TRIANGULAR_MESH)
                                a = new t.Mesh,
                                l = e.DecodeBufferToMesh(i, a);
                            else {
                                if (c !== t.POINT_CLOUD)
                                    throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                a = new t.PointCloud,
                                l = e.DecodeBufferToPointCloud(i, a)
                            }
                            if (!l.ok() || 0 === a.ptr)
                                throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                            const h = {
                                index: null,
                                attributes: []
                            };
                            for (const i in s) {
                                const l = self[o[i]];
                                let c, u;
                                if (r.useUniqueIDs)
                                    u = s[i],
                                    c = e.GetAttributeByUniqueId(a, u);
                                else {
                                    if (u = e.GetAttributeId(a, t[s[i]]),
                                    -1 === u)
                                        continue;
                                    c = e.GetAttribute(a, u)
                                }
                                h.attributes.push(n(t, e, a, i, l, c))
                            }
                            return c === t.TRIANGULAR_MESH && (h.index = function(t, e, n) {
                                const i = 3 * n.num_faces()
                                  , r = 4 * i
                                  , s = t._malloc(r);
                                e.GetTrianglesUInt32Array(n, r, s);
                                const o = new Uint32Array(t.HEAPF32.buffer,s,i).slice();
                                return t._free(s),
                                {
                                    array: o,
                                    itemSize: 1
                                }
                            }(t, e, a)),
                            t.destroy(a),
                            h
                        }(e, o, a, s)
                          , i = t.attributes.map((t=>t.array.buffer));
                        t.index && i.push(t.index.array.buffer),
                        self.postMessage({
                            type: "decode",
                            id: r.id,
                            geometry: t
                        }, i)
                    } catch (t) {
                        console.error(t),
                        self.postMessage({
                            type: "error",
                            id: r.id,
                            error: t.message
                        })
                    } finally {
                        e.destroy(a),
                        e.destroy(o)
                    }
                }
                ))
            }
        }
    }
    function mv(t, e) {
        var n = t.__state.conversionName.toString()
          , i = Math.round(t.r)
          , r = Math.round(t.g)
          , s = Math.round(t.b)
          , o = t.a
          , a = Math.round(t.h)
          , l = t.s.toFixed(1)
          , c = t.v.toFixed(1);
        if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
            for (var h = t.hex.toString(16); h.length < 6; )
                h = "0" + h;
            return "#" + h
        }
        return "CSS_RGB" === n ? "rgb(" + i + "," + r + "," + s + ")" : "CSS_RGBA" === n ? "rgba(" + i + "," + r + "," + s + "," + o + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + i + "," + r + "," + s + "]" : "RGBA_ARRAY" === n ? "[" + i + "," + r + "," + s + "," + o + "]" : "RGB_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + s + "}" : "RGBA_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + s + ",a:" + o + "}" : "HSV_OBJ" === n ? "{h:" + a + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === n ? "{h:" + a + ",s:" + l + ",v:" + c + ",a:" + o + "}" : "unknown format"
    }
    var gv = Array.prototype.forEach
      , vv = Array.prototype.slice
      , yv = {
        BREAK: {},
        extend: function(t) {
            return this.each(vv.call(arguments, 1), (function(e) {
                (this.isObject(e) ? Object.keys(e) : []).forEach(function(n) {
                    this.isUndefined(e[n]) || (t[n] = e[n])
                }
                .bind(this))
            }
            ), this),
            t
        },
        defaults: function(t) {
            return this.each(vv.call(arguments, 1), (function(e) {
                (this.isObject(e) ? Object.keys(e) : []).forEach(function(n) {
                    this.isUndefined(t[n]) && (t[n] = e[n])
                }
                .bind(this))
            }
            ), this),
            t
        },
        compose: function() {
            var t = vv.call(arguments);
            return function() {
                for (var e = vv.call(arguments), n = t.length - 1; n >= 0; n--)
                    e = [t[n].apply(this, e)];
                return e[0]
            }
        },
        each: function(t, e, n) {
            if (t)
                if (gv && t.forEach && t.forEach === gv)
                    t.forEach(e, n);
                else if (t.length === t.length + 0) {
                    var i, r = void 0;
                    for (r = 0,
                    i = t.length; r < i; r++)
                        if (r in t && e.call(n, t[r], r) === this.BREAK)
                            return
                } else
                    for (var s in t)
                        if (e.call(n, t[s], s) === this.BREAK)
                            return
        },
        defer: function(t) {
            setTimeout(t, 0)
        },
        debounce: function(t, e, n) {
            var i = void 0;
            return function() {
                var r = this
                  , s = arguments;
                function o() {
                    i = null,
                    n || t.apply(r, s)
                }
                var a = n || !i;
                clearTimeout(i),
                i = setTimeout(o, e),
                a && t.apply(r, s)
            }
        },
        toArray: function(t) {
            return t.toArray ? t.toArray() : vv.call(t)
        },
        isUndefined: function(t) {
            return void 0 === t
        },
        isNull: function(t) {
            return null === t
        },
        isNaN: function(t) {
            function e() {
                return t.apply(this, arguments)
            }
            return e.toString = function() {
                return t.toString()
            }
            ,
            e
        }((function(t) {
            return isNaN(t)
        }
        )),
        isArray: Array.isArray || function(t) {
            return t.constructor === Array
        }
        ,
        isObject: function(t) {
            return t === Object(t)
        },
        isNumber: function(t) {
            return t === t + 0
        },
        isString: function(t) {
            return t === t + ""
        },
        isBoolean: function(t) {
            return !1 === t || !0 === t
        },
        isFunction: function(t) {
            return t instanceof Function
        }
    }
      , _v = [{
        litmus: yv.isString,
        conversions: {
            THREE_CHAR_HEX: {
                read: function(t) {
                    var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                    return null !== e && {
                        space: "HEX",
                        hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                    }
                },
                write: mv
            },
            SIX_CHAR_HEX: {
                read: function(t) {
                    var e = t.match(/^#([A-F0-9]{6})$/i);
                    return null !== e && {
                        space: "HEX",
                        hex: parseInt("0x" + e[1].toString(), 0)
                    }
                },
                write: mv
            },
            CSS_RGB: {
                read: function(t) {
                    var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                    return null !== e && {
                        space: "RGB",
                        r: parseFloat(e[1]),
                        g: parseFloat(e[2]),
                        b: parseFloat(e[3])
                    }
                },
                write: mv
            },
            CSS_RGBA: {
                read: function(t) {
                    var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                    return null !== e && {
                        space: "RGB",
                        r: parseFloat(e[1]),
                        g: parseFloat(e[2]),
                        b: parseFloat(e[3]),
                        a: parseFloat(e[4])
                    }
                },
                write: mv
            }
        }
    }, {
        litmus: yv.isNumber,
        conversions: {
            HEX: {
                read: function(t) {
                    return {
                        space: "HEX",
                        hex: t,
                        conversionName: "HEX"
                    }
                },
                write: function(t) {
                    return t.hex
                }
            }
        }
    }, {
        litmus: yv.isArray,
        conversions: {
            RGB_ARRAY: {
                read: function(t) {
                    return 3 === t.length && {
                        space: "RGB",
                        r: t[0],
                        g: t[1],
                        b: t[2]
                    }
                },
                write: function(t) {
                    return [t.r, t.g, t.b]
                }
            },
            RGBA_ARRAY: {
                read: function(t) {
                    return 4 === t.length && {
                        space: "RGB",
                        r: t[0],
                        g: t[1],
                        b: t[2],
                        a: t[3]
                    }
                },
                write: function(t) {
                    return [t.r, t.g, t.b, t.a]
                }
            }
        }
    }, {
        litmus: yv.isObject,
        conversions: {
            RGBA_OBJ: {
                read: function(t) {
                    return !!(yv.isNumber(t.r) && yv.isNumber(t.g) && yv.isNumber(t.b) && yv.isNumber(t.a)) && {
                        space: "RGB",
                        r: t.r,
                        g: t.g,
                        b: t.b,
                        a: t.a
                    }
                },
                write: function(t) {
                    return {
                        r: t.r,
                        g: t.g,
                        b: t.b,
                        a: t.a
                    }
                }
            },
            RGB_OBJ: {
                read: function(t) {
                    return !!(yv.isNumber(t.r) && yv.isNumber(t.g) && yv.isNumber(t.b)) && {
                        space: "RGB",
                        r: t.r,
                        g: t.g,
                        b: t.b
                    }
                },
                write: function(t) {
                    return {
                        r: t.r,
                        g: t.g,
                        b: t.b
                    }
                }
            },
            HSVA_OBJ: {
                read: function(t) {
                    return !!(yv.isNumber(t.h) && yv.isNumber(t.s) && yv.isNumber(t.v) && yv.isNumber(t.a)) && {
                        space: "HSV",
                        h: t.h,
                        s: t.s,
                        v: t.v,
                        a: t.a
                    }
                },
                write: function(t) {
                    return {
                        h: t.h,
                        s: t.s,
                        v: t.v,
                        a: t.a
                    }
                }
            },
            HSV_OBJ: {
                read: function(t) {
                    return !!(yv.isNumber(t.h) && yv.isNumber(t.s) && yv.isNumber(t.v)) && {
                        space: "HSV",
                        h: t.h,
                        s: t.s,
                        v: t.v
                    }
                },
                write: function(t) {
                    return {
                        h: t.h,
                        s: t.s,
                        v: t.v
                    }
                }
            }
        }
    }]
      , xv = void 0
      , bv = void 0
      , wv = function() {
        bv = !1;
        var t = arguments.length > 1 ? yv.toArray(arguments) : arguments[0];
        return yv.each(_v, (function(e) {
            if (e.litmus(t))
                return yv.each(e.conversions, (function(e, n) {
                    if (xv = e.read(t),
                    !1 === bv && !1 !== xv)
                        return bv = xv,
                        xv.conversionName = n,
                        xv.conversion = e,
                        yv.BREAK
                }
                )),
                yv.BREAK
        }
        )),
        bv
    }
      , Mv = void 0
      , Sv = {
        hsv_to_rgb: function(t, e, n) {
            var i = Math.floor(t / 60) % 6
              , r = t / 60 - Math.floor(t / 60)
              , s = n * (1 - e)
              , o = n * (1 - r * e)
              , a = n * (1 - (1 - r) * e)
              , l = [[n, a, s], [o, n, s], [s, n, a], [s, o, n], [a, s, n], [n, s, o]][i];
            return {
                r: 255 * l[0],
                g: 255 * l[1],
                b: 255 * l[2]
            }
        },
        rgb_to_hsv: function(t, e, n) {
            var i = Math.min(t, e, n)
              , r = Math.max(t, e, n)
              , s = r - i
              , o = void 0;
            return 0 === r ? {
                h: NaN,
                s: 0,
                v: 0
            } : (o = t === r ? (e - n) / s : e === r ? 2 + (n - t) / s : 4 + (t - e) / s,
            (o /= 6) < 0 && (o += 1),
            {
                h: 360 * o,
                s: s / r,
                v: r / 255
            })
        },
        rgb_to_hex: function(t, e, n) {
            var i = this.hex_with_component(0, 2, t);
            return i = this.hex_with_component(i, 1, e),
            this.hex_with_component(i, 0, n)
        },
        component_from_hex: function(t, e) {
            return t >> 8 * e & 255
        },
        hex_with_component: function(t, e, n) {
            return n << (Mv = 8 * e) | t & ~(255 << Mv)
        }
    }
      , Tv = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    }
    : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }
      , Ev = function(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
      , Av = function() {
        function t(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        return function(e, n, i) {
            return n && t(e.prototype, n),
            i && t(e, i),
            e
        }
    }()
      , Rv = function t(e, n, i) {
        null === e && (e = Function.prototype);
        var r = Object.getOwnPropertyDescriptor(e, n);
        if (void 0 === r) {
            var s = Object.getPrototypeOf(e);
            return null === s ? void 0 : t(s, n, i)
        }
        if ("value"in r)
            return r.value;
        var o = r.get;
        return void 0 !== o ? o.call(i) : void 0
    }
      , Lv = function(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
    }
      , Cv = function(t, e) {
        if (!t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e || "object" != typeof e && "function" != typeof e ? t : e
    }
      , Pv = function() {
        function t() {
            if (Ev(this, t),
            this.__state = wv.apply(this, arguments),
            !1 === this.__state)
                throw new Error("Failed to interpret color arguments");
            this.__state.a = this.__state.a || 1
        }
        return Av(t, [{
            key: "toString",
            value: function() {
                return mv(this)
            }
        }, {
            key: "toHexString",
            value: function() {
                return mv(this, !0)
            }
        }, {
            key: "toOriginal",
            value: function() {
                return this.__state.conversion.write(this)
            }
        }]),
        t
    }();
    function Dv(t, e, n) {
        Object.defineProperty(t, e, {
            get: function() {
                return "RGB" === this.__state.space || Pv.recalculateRGB(this, e, n),
                this.__state[e]
            },
            set: function(t) {
                "RGB" !== this.__state.space && (Pv.recalculateRGB(this, e, n),
                this.__state.space = "RGB"),
                this.__state[e] = t
            }
        })
    }
    function Iv(t, e) {
        Object.defineProperty(t, e, {
            get: function() {
                return "HSV" === this.__state.space || Pv.recalculateHSV(this),
                this.__state[e]
            },
            set: function(t) {
                "HSV" !== this.__state.space && (Pv.recalculateHSV(this),
                this.__state.space = "HSV"),
                this.__state[e] = t
            }
        })
    }
    Pv.recalculateRGB = function(t, e, n) {
        if ("HEX" === t.__state.space)
            t.__state[e] = Sv.component_from_hex(t.__state.hex, n);
        else {
            if ("HSV" !== t.__state.space)
                throw new Error("Corrupted color state");
            yv.extend(t.__state, Sv.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
        }
    }
    ,
    Pv.recalculateHSV = function(t) {
        var e = Sv.rgb_to_hsv(t.r, t.g, t.b);
        yv.extend(t.__state, {
            s: e.s,
            v: e.v
        }),
        yv.isNaN(e.h) ? yv.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
    }
    ,
    Pv.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"],
    Dv(Pv.prototype, "r", 2),
    Dv(Pv.prototype, "g", 1),
    Dv(Pv.prototype, "b", 0),
    Iv(Pv.prototype, "h"),
    Iv(Pv.prototype, "s"),
    Iv(Pv.prototype, "v"),
    Object.defineProperty(Pv.prototype, "a", {
        get: function() {
            return this.__state.a
        },
        set: function(t) {
            this.__state.a = t
        }
    }),
    Object.defineProperty(Pv.prototype, "hex", {
        get: function() {
            return "HEX" !== this.__state.space && (this.__state.hex = Sv.rgb_to_hex(this.r, this.g, this.b),
            this.__state.space = "HEX"),
            this.__state.hex
        },
        set: function(t) {
            this.__state.space = "HEX",
            this.__state.hex = t
        }
    });
    var Ov = function() {
        function t(e, n) {
            Ev(this, t),
            this.initialValue = e[n],
            this.domElement = document.createElement("div"),
            this.object = e,
            this.property = n,
            this.__onChange = void 0,
            this.__onFinishChange = void 0
        }
        return Av(t, [{
            key: "onChange",
            value: function(t) {
                return this.__onChange = t,
                this
            }
        }, {
            key: "onFinishChange",
            value: function(t) {
                return this.__onFinishChange = t,
                this
            }
        }, {
            key: "setValue",
            value: function(t) {
                return this.object[this.property] = t,
                this.__onChange && this.__onChange.call(this, t),
                this.updateDisplay(),
                this
            }
        }, {
            key: "getValue",
            value: function() {
                return this.object[this.property]
            }
        }, {
            key: "updateDisplay",
            value: function() {
                return this
            }
        }, {
            key: "isModified",
            value: function() {
                return this.initialValue !== this.getValue()
            }
        }]),
        t
    }()
      , kv = {};
    yv.each({
        HTMLEvents: ["change"],
        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
        KeyboardEvents: ["keydown"]
    }, (function(t, e) {
        yv.each(t, (function(t) {
            kv[t] = e
        }
        ))
    }
    ));
    var Nv = /(\d+(\.\d+)?)px/;
    function zv(t) {
        if ("0" === t || yv.isUndefined(t))
            return 0;
        var e = t.match(Nv);
        return yv.isNull(e) ? 0 : parseFloat(e[1])
    }
    var Bv = {
        makeSelectable: function(t, e) {
            void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                return !1
            }
            : function() {}
            ,
            t.style.MozUserSelect = e ? "auto" : "none",
            t.style.KhtmlUserSelect = e ? "auto" : "none",
            t.unselectable = e ? "on" : "off")
        },
        makeFullscreen: function(t, e, n) {
            var i = n
              , r = e;
            yv.isUndefined(r) && (r = !0),
            yv.isUndefined(i) && (i = !0),
            t.style.position = "absolute",
            r && (t.style.left = 0,
            t.style.right = 0),
            i && (t.style.top = 0,
            t.style.bottom = 0)
        },
        fakeEvent: function(t, e, n, i) {
            var r = n || {}
              , s = kv[e];
            if (!s)
                throw new Error("Event type " + e + " not supported.");
            var o = document.createEvent(s);
            switch (s) {
            case "MouseEvents":
                var a = r.x || r.clientX || 0
                  , l = r.y || r.clientY || 0;
                o.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, a, l, !1, !1, !1, !1, 0, null);
                break;
            case "KeyboardEvents":
                var c = o.initKeyboardEvent || o.initKeyEvent;
                yv.defaults(r, {
                    cancelable: !0,
                    ctrlKey: !1,
                    altKey: !1,
                    shiftKey: !1,
                    metaKey: !1,
                    keyCode: void 0,
                    charCode: void 0
                }),
                c(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                break;
            default:
                o.initEvent(e, r.bubbles || !1, r.cancelable || !0)
            }
            yv.defaults(o, i),
            t.dispatchEvent(o)
        },
        bind: function(t, e, n, i) {
            var r = i || !1;
            return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n),
            Bv
        },
        unbind: function(t, e, n, i) {
            var r = i || !1;
            return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n),
            Bv
        },
        addClass: function(t, e) {
            if (void 0 === t.className)
                t.className = e;
            else if (t.className !== e) {
                var n = t.className.split(/ +/);
                -1 === n.indexOf(e) && (n.push(e),
                t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
            }
            return Bv
        },
        removeClass: function(t, e) {
            if (e)
                if (t.className === e)
                    t.removeAttribute("class");
                else {
                    var n = t.className.split(/ +/)
                      , i = n.indexOf(e);
                    -1 !== i && (n.splice(i, 1),
                    t.className = n.join(" "))
                }
            else
                t.className = void 0;
            return Bv
        },
        hasClass: function(t, e) {
            return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
        },
        getWidth: function(t) {
            var e = getComputedStyle(t);
            return zv(e["border-left-width"]) + zv(e["border-right-width"]) + zv(e["padding-left"]) + zv(e["padding-right"]) + zv(e.width)
        },
        getHeight: function(t) {
            var e = getComputedStyle(t);
            return zv(e["border-top-width"]) + zv(e["border-bottom-width"]) + zv(e["padding-top"]) + zv(e["padding-bottom"]) + zv(e.height)
        },
        getOffset: function(t) {
            var e = t
              , n = {
                left: 0,
                top: 0
            };
            if (e.offsetParent)
                do {
                    n.left += e.offsetLeft,
                    n.top += e.offsetTop,
                    e = e.offsetParent
                } while (e);
            return n
        },
        isActive: function(t) {
            return t === document.activeElement && (t.type || t.href)
        }
    }
      , Fv = function(t) {
        function e(t, n) {
            Ev(this, e);
            var i = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
              , r = i;
            return i.__prev = i.getValue(),
            i.__checkbox = document.createElement("input"),
            i.__checkbox.setAttribute("type", "checkbox"),
            Bv.bind(i.__checkbox, "change", (function() {
                r.setValue(!r.__prev)
            }
            ), !1),
            i.domElement.appendChild(i.__checkbox),
            i.updateDisplay(),
            i
        }
        return Lv(e, t),
        Av(e, [{
            key: "setValue",
            value: function(t) {
                var n = Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                this.__prev = this.getValue(),
                n
            }
        }, {
            key: "updateDisplay",
            value: function() {
                return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"),
                this.__checkbox.checked = !0,
                this.__prev = !0) : (this.__checkbox.checked = !1,
                this.__prev = !1),
                Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]),
        e
    }(Ov)
      , Uv = function(t) {
        function e(t, n, i) {
            Ev(this, e);
            var r = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
              , s = i
              , o = r;
            if (r.__select = document.createElement("select"),
            yv.isArray(s)) {
                var a = {};
                yv.each(s, (function(t) {
                    a[t] = t
                }
                )),
                s = a
            }
            return yv.each(s, (function(t, e) {
                var n = document.createElement("option");
                n.innerHTML = e,
                n.setAttribute("value", t),
                o.__select.appendChild(n)
            }
            )),
            r.updateDisplay(),
            Bv.bind(r.__select, "change", (function() {
                var t = this.options[this.selectedIndex].value;
                o.setValue(t)
            }
            )),
            r.domElement.appendChild(r.__select),
            r
        }
        return Lv(e, t),
        Av(e, [{
            key: "setValue",
            value: function(t) {
                var n = Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()),
                n
            }
        }, {
            key: "updateDisplay",
            value: function() {
                return Bv.isActive(this.__select) ? this : (this.__select.value = this.getValue(),
                Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
            }
        }]),
        e
    }(Ov)
      , Hv = function(t) {
        function e(t, n) {
            Ev(this, e);
            var i = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
              , r = i;
            function s() {
                r.setValue(r.__input.value)
            }
            return i.__input = document.createElement("input"),
            i.__input.setAttribute("type", "text"),
            Bv.bind(i.__input, "keyup", s),
            Bv.bind(i.__input, "change", s),
            Bv.bind(i.__input, "blur", (function() {
                r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
            }
            )),
            Bv.bind(i.__input, "keydown", (function(t) {
                13 === t.keyCode && this.blur()
            }
            )),
            i.updateDisplay(),
            i.domElement.appendChild(i.__input),
            i
        }
        return Lv(e, t),
        Av(e, [{
            key: "updateDisplay",
            value: function() {
                return Bv.isActive(this.__input) || (this.__input.value = this.getValue()),
                Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]),
        e
    }(Ov);
    function Vv(t) {
        var e = t.toString();
        return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
    }
    var Gv = function(t) {
        function e(t, n, i) {
            Ev(this, e);
            var r = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
              , s = i || {};
            return r.__min = s.min,
            r.__max = s.max,
            r.__step = s.step,
            yv.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step,
            r.__precision = Vv(r.__impliedStep),
            r
        }
        return Lv(e, t),
        Av(e, [{
            key: "setValue",
            value: function(t) {
                var n = t;
                return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max),
                void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step),
                Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n)
            }
        }, {
            key: "min",
            value: function(t) {
                return this.__min = t,
                this
            }
        }, {
            key: "max",
            value: function(t) {
                return this.__max = t,
                this
            }
        }, {
            key: "step",
            value: function(t) {
                return this.__step = t,
                this.__impliedStep = t,
                this.__precision = Vv(t),
                this
            }
        }]),
        e
    }(Ov)
      , Wv = function(t) {
        function e(t, n, i) {
            Ev(this, e);
            var r = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i));
            r.__truncationSuspended = !1;
            var s = r
              , o = void 0;
            function a() {
                s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
            }
            function l(t) {
                var e = o - t.clientY;
                s.setValue(s.getValue() + e * s.__impliedStep),
                o = t.clientY
            }
            function c() {
                Bv.unbind(window, "mousemove", l),
                Bv.unbind(window, "mouseup", c),
                a()
            }
            return r.__input = document.createElement("input"),
            r.__input.setAttribute("type", "text"),
            Bv.bind(r.__input, "change", (function() {
                var t = parseFloat(s.__input.value);
                yv.isNaN(t) || s.setValue(t)
            }
            )),
            Bv.bind(r.__input, "blur", (function() {
                a()
            }
            )),
            Bv.bind(r.__input, "mousedown", (function(t) {
                Bv.bind(window, "mousemove", l),
                Bv.bind(window, "mouseup", c),
                o = t.clientY
            }
            )),
            Bv.bind(r.__input, "keydown", (function(t) {
                13 === t.keyCode && (s.__truncationSuspended = !0,
                this.blur(),
                s.__truncationSuspended = !1,
                a())
            }
            )),
            r.updateDisplay(),
            r.domElement.appendChild(r.__input),
            r
        }
        return Lv(e, t),
        Av(e, [{
            key: "updateDisplay",
            value: function() {
                var t, n, i;
                return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(),
                n = this.__precision,
                i = Math.pow(10, n),
                Math.round(t * i) / i),
                Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]),
        e
    }(Gv);
    function jv(t, e, n, i, r) {
        return i + (t - e) / (n - e) * (r - i)
    }
    var Xv = function(t) {
        function e(t, n, i, r, s) {
            Ev(this, e);
            var o = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
                min: i,
                max: r,
                step: s
            }))
              , a = o;
            function l(t) {
                t.preventDefault();
                var e = a.__background.getBoundingClientRect();
                return a.setValue(jv(t.clientX, e.left, e.right, a.__min, a.__max)),
                !1
            }
            function c() {
                Bv.unbind(window, "mousemove", l),
                Bv.unbind(window, "mouseup", c),
                a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
            }
            function h(t) {
                var e = t.touches[0].clientX
                  , n = a.__background.getBoundingClientRect();
                a.setValue(jv(e, n.left, n.right, a.__min, a.__max))
            }
            function u() {
                Bv.unbind(window, "touchmove", h),
                Bv.unbind(window, "touchend", u),
                a.__onFinishChange && a.__onFinishChange.call(a, a.getValue())
            }
            return o.__background = document.createElement("div"),
            o.__foreground = document.createElement("div"),
            Bv.bind(o.__background, "mousedown", (function(t) {
                document.activeElement.blur(),
                Bv.bind(window, "mousemove", l),
                Bv.bind(window, "mouseup", c),
                l(t)
            }
            )),
            Bv.bind(o.__background, "touchstart", (function(t) {
                1 === t.touches.length && (Bv.bind(window, "touchmove", h),
                Bv.bind(window, "touchend", u),
                h(t))
            }
            )),
            Bv.addClass(o.__background, "slider"),
            Bv.addClass(o.__foreground, "slider-fg"),
            o.updateDisplay(),
            o.__background.appendChild(o.__foreground),
            o.domElement.appendChild(o.__background),
            o
        }
        return Lv(e, t),
        Av(e, [{
            key: "updateDisplay",
            value: function() {
                var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                return this.__foreground.style.width = 100 * t + "%",
                Rv(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]),
        e
    }(Gv)
      , qv = function(t) {
        function e(t, n, i) {
            Ev(this, e);
            var r = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n))
              , s = r;
            return r.__button = document.createElement("div"),
            r.__button.innerHTML = void 0 === i ? "Fire" : i,
            Bv.bind(r.__button, "click", (function(t) {
                return t.preventDefault(),
                s.fire(),
                !1
            }
            )),
            Bv.addClass(r.__button, "button"),
            r.domElement.appendChild(r.__button),
            r
        }
        return Lv(e, t),
        Av(e, [{
            key: "fire",
            value: function() {
                this.__onChange && this.__onChange.call(this),
                this.getValue().call(this.object),
                this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
            }
        }]),
        e
    }(Ov)
      , Yv = function(t) {
        function e(t, n) {
            Ev(this, e);
            var i = Cv(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
            i.__color = new Pv(i.getValue()),
            i.__temp = new Pv(0);
            var r = i;
            i.domElement = document.createElement("div"),
            Bv.makeSelectable(i.domElement, !1),
            i.__selector = document.createElement("div"),
            i.__selector.className = "selector",
            i.__saturation_field = document.createElement("div"),
            i.__saturation_field.className = "saturation-field",
            i.__field_knob = document.createElement("div"),
            i.__field_knob.className = "field-knob",
            i.__field_knob_border = "2px solid ",
            i.__hue_knob = document.createElement("div"),
            i.__hue_knob.className = "hue-knob",
            i.__hue_field = document.createElement("div"),
            i.__hue_field.className = "hue-field",
            i.__input = document.createElement("input"),
            i.__input.type = "text",
            i.__input_textShadow = "0 1px 1px ",
            Bv.bind(i.__input, "keydown", (function(t) {
                13 === t.keyCode && u.call(this)
            }
            )),
            Bv.bind(i.__input, "blur", u),
            Bv.bind(i.__selector, "mousedown", (function() {
                Bv.addClass(this, "drag").bind(window, "mouseup", (function() {
                    Bv.removeClass(r.__selector, "drag")
                }
                ))
            }
            )),
            Bv.bind(i.__selector, "touchstart", (function() {
                Bv.addClass(this, "drag").bind(window, "touchend", (function() {
                    Bv.removeClass(r.__selector, "drag")
                }
                ))
            }
            ));
            var s, o = document.createElement("div");
            function a(t) {
                p(t),
                Bv.bind(window, "mousemove", p),
                Bv.bind(window, "touchmove", p),
                Bv.bind(window, "mouseup", c),
                Bv.bind(window, "touchend", c)
            }
            function l(t) {
                f(t),
                Bv.bind(window, "mousemove", f),
                Bv.bind(window, "touchmove", f),
                Bv.bind(window, "mouseup", h),
                Bv.bind(window, "touchend", h)
            }
            function c() {
                Bv.unbind(window, "mousemove", p),
                Bv.unbind(window, "touchmove", p),
                Bv.unbind(window, "mouseup", c),
                Bv.unbind(window, "touchend", c),
                d()
            }
            function h() {
                Bv.unbind(window, "mousemove", f),
                Bv.unbind(window, "touchmove", f),
                Bv.unbind(window, "mouseup", h),
                Bv.unbind(window, "touchend", h),
                d()
            }
            function u() {
                var t = wv(this.value);
                !1 !== t ? (r.__color.__state = t,
                r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString()
            }
            function d() {
                r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal())
            }
            function p(t) {
                -1 === t.type.indexOf("touch") && t.preventDefault();
                var e = r.__saturation_field.getBoundingClientRect()
                  , n = t.touches && t.touches[0] || t
                  , i = n.clientX
                  , s = n.clientY
                  , o = (i - e.left) / (e.right - e.left)
                  , a = 1 - (s - e.top) / (e.bottom - e.top);
                return a > 1 ? a = 1 : a < 0 && (a = 0),
                o > 1 ? o = 1 : o < 0 && (o = 0),
                r.__color.v = a,
                r.__color.s = o,
                r.setValue(r.__color.toOriginal()),
                !1
            }
            function f(t) {
                -1 === t.type.indexOf("touch") && t.preventDefault();
                var e = r.__hue_field.getBoundingClientRect()
                  , n = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
                return n > 1 ? n = 1 : n < 0 && (n = 0),
                r.__color.h = 360 * n,
                r.setValue(r.__color.toOriginal()),
                !1
            }
            return yv.extend(i.__selector.style, {
                width: "122px",
                height: "102px",
                padding: "3px",
                backgroundColor: "#222",
                boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
            }),
            yv.extend(i.__field_knob.style, {
                position: "absolute",
                width: "12px",
                height: "12px",
                border: i.__field_knob_border + (i.__color.v < .5 ? "#fff" : "#000"),
                boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                borderRadius: "12px",
                zIndex: 1
            }),
            yv.extend(i.__hue_knob.style, {
                position: "absolute",
                width: "15px",
                height: "2px",
                borderRight: "4px solid #fff",
                zIndex: 1
            }),
            yv.extend(i.__saturation_field.style, {
                width: "100px",
                height: "100px",
                border: "1px solid #555",
                marginRight: "3px",
                display: "inline-block",
                cursor: "pointer"
            }),
            yv.extend(o.style, {
                width: "100%",
                height: "100%",
                background: "none"
            }),
            Jv(o, "top", "rgba(0,0,0,0)", "#000"),
            yv.extend(i.__hue_field.style, {
                width: "15px",
                height: "100px",
                border: "1px solid #555",
                cursor: "ns-resize",
                position: "absolute",
                top: "3px",
                right: "3px"
            }),
            (s = i.__hue_field).style.background = "",
            s.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",
            s.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
            s.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
            s.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
            s.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",
            yv.extend(i.__input.style, {
                outline: "none",
                textAlign: "center",
                color: "#fff",
                border: 0,
                fontWeight: "bold",
                textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)"
            }),
            Bv.bind(i.__saturation_field, "mousedown", a),
            Bv.bind(i.__saturation_field, "touchstart", a),
            Bv.bind(i.__field_knob, "mousedown", a),
            Bv.bind(i.__field_knob, "touchstart", a),
            Bv.bind(i.__hue_field, "mousedown", l),
            Bv.bind(i.__hue_field, "touchstart", l),
            i.__saturation_field.appendChild(o),
            i.__selector.appendChild(i.__field_knob),
            i.__selector.appendChild(i.__saturation_field),
            i.__selector.appendChild(i.__hue_field),
            i.__hue_field.appendChild(i.__hue_knob),
            i.domElement.appendChild(i.__input),
            i.domElement.appendChild(i.__selector),
            i.updateDisplay(),
            i
        }
        return Lv(e, t),
        Av(e, [{
            key: "updateDisplay",
            value: function() {
                var t = wv(this.getValue());
                if (!1 !== t) {
                    var e = !1;
                    yv.each(Pv.COMPONENTS, (function(n) {
                        if (!yv.isUndefined(t[n]) && !yv.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n])
                            return e = !0,
                            {}
                    }
                    ), this),
                    e && yv.extend(this.__color.__state, t)
                }
                yv.extend(this.__temp.__state, this.__color.__state),
                this.__temp.a = 1;
                var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0
                  , i = 255 - n;
                yv.extend(this.__field_knob.style, {
                    marginLeft: 100 * this.__color.s - 7 + "px",
                    marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                    backgroundColor: this.__temp.toHexString(),
                    border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                }),
                this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px",
                this.__temp.s = 1,
                this.__temp.v = 1,
                Jv(this.__saturation_field, "left", "#fff", this.__temp.toHexString()),
                this.__input.value = this.__color.toString(),
                yv.extend(this.__input.style, {
                    backgroundColor: this.__color.toHexString(),
                    color: "rgb(" + n + "," + n + "," + n + ")",
                    textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)"
                })
            }
        }]),
        e
    }(Ov)
      , Zv = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
    function Jv(t, e, n, i) {
        t.style.background = "",
        yv.each(Zv, (function(r) {
            t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + n + " 0%, " + i + " 100%); "
        }
        ))
    }
    var Kv = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'
      , Qv = function(t, e) {
        var n = t[e];
        return yv.isArray(arguments[2]) || yv.isObject(arguments[2]) ? new Uv(t,e,arguments[2]) : yv.isNumber(n) ? yv.isNumber(arguments[2]) && yv.isNumber(arguments[3]) ? yv.isNumber(arguments[4]) ? new Xv(t,e,arguments[2],arguments[3],arguments[4]) : new Xv(t,e,arguments[2],arguments[3]) : yv.isNumber(arguments[4]) ? new Wv(t,e,{
            min: arguments[2],
            max: arguments[3],
            step: arguments[4]
        }) : new Wv(t,e,{
            min: arguments[2],
            max: arguments[3]
        }) : yv.isString(n) ? new Hv(t,e) : yv.isFunction(n) ? new qv(t,e,"") : yv.isBoolean(n) ? new Fv(t,e) : null
    }
      , $v = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
        setTimeout(t, 1e3 / 60)
    }
      , ty = function() {
        function t() {
            Ev(this, t),
            this.backgroundElement = document.createElement("div"),
            yv.extend(this.backgroundElement.style, {
                backgroundColor: "rgba(0,0,0,0.8)",
                top: 0,
                left: 0,
                display: "none",
                zIndex: "1000",
                opacity: 0,
                WebkitTransition: "opacity 0.2s linear",
                transition: "opacity 0.2s linear"
            }),
            Bv.makeFullscreen(this.backgroundElement),
            this.backgroundElement.style.position = "fixed",
            this.domElement = document.createElement("div"),
            yv.extend(this.domElement.style, {
                position: "fixed",
                display: "none",
                zIndex: "1001",
                opacity: 0,
                WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                transition: "transform 0.2s ease-out, opacity 0.2s linear"
            }),
            document.body.appendChild(this.backgroundElement),
            document.body.appendChild(this.domElement);
            var e = this;
            Bv.bind(this.backgroundElement, "click", (function() {
                e.hide()
            }
            ))
        }
        return Av(t, [{
            key: "show",
            value: function() {
                var t = this;
                this.backgroundElement.style.display = "block",
                this.domElement.style.display = "block",
                this.domElement.style.opacity = 0,
                this.domElement.style.webkitTransform = "scale(1.1)",
                this.layout(),
                yv.defer((function() {
                    t.backgroundElement.style.opacity = 1,
                    t.domElement.style.opacity = 1,
                    t.domElement.style.webkitTransform = "scale(1)"
                }
                ))
            }
        }, {
            key: "hide",
            value: function() {
                var t = this
                  , e = function e() {
                    t.domElement.style.display = "none",
                    t.backgroundElement.style.display = "none",
                    Bv.unbind(t.domElement, "webkitTransitionEnd", e),
                    Bv.unbind(t.domElement, "transitionend", e),
                    Bv.unbind(t.domElement, "oTransitionEnd", e)
                };
                Bv.bind(this.domElement, "webkitTransitionEnd", e),
                Bv.bind(this.domElement, "transitionend", e),
                Bv.bind(this.domElement, "oTransitionEnd", e),
                this.backgroundElement.style.opacity = 0,
                this.domElement.style.opacity = 0,
                this.domElement.style.webkitTransform = "scale(1.1)"
            }
        }, {
            key: "layout",
            value: function() {
                this.domElement.style.left = window.innerWidth / 2 - Bv.getWidth(this.domElement) / 2 + "px",
                this.domElement.style.top = window.innerHeight / 2 - Bv.getHeight(this.domElement) / 2 + "px"
            }
        }]),
        t
    }();
    !function(t, e) {
        var n = e || document
          , i = document.createElement("style");
        i.type = "text/css",
        i.innerHTML = t;
        var r = n.getElementsByTagName("head")[0];
        try {
            r.appendChild(i)
        } catch (t) {}
    }(function(t) {
        if ("undefined" != typeof window) {
            var e = document.createElement("style");
            return e.setAttribute("type", "text/css"),
            e.innerHTML = t,
            document.head.appendChild(e),
            t
        }
    }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
    var ey = "Default"
      , ny = function() {
        try {
            return !!window.localStorage
        } catch (t) {
            return !1
        }
    }()
      , iy = void 0
      , ry = !0
      , sy = void 0
      , oy = !1
      , ay = []
      , ly = function t(e) {
        var n = this
          , i = e || {};
        this.domElement = document.createElement("div"),
        this.__ul = document.createElement("ul"),
        this.domElement.appendChild(this.__ul),
        Bv.addClass(this.domElement, "dg"),
        this.__folders = {},
        this.__controllers = [],
        this.__rememberedObjects = [],
        this.__rememberedObjectIndecesToControllers = [],
        this.__listening = [],
        i = yv.defaults(i, {
            closeOnTop: !1,
            autoPlace: !0,
            width: t.DEFAULT_WIDTH
        }),
        i = yv.defaults(i, {
            resizable: i.autoPlace,
            hideable: i.autoPlace
        }),
        yv.isUndefined(i.load) ? i.load = {
            preset: ey
        } : i.preset && (i.load.preset = i.preset),
        yv.isUndefined(i.parent) && i.hideable && ay.push(this),
        i.resizable = yv.isUndefined(i.parent) && i.resizable,
        i.autoPlace && yv.isUndefined(i.scrollable) && (i.scrollable = !0);
        var r, s = ny && "true" === localStorage.getItem(fy(0, "isLocal")), o = void 0, a = void 0;
        if (Object.defineProperties(this, {
            parent: {
                get: function() {
                    return i.parent
                }
            },
            scrollable: {
                get: function() {
                    return i.scrollable
                }
            },
            autoPlace: {
                get: function() {
                    return i.autoPlace
                }
            },
            closeOnTop: {
                get: function() {
                    return i.closeOnTop
                }
            },
            preset: {
                get: function() {
                    return n.parent ? n.getRoot().preset : i.load.preset
                },
                set: function(t) {
                    n.parent ? n.getRoot().preset = t : i.load.preset = t,
                    function(t) {
                        for (var e = 0; e < t.__preset_select.length; e++)
                            t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
                    }(this),
                    n.revert()
                }
            },
            width: {
                get: function() {
                    return i.width
                },
                set: function(t) {
                    i.width = t,
                    _y(n, t)
                }
            },
            name: {
                get: function() {
                    return i.name
                },
                set: function(t) {
                    i.name = t,
                    a && (a.innerHTML = i.name)
                }
            },
            closed: {
                get: function() {
                    return i.closed
                },
                set: function(e) {
                    i.closed = e,
                    i.closed ? Bv.addClass(n.__ul, t.CLASS_CLOSED) : Bv.removeClass(n.__ul, t.CLASS_CLOSED),
                    this.onResize(),
                    n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                }
            },
            load: {
                get: function() {
                    return i.load
                }
            },
            useLocalStorage: {
                get: function() {
                    return s
                },
                set: function(t) {
                    ny && (s = t,
                    t ? Bv.bind(window, "unload", o) : Bv.unbind(window, "unload", o),
                    localStorage.setItem(fy(0, "isLocal"), t))
                }
            }
        }),
        yv.isUndefined(i.parent)) {
            if (this.closed = i.closed || !1,
            Bv.addClass(this.domElement, t.CLASS_MAIN),
            Bv.makeSelectable(this.domElement, !1),
            ny && s) {
                n.useLocalStorage = !0;
                var l = localStorage.getItem(fy(0, "gui"));
                l && (i.load = JSON.parse(l))
            }
            this.__closeButton = document.createElement("div"),
            this.__closeButton.innerHTML = t.TEXT_CLOSED,
            Bv.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON),
            i.closeOnTop ? (Bv.addClass(this.__closeButton, t.CLASS_CLOSE_TOP),
            this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Bv.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM),
            this.domElement.appendChild(this.__closeButton)),
            Bv.bind(this.__closeButton, "click", (function() {
                n.closed = !n.closed
            }
            ))
        } else {
            void 0 === i.closed && (i.closed = !0);
            var c = document.createTextNode(i.name);
            Bv.addClass(c, "controller-name"),
            a = cy(n, c),
            Bv.addClass(this.__ul, t.CLASS_CLOSED),
            Bv.addClass(a, "title"),
            Bv.bind(a, "click", (function(t) {
                return t.preventDefault(),
                n.closed = !n.closed,
                !1
            }
            )),
            i.closed || (this.closed = !1)
        }
        i.autoPlace && (yv.isUndefined(i.parent) && (ry && (sy = document.createElement("div"),
        Bv.addClass(sy, "dg"),
        Bv.addClass(sy, t.CLASS_AUTO_PLACE_CONTAINER),
        document.body.appendChild(sy),
        ry = !1),
        sy.appendChild(this.domElement),
        Bv.addClass(this.domElement, t.CLASS_AUTO_PLACE)),
        this.parent || _y(n, i.width)),
        this.__resizeHandler = function() {
            n.onResizeDebounced()
        }
        ,
        Bv.bind(window, "resize", this.__resizeHandler),
        Bv.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
        Bv.bind(this.__ul, "transitionend", this.__resizeHandler),
        Bv.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
        this.onResize(),
        i.resizable && yy(this),
        o = function() {
            ny && "true" === localStorage.getItem(fy(0, "isLocal")) && localStorage.setItem(fy(0, "gui"), JSON.stringify(n.getSaveObject()))
        }
        ,
        this.saveToLocalStorageIfPossible = o,
        i.parent || ((r = n.getRoot()).width += 1,
        yv.defer((function() {
            r.width -= 1
        }
        )))
    };
    function cy(t, e, n) {
        var i = document.createElement("li");
        return e && i.appendChild(e),
        n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i),
        t.onResize(),
        i
    }
    function hy(t) {
        Bv.unbind(window, "resize", t.__resizeHandler),
        t.saveToLocalStorageIfPossible && Bv.unbind(window, "unload", t.saveToLocalStorageIfPossible)
    }
    function uy(t, e) {
        var n = t.__preset_select[t.__preset_select.selectedIndex];
        n.innerHTML = e ? n.value + "*" : n.value
    }
    function dy(t, e) {
        var n = t.getRoot()
          , i = n.__rememberedObjects.indexOf(e.object);
        if (-1 !== i) {
            var r = n.__rememberedObjectIndecesToControllers[i];
            if (void 0 === r && (r = {},
            n.__rememberedObjectIndecesToControllers[i] = r),
            r[e.property] = e,
            n.load && n.load.remembered) {
                var s = n.load.remembered
                  , o = void 0;
                if (s[t.preset])
                    o = s[t.preset];
                else {
                    if (!s.Default)
                        return;
                    o = s.Default
                }
                if (o[i] && void 0 !== o[i][e.property]) {
                    var a = o[i][e.property];
                    e.initialValue = a,
                    e.setValue(a)
                }
            }
        }
    }
    function py(t, e, n, i) {
        if (void 0 === e[n])
            throw new Error('Object "' + e + '" has no property "' + n + '"');
        var r = void 0;
        if (i.color)
            r = new Yv(e,n);
        else {
            var s = [e, n].concat(i.factoryArgs);
            r = Qv.apply(t, s)
        }
        i.before instanceof Ov && (i.before = i.before.__li),
        dy(t, r),
        Bv.addClass(r.domElement, "c");
        var o = document.createElement("span");
        Bv.addClass(o, "property-name"),
        o.innerHTML = r.property;
        var a = document.createElement("div");
        a.appendChild(o),
        a.appendChild(r.domElement);
        var l = cy(t, a, i.before);
        return Bv.addClass(l, ly.CLASS_CONTROLLER_ROW),
        r instanceof Yv ? Bv.addClass(l, "color") : Bv.addClass(l, Tv(r.getValue())),
        function(t, e, n) {
            if (n.__li = e,
            n.__gui = t,
            yv.extend(n, {
                options: function(e) {
                    if (arguments.length > 1) {
                        var i = n.__li.nextElementSibling;
                        return n.remove(),
                        py(t, n.object, n.property, {
                            before: i,
                            factoryArgs: [yv.toArray(arguments)]
                        })
                    }
                    if (yv.isArray(e) || yv.isObject(e)) {
                        var r = n.__li.nextElementSibling;
                        return n.remove(),
                        py(t, n.object, n.property, {
                            before: r,
                            factoryArgs: [e]
                        })
                    }
                },
                name: function(t) {
                    return n.__li.firstElementChild.firstElementChild.innerHTML = t,
                    n
                },
                listen: function() {
                    return n.__gui.listen(n),
                    n
                },
                remove: function() {
                    return n.__gui.remove(n),
                    n
                }
            }),
            n instanceof Xv) {
                var i = new Wv(n.object,n.property,{
                    min: n.__min,
                    max: n.__max,
                    step: n.__step
                });
                yv.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function(t) {
                    var e = n[t]
                      , r = i[t];
                    n[t] = i[t] = function() {
                        var t = Array.prototype.slice.call(arguments);
                        return r.apply(i, t),
                        e.apply(n, t)
                    }
                }
                )),
                Bv.addClass(e, "has-slider"),
                n.domElement.insertBefore(i.domElement, n.domElement.firstElementChild)
            } else if (n instanceof Wv) {
                var r = function(e) {
                    if (yv.isNumber(n.__min) && yv.isNumber(n.__max)) {
                        var i = n.__li.firstElementChild.firstElementChild.innerHTML
                          , r = n.__gui.__listening.indexOf(n) > -1;
                        n.remove();
                        var s = py(t, n.object, n.property, {
                            before: n.__li.nextElementSibling,
                            factoryArgs: [n.__min, n.__max, n.__step]
                        });
                        return s.name(i),
                        r && s.listen(),
                        s
                    }
                    return e
                };
                n.min = yv.compose(r, n.min),
                n.max = yv.compose(r, n.max)
            } else
                n instanceof Fv ? (Bv.bind(e, "click", (function() {
                    Bv.fakeEvent(n.__checkbox, "click")
                }
                )),
                Bv.bind(n.__checkbox, "click", (function(t) {
                    t.stopPropagation()
                }
                ))) : n instanceof qv ? (Bv.bind(e, "click", (function() {
                    Bv.fakeEvent(n.__button, "click")
                }
                )),
                Bv.bind(e, "mouseover", (function() {
                    Bv.addClass(n.__button, "hover")
                }
                )),
                Bv.bind(e, "mouseout", (function() {
                    Bv.removeClass(n.__button, "hover")
                }
                ))) : n instanceof Yv && (Bv.addClass(e, "color"),
                n.updateDisplay = yv.compose((function(t) {
                    return e.style.borderLeftColor = n.__color.toString(),
                    t
                }
                ), n.updateDisplay),
                n.updateDisplay());
            n.setValue = yv.compose((function(e) {
                return t.getRoot().__preset_select && n.isModified() && uy(t.getRoot(), !0),
                e
            }
            ), n.setValue)
        }(t, l, r),
        t.__controllers.push(r),
        r
    }
    function fy(t, e) {
        return document.location.href + "." + e
    }
    function my(t, e, n) {
        var i = document.createElement("option");
        i.innerHTML = e,
        i.value = e,
        t.__preset_select.appendChild(i),
        n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
    }
    function gy(t, e) {
        e.style.display = t.useLocalStorage ? "block" : "none"
    }
    function vy(t) {
        var e = t.__save_row = document.createElement("li");
        Bv.addClass(t.domElement, "has-save"),
        t.__ul.insertBefore(e, t.__ul.firstChild),
        Bv.addClass(e, "save-row");
        var n = document.createElement("span");
        n.innerHTML = "&nbsp;",
        Bv.addClass(n, "button gears");
        var i = document.createElement("span");
        i.innerHTML = "Save",
        Bv.addClass(i, "button"),
        Bv.addClass(i, "save");
        var r = document.createElement("span");
        r.innerHTML = "New",
        Bv.addClass(r, "button"),
        Bv.addClass(r, "save-as");
        var s = document.createElement("span");
        s.innerHTML = "Revert",
        Bv.addClass(s, "button"),
        Bv.addClass(s, "revert");
        var o = t.__preset_select = document.createElement("select");
        if (t.load && t.load.remembered ? yv.each(t.load.remembered, (function(e, n) {
            my(t, n, n === t.preset)
        }
        )) : my(t, ey, !1),
        Bv.bind(o, "change", (function() {
            for (var e = 0; e < t.__preset_select.length; e++)
                t.__preset_select[e].innerHTML = t.__preset_select[e].value;
            t.preset = this.value
        }
        )),
        e.appendChild(o),
        e.appendChild(n),
        e.appendChild(i),
        e.appendChild(r),
        e.appendChild(s),
        ny) {
            var a = document.getElementById("dg-local-explain")
              , l = document.getElementById("dg-local-storage");
            document.getElementById("dg-save-locally").style.display = "block",
            "true" === localStorage.getItem(fy(0, "isLocal")) && l.setAttribute("checked", "checked"),
            gy(t, a),
            Bv.bind(l, "change", (function() {
                t.useLocalStorage = !t.useLocalStorage,
                gy(t, a)
            }
            ))
        }
        var c = document.getElementById("dg-new-constructor");
        Bv.bind(c, "keydown", (function(t) {
            !t.metaKey || 67 !== t.which && 67 !== t.keyCode || iy.hide()
        }
        )),
        Bv.bind(n, "click", (function() {
            c.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2),
            iy.show(),
            c.focus(),
            c.select()
        }
        )),
        Bv.bind(i, "click", (function() {
            t.save()
        }
        )),
        Bv.bind(r, "click", (function() {
            var e = prompt("Enter a new preset name.");
            e && t.saveAs(e)
        }
        )),
        Bv.bind(s, "click", (function() {
            t.revert()
        }
        ))
    }
    function yy(t) {
        var e = void 0;
        function n(n) {
            return n.preventDefault(),
            t.width += e - n.clientX,
            t.onResize(),
            e = n.clientX,
            !1
        }
        function i() {
            Bv.removeClass(t.__closeButton, ly.CLASS_DRAG),
            Bv.unbind(window, "mousemove", n),
            Bv.unbind(window, "mouseup", i)
        }
        function r(r) {
            return r.preventDefault(),
            e = r.clientX,
            Bv.addClass(t.__closeButton, ly.CLASS_DRAG),
            Bv.bind(window, "mousemove", n),
            Bv.bind(window, "mouseup", i),
            !1
        }
        t.__resize_handle = document.createElement("div"),
        yv.extend(t.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute"
        }),
        Bv.bind(t.__resize_handle, "mousedown", r),
        Bv.bind(t.__closeButton, "mousedown", r),
        t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
    }
    function _y(t, e) {
        t.domElement.style.width = e + "px",
        t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"),
        t.__closeButton && (t.__closeButton.style.width = e + "px")
    }
    function xy(t, e) {
        var n = {};
        return yv.each(t.__rememberedObjects, (function(i, r) {
            var s = {}
              , o = t.__rememberedObjectIndecesToControllers[r];
            yv.each(o, (function(t, n) {
                s[n] = e ? t.initialValue : t.getValue()
            }
            )),
            n[r] = s
        }
        )),
        n
    }
    function by(t) {
        0 !== t.length && $v.call(window, (function() {
            by(t)
        }
        )),
        yv.each(t, (function(t) {
            t.updateDisplay()
        }
        ))
    }
    ly.toggleHide = function() {
        oy = !oy,
        yv.each(ay, (function(t) {
            t.domElement.style.display = oy ? "none" : ""
        }
        ))
    }
    ,
    ly.CLASS_AUTO_PLACE = "a",
    ly.CLASS_AUTO_PLACE_CONTAINER = "ac",
    ly.CLASS_MAIN = "main",
    ly.CLASS_CONTROLLER_ROW = "cr",
    ly.CLASS_TOO_TALL = "taller-than-window",
    ly.CLASS_CLOSED = "closed",
    ly.CLASS_CLOSE_BUTTON = "close-button",
    ly.CLASS_CLOSE_TOP = "close-top",
    ly.CLASS_CLOSE_BOTTOM = "close-bottom",
    ly.CLASS_DRAG = "drag",
    ly.DEFAULT_WIDTH = 245,
    ly.TEXT_CLOSED = "Close Controls",
    ly.TEXT_OPEN = "Open Controls",
    ly._keydownHandler = function(t) {
        "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || ly.toggleHide()
    }
    ,
    Bv.bind(window, "keydown", ly._keydownHandler, !1),
    yv.extend(ly.prototype, {
        add: function(t, e) {
            return py(this, t, e, {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
            })
        },
        addColor: function(t, e) {
            return py(this, t, e, {
                color: !0
            })
        },
        remove: function(t) {
            this.__ul.removeChild(t.__li),
            this.__controllers.splice(this.__controllers.indexOf(t), 1);
            var e = this;
            yv.defer((function() {
                e.onResize()
            }
            ))
        },
        destroy: function() {
            if (this.parent)
                throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
            this.autoPlace && sy.removeChild(this.domElement);
            var t = this;
            yv.each(this.__folders, (function(e) {
                t.removeFolder(e)
            }
            )),
            Bv.unbind(window, "keydown", ly._keydownHandler, !1),
            hy(this)
        },
        addFolder: function(t) {
            if (void 0 !== this.__folders[t])
                throw new Error('You already have a folder in this GUI by the name "' + t + '"');
            var e = {
                name: t,
                parent: this
            };
            e.autoPlace = this.autoPlace,
            this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed,
            e.load = this.load.folders[t]);
            var n = new ly(e);
            this.__folders[t] = n;
            var i = cy(this, n.domElement);
            return Bv.addClass(i, "folder"),
            n
        },
        removeFolder: function(t) {
            this.__ul.removeChild(t.domElement.parentElement),
            delete this.__folders[t.name],
            this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name],
            hy(t);
            var e = this;
            yv.each(t.__folders, (function(e) {
                t.removeFolder(e)
            }
            )),
            yv.defer((function() {
                e.onResize()
            }
            ))
        },
        open: function() {
            this.closed = !1
        },
        close: function() {
            this.closed = !0
        },
        hide: function() {
            this.domElement.style.display = "none"
        },
        show: function() {
            this.domElement.style.display = ""
        },
        onResize: function() {
            var t = this.getRoot();
            if (t.scrollable) {
                var e = Bv.getOffset(t.__ul).top
                  , n = 0;
                yv.each(t.__ul.childNodes, (function(e) {
                    t.autoPlace && e === t.__save_row || (n += Bv.getHeight(e))
                }
                )),
                window.innerHeight - e - 20 < n ? (Bv.addClass(t.domElement, ly.CLASS_TOO_TALL),
                t.__ul.style.height = window.innerHeight - e - 20 + "px") : (Bv.removeClass(t.domElement, ly.CLASS_TOO_TALL),
                t.__ul.style.height = "auto")
            }
            t.__resize_handle && yv.defer((function() {
                t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
            }
            )),
            t.__closeButton && (t.__closeButton.style.width = t.width + "px")
        },
        onResizeDebounced: yv.debounce((function() {
            this.onResize()
        }
        ), 50),
        remember: function() {
            if (yv.isUndefined(iy) && ((iy = new ty).domElement.innerHTML = Kv),
            this.parent)
                throw new Error("You can only call remember on a top level GUI.");
            var t = this;
            yv.each(Array.prototype.slice.call(arguments), (function(e) {
                0 === t.__rememberedObjects.length && vy(t),
                -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
            }
            )),
            this.autoPlace && _y(this, this.width)
        },
        getRoot: function() {
            for (var t = this; t.parent; )
                t = t.parent;
            return t
        },
        getSaveObject: function() {
            var t = this.load;
            return t.closed = this.closed,
            this.__rememberedObjects.length > 0 && (t.preset = this.preset,
            t.remembered || (t.remembered = {}),
            t.remembered[this.preset] = xy(this)),
            t.folders = {},
            yv.each(this.__folders, (function(e, n) {
                t.folders[n] = e.getSaveObject()
            }
            )),
            t
        },
        save: function() {
            this.load.remembered || (this.load.remembered = {}),
            this.load.remembered[this.preset] = xy(this),
            uy(this, !1),
            this.saveToLocalStorageIfPossible()
        },
        saveAs: function(t) {
            this.load.remembered || (this.load.remembered = {},
            this.load.remembered.Default = xy(this, !0)),
            this.load.remembered[t] = xy(this),
            this.preset = t,
            my(this, t, !0),
            this.saveToLocalStorageIfPossible()
        },
        revert: function(t) {
            yv.each(this.__controllers, (function(e) {
                this.getRoot().load.remembered ? dy(t || this.getRoot(), e) : e.setValue(e.initialValue),
                e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
            }
            ), this),
            yv.each(this.__folders, (function(t) {
                t.revert(t)
            }
            )),
            t || uy(this.getRoot(), !1)
        },
        listen: function(t) {
            var e = 0 === this.__listening.length;
            this.__listening.push(t),
            e && by(this.__listening)
        },
        updateDisplay: function() {
            yv.each(this.__controllers, (function(t) {
                t.updateDisplay()
            }
            )),
            yv.each(this.__folders, (function(t) {
                t.updateDisplay()
            }
            ))
        }
    });
    var wy = ly
      , My = function() {
        var t = 0
          , e = document.createElement("div");
        function n(t) {
            return e.appendChild(t.dom),
            t
        }
        function i(n) {
            for (var i = 0; i < e.children.length; i++)
                e.children[i].style.display = i === n ? "block" : "none";
            t = n
        }
        e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
        e.addEventListener("click", (function(n) {
            n.preventDefault(),
            i(++t % e.children.length)
        }
        ), !1);
        var r = (performance || Date).now()
          , s = r
          , o = 0
          , a = n(new My.Panel("FPS","#0ff","#002"))
          , l = n(new My.Panel("MS","#0f0","#020"));
        if (self.performance && self.performance.memory)
            var c = n(new My.Panel("MB","#f08","#201"));
        return i(0),
        {
            REVISION: 16,
            dom: e,
            addPanel: n,
            showPanel: i,
            begin: function() {
                r = (performance || Date).now()
            },
            end: function() {
                o++;
                var t = (performance || Date).now();
                if (l.update(t - r, 200),
                t >= s + 1e3 && (a.update(1e3 * o / (t - s), 100),
                s = t,
                o = 0,
                c)) {
                    var e = performance.memory;
                    c.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
                }
                return t
            },
            update: function() {
                r = this.end()
            },
            domElement: e,
            setMode: i
        }
    };
    My.Panel = function(t, e, n) {
        var i = 1 / 0
          , r = 0
          , s = Math.round
          , o = s(window.devicePixelRatio || 1)
          , a = 80 * o
          , l = 48 * o
          , c = 3 * o
          , h = 2 * o
          , u = 3 * o
          , d = 15 * o
          , p = 74 * o
          , f = 30 * o
          , m = document.createElement("canvas");
        m.width = a,
        m.height = l,
        m.style.cssText = "width:80px;height:48px";
        var g = m.getContext("2d");
        return g.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif",
        g.textBaseline = "top",
        g.fillStyle = n,
        g.fillRect(0, 0, a, l),
        g.fillStyle = e,
        g.fillText(t, c, h),
        g.fillRect(u, d, p, f),
        g.fillStyle = n,
        g.globalAlpha = .9,
        g.fillRect(u, d, p, f),
        {
            dom: m,
            update: function(l, v) {
                i = Math.min(i, l),
                r = Math.max(r, l),
                g.fillStyle = n,
                g.globalAlpha = 1,
                g.fillRect(0, 0, a, d),
                g.fillStyle = e,
                g.fillText(s(l) + " " + t + " (" + s(i) + "-" + s(r) + ")", c, h),
                g.drawImage(m, u + o, d, p - o, f, u, d, p - o, f),
                g.fillRect(u + p - o, d, o, f),
                g.fillStyle = n,
                g.globalAlpha = .9,
                g.fillRect(u + p - o, d, o, s((1 - l / v) * f))
            }
        }
    }
    ;
    const Sy = My;
    var Ty = {}
      , Ey = function(t) {
        return URL.createObjectURL(new Blob([t],{
            type: "text/javascript"
        }))
    }
      , Ay = function(t) {
        return new Worker(t)
    };
    try {
        URL.revokeObjectURL(Ey(""))
    } catch (t) {
        Ey = function(t) {
            return "data:application/javascript;charset=UTF-8," + encodeURI(t)
        }
        ,
        Ay = function(t) {
            return new Worker(t,{
                type: "module"
            })
        }
    }
    var Ry = Uint8Array
      , Ly = Uint16Array
      , Cy = Uint32Array
      , Py = new Ry([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
      , Dy = new Ry([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
      , Iy = new Ry([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      , Oy = function(t, e) {
        for (var n = new Ly(31), i = 0; i < 31; ++i)
            n[i] = e += 1 << t[i - 1];
        var r = new Cy(n[30]);
        for (i = 1; i < 30; ++i)
            for (var s = n[i]; s < n[i + 1]; ++s)
                r[s] = s - n[i] << 5 | i;
        return [n, r]
    }
      , ky = Oy(Py, 2)
      , Ny = ky[0]
      , zy = ky[1];
    Ny[28] = 258,
    zy[258] = 28;
    for (var By = Oy(Dy, 0), Fy = By[0], Uy = By[1], Hy = new Ly(32768), Vy = 0; Vy < 32768; ++Vy) {
        var Gy = (43690 & Vy) >>> 1 | (21845 & Vy) << 1;
        Gy = (61680 & (Gy = (52428 & Gy) >>> 2 | (13107 & Gy) << 2)) >>> 4 | (3855 & Gy) << 4,
        Hy[Vy] = ((65280 & Gy) >>> 8 | (255 & Gy) << 8) >>> 1
    }
    var Wy = function(t, e, n) {
        for (var i = t.length, r = 0, s = new Ly(e); r < i; ++r)
            ++s[t[r] - 1];
        var o, a = new Ly(e);
        for (r = 0; r < e; ++r)
            a[r] = a[r - 1] + s[r - 1] << 1;
        if (n) {
            o = new Ly(1 << e);
            var l = 15 - e;
            for (r = 0; r < i; ++r)
                if (t[r])
                    for (var c = r << 4 | t[r], h = e - t[r], u = a[t[r] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)
                        o[Hy[u] >>> l] = c
        } else
            for (o = new Ly(i),
            r = 0; r < i; ++r)
                t[r] && (o[r] = Hy[a[t[r] - 1]++] >>> 15 - t[r]);
        return o
    }
      , jy = new Ry(288);
    for (Vy = 0; Vy < 144; ++Vy)
        jy[Vy] = 8;
    for (Vy = 144; Vy < 256; ++Vy)
        jy[Vy] = 9;
    for (Vy = 256; Vy < 280; ++Vy)
        jy[Vy] = 7;
    for (Vy = 280; Vy < 288; ++Vy)
        jy[Vy] = 8;
    var Xy = new Ry(32);
    for (Vy = 0; Vy < 32; ++Vy)
        Xy[Vy] = 5;
    var qy = Wy(jy, 9, 0)
      , Yy = Wy(jy, 9, 1)
      , Zy = Wy(Xy, 5, 0)
      , Jy = Wy(Xy, 5, 1)
      , Ky = function(t) {
        for (var e = t[0], n = 1; n < t.length; ++n)
            t[n] > e && (e = t[n]);
        return e
    }
      , Qy = function(t, e, n) {
        var i = e / 8 | 0;
        return (t[i] | t[i + 1] << 8) >> (7 & e) & n
    }
      , $y = function(t, e) {
        var n = e / 8 | 0;
        return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (7 & e)
    }
      , t_ = function(t) {
        return (t / 8 | 0) + (7 & t && 1)
    }
      , e_ = function(t, e, n) {
        (null == e || e < 0) && (e = 0),
        (null == n || n > t.length) && (n = t.length);
        var i = new (t instanceof Ly ? Ly : t instanceof Cy ? Cy : Ry)(n - e);
        return i.set(t.subarray(e, n)),
        i
    }
      , n_ = function(t, e, n) {
        var i = t.length;
        if (!i || n && !n.l && i < 5)
            return e || new Ry(0);
        var r = !e || n
          , s = !n || n.i;
        n || (n = {}),
        e || (e = new Ry(3 * i));
        var o = function(t) {
            var n = e.length;
            if (t > n) {
                var i = new Ry(Math.max(2 * n, t));
                i.set(e),
                e = i
            }
        }
          , a = n.f || 0
          , l = n.p || 0
          , c = n.b || 0
          , h = n.l
          , u = n.d
          , d = n.m
          , p = n.n
          , f = 8 * i;
        do {
            if (!h) {
                n.f = a = Qy(t, l, 1);
                var m = Qy(t, l + 1, 3);
                if (l += 3,
                !m) {
                    var g = t[(A = t_(l) + 4) - 4] | t[A - 3] << 8
                      , v = A + g;
                    if (v > i) {
                        if (s)
                            throw "unexpected EOF";
                        break
                    }
                    r && o(c + g),
                    e.set(t.subarray(A, v), c),
                    n.b = c += g,
                    n.p = l = 8 * v;
                    continue
                }
                if (1 == m)
                    h = Yy,
                    u = Jy,
                    d = 9,
                    p = 5;
                else {
                    if (2 != m)
                        throw "invalid block type";
                    var y = Qy(t, l, 31) + 257
                      , _ = Qy(t, l + 10, 15) + 4
                      , x = y + Qy(t, l + 5, 31) + 1;
                    l += 14;
                    for (var b = new Ry(x), w = new Ry(19), M = 0; M < _; ++M)
                        w[Iy[M]] = Qy(t, l + 3 * M, 7);
                    l += 3 * _;
                    var S = Ky(w)
                      , T = (1 << S) - 1
                      , E = Wy(w, S, 1);
                    for (M = 0; M < x; ) {
                        var A, R = E[Qy(t, l, T)];
                        if (l += 15 & R,
                        (A = R >>> 4) < 16)
                            b[M++] = A;
                        else {
                            var L = 0
                              , C = 0;
                            for (16 == A ? (C = 3 + Qy(t, l, 3),
                            l += 2,
                            L = b[M - 1]) : 17 == A ? (C = 3 + Qy(t, l, 7),
                            l += 3) : 18 == A && (C = 11 + Qy(t, l, 127),
                            l += 7); C--; )
                                b[M++] = L
                        }
                    }
                    var P = b.subarray(0, y)
                      , D = b.subarray(y);
                    d = Ky(P),
                    p = Ky(D),
                    h = Wy(P, d, 1),
                    u = Wy(D, p, 1)
                }
                if (l > f) {
                    if (s)
                        throw "unexpected EOF";
                    break
                }
            }
            r && o(c + 131072);
            for (var I = (1 << d) - 1, O = (1 << p) - 1, k = l; ; k = l) {
                var N = (L = h[$y(t, l) & I]) >>> 4;
                if ((l += 15 & L) > f) {
                    if (s)
                        throw "unexpected EOF";
                    break
                }
                if (!L)
                    throw "invalid length/literal";
                if (N < 256)
                    e[c++] = N;
                else {
                    if (256 == N) {
                        k = l,
                        h = null;
                        break
                    }
                    var z = N - 254;
                    if (N > 264) {
                        var B = Py[M = N - 257];
                        z = Qy(t, l, (1 << B) - 1) + Ny[M],
                        l += B
                    }
                    var F = u[$y(t, l) & O]
                      , U = F >>> 4;
                    if (!F)
                        throw "invalid distance";
                    if (l += 15 & F,
                    D = Fy[U],
                    U > 3 && (B = Dy[U],
                    D += $y(t, l) & (1 << B) - 1,
                    l += B),
                    l > f) {
                        if (s)
                            throw "unexpected EOF";
                        break
                    }
                    r && o(c + 131072);
                    for (var H = c + z; c < H; c += 4)
                        e[c] = e[c - D],
                        e[c + 1] = e[c + 1 - D],
                        e[c + 2] = e[c + 2 - D],
                        e[c + 3] = e[c + 3 - D];
                    c = H
                }
            }
            n.l = h,
            n.p = k,
            n.b = c,
            h && (a = 1,
            n.m = d,
            n.d = u,
            n.n = p)
        } while (!a);
        return c == e.length ? e : e_(e, 0, c)
    }
      , i_ = function(t, e, n) {
        n <<= 7 & e;
        var i = e / 8 | 0;
        t[i] |= n,
        t[i + 1] |= n >>> 8
    }
      , r_ = function(t, e, n) {
        n <<= 7 & e;
        var i = e / 8 | 0;
        t[i] |= n,
        t[i + 1] |= n >>> 8,
        t[i + 2] |= n >>> 16
    }
      , s_ = function(t, e) {
        for (var n = [], i = 0; i < t.length; ++i)
            t[i] && n.push({
                s: i,
                f: t[i]
            });
        var r = n.length
          , s = n.slice();
        if (!r)
            return [d_, 0];
        if (1 == r) {
            var o = new Ry(n[0].s + 1);
            return o[n[0].s] = 1,
            [o, 1]
        }
        n.sort((function(t, e) {
            return t.f - e.f
        }
        )),
        n.push({
            s: -1,
            f: 25001
        });
        var a = n[0]
          , l = n[1]
          , c = 0
          , h = 1
          , u = 2;
        for (n[0] = {
            s: -1,
            f: a.f + l.f,
            l: a,
            r: l
        }; h != r - 1; )
            a = n[n[c].f < n[u].f ? c++ : u++],
            l = n[c != h && n[c].f < n[u].f ? c++ : u++],
            n[h++] = {
                s: -1,
                f: a.f + l.f,
                l: a,
                r: l
            };
        var d = s[0].s;
        for (i = 1; i < r; ++i)
            s[i].s > d && (d = s[i].s);
        var p = new Ly(d + 1)
          , f = o_(n[h - 1], p, 0);
        if (f > e) {
            i = 0;
            var m = 0
              , g = f - e
              , v = 1 << g;
            for (s.sort((function(t, e) {
                return p[e.s] - p[t.s] || t.f - e.f
            }
            )); i < r; ++i) {
                var y = s[i].s;
                if (!(p[y] > e))
                    break;
                m += v - (1 << f - p[y]),
                p[y] = e
            }
            for (m >>>= g; m > 0; ) {
                var _ = s[i].s;
                p[_] < e ? m -= 1 << e - p[_]++ - 1 : ++i
            }
            for (; i >= 0 && m; --i) {
                var x = s[i].s;
                p[x] == e && (--p[x],
                ++m)
            }
            f = e
        }
        return [new Ry(p), f]
    }
      , o_ = function(t, e, n) {
        return -1 == t.s ? Math.max(o_(t.l, e, n + 1), o_(t.r, e, n + 1)) : e[t.s] = n
    }
      , a_ = function(t) {
        for (var e = t.length; e && !t[--e]; )
            ;
        for (var n = new Ly(++e), i = 0, r = t[0], s = 1, o = function(t) {
            n[i++] = t
        }, a = 1; a <= e; ++a)
            if (t[a] == r && a != e)
                ++s;
            else {
                if (!r && s > 2) {
                    for (; s > 138; s -= 138)
                        o(32754);
                    s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305),
                    s = 0)
                } else if (s > 3) {
                    for (o(r),
                    --s; s > 6; s -= 6)
                        o(8304);
                    s > 2 && (o(s - 3 << 5 | 8208),
                    s = 0)
                }
                for (; s--; )
                    o(r);
                s = 1,
                r = t[a]
            }
        return [n.subarray(0, i), e]
    }
      , l_ = function(t, e) {
        for (var n = 0, i = 0; i < e.length; ++i)
            n += t[i] * e[i];
        return n
    }
      , c_ = function(t, e, n) {
        var i = n.length
          , r = t_(e + 2);
        t[r] = 255 & i,
        t[r + 1] = i >>> 8,
        t[r + 2] = 255 ^ t[r],
        t[r + 3] = 255 ^ t[r + 1];
        for (var s = 0; s < i; ++s)
            t[r + s + 4] = n[s];
        return 8 * (r + 4 + i)
    }
      , h_ = function(t, e, n, i, r, s, o, a, l, c, h) {
        i_(e, h++, n),
        ++r[256];
        for (var u = s_(r, 15), d = u[0], p = u[1], f = s_(s, 15), m = f[0], g = f[1], v = a_(d), y = v[0], _ = v[1], x = a_(m), b = x[0], w = x[1], M = new Ly(19), S = 0; S < y.length; ++S)
            M[31 & y[S]]++;
        for (S = 0; S < b.length; ++S)
            M[31 & b[S]]++;
        for (var T = s_(M, 7), E = T[0], A = T[1], R = 19; R > 4 && !E[Iy[R - 1]]; --R)
            ;
        var L, C, P, D, I = c + 5 << 3, O = l_(r, jy) + l_(s, Xy) + o, k = l_(r, d) + l_(s, m) + o + 14 + 3 * R + l_(M, E) + (2 * M[16] + 3 * M[17] + 7 * M[18]);
        if (I <= O && I <= k)
            return c_(e, h, t.subarray(l, l + c));
        if (i_(e, h, 1 + (k < O)),
        h += 2,
        k < O) {
            L = Wy(d, p, 0),
            C = d,
            P = Wy(m, g, 0),
            D = m;
            var N = Wy(E, A, 0);
            for (i_(e, h, _ - 257),
            i_(e, h + 5, w - 1),
            i_(e, h + 10, R - 4),
            h += 14,
            S = 0; S < R; ++S)
                i_(e, h + 3 * S, E[Iy[S]]);
            h += 3 * R;
            for (var z = [y, b], B = 0; B < 2; ++B) {
                var F = z[B];
                for (S = 0; S < F.length; ++S) {
                    var U = 31 & F[S];
                    i_(e, h, N[U]),
                    h += E[U],
                    U > 15 && (i_(e, h, F[S] >>> 5 & 127),
                    h += F[S] >>> 12)
                }
            }
        } else
            L = qy,
            C = jy,
            P = Zy,
            D = Xy;
        for (S = 0; S < a; ++S)
            if (i[S] > 255) {
                U = i[S] >>> 18 & 31,
                r_(e, h, L[U + 257]),
                h += C[U + 257],
                U > 7 && (i_(e, h, i[S] >>> 23 & 31),
                h += Py[U]);
                var H = 31 & i[S];
                r_(e, h, P[H]),
                h += D[H],
                H > 3 && (r_(e, h, i[S] >>> 5 & 8191),
                h += Dy[H])
            } else
                r_(e, h, L[i[S]]),
                h += C[i[S]];
        return r_(e, h, L[256]),
        h + C[256]
    }
      , u_ = new Cy([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
      , d_ = new Ry(0)
      , p_ = function(t, e, n, i, r, s) {
        var o = t.length
          , a = new Ry(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r)
          , l = a.subarray(i, a.length - r)
          , c = 0;
        if (!e || o < 8)
            for (var h = 0; h <= o; h += 65535) {
                var u = h + 65535;
                u < o ? c = c_(l, c, t.subarray(h, u)) : (l[h] = s,
                c = c_(l, c, t.subarray(h, o)))
            }
        else {
            for (var d = u_[e - 1], p = d >>> 13, f = 8191 & d, m = (1 << n) - 1, g = new Ly(32768), v = new Ly(m + 1), y = Math.ceil(n / 3), _ = 2 * y, x = function(e) {
                return (t[e] ^ t[e + 1] << y ^ t[e + 2] << _) & m
            }, b = new Cy(25e3), w = new Ly(288), M = new Ly(32), S = 0, T = 0, E = (h = 0,
            0), A = 0, R = 0; h < o; ++h) {
                var L = x(h)
                  , C = 32767 & h
                  , P = v[L];
                if (g[C] = P,
                v[L] = C,
                A <= h) {
                    var D = o - h;
                    if ((S > 7e3 || E > 24576) && D > 423) {
                        c = h_(t, l, 0, b, w, M, T, E, R, h - R, c),
                        E = S = T = 0,
                        R = h;
                        for (var I = 0; I < 286; ++I)
                            w[I] = 0;
                        for (I = 0; I < 30; ++I)
                            M[I] = 0
                    }
                    var O = 2
                      , k = 0
                      , N = f
                      , z = C - P & 32767;
                    if (D > 2 && L == x(h - z))
                        for (var B = Math.min(p, D) - 1, F = Math.min(32767, h), U = Math.min(258, D); z <= F && --N && C != P; ) {
                            if (t[h + O] == t[h + O - z]) {
                                for (var H = 0; H < U && t[h + H] == t[h + H - z]; ++H)
                                    ;
                                if (H > O) {
                                    if (O = H,
                                    k = z,
                                    H > B)
                                        break;
                                    var V = Math.min(z, H - 2)
                                      , G = 0;
                                    for (I = 0; I < V; ++I) {
                                        var W = h - z + I + 32768 & 32767
                                          , j = W - g[W] + 32768 & 32767;
                                        j > G && (G = j,
                                        P = W)
                                    }
                                }
                            }
                            z += (C = P) - (P = g[C]) + 32768 & 32767
                        }
                    if (k) {
                        b[E++] = 268435456 | zy[O] << 18 | Uy[k];
                        var X = 31 & zy[O]
                          , q = 31 & Uy[k];
                        T += Py[X] + Dy[q],
                        ++w[257 + X],
                        ++M[q],
                        A = h + O,
                        ++S
                    } else
                        b[E++] = t[h],
                        ++w[t[h]]
                }
            }
            c = h_(t, l, s, b, w, M, T, E, R, h - R, c),
            !s && 7 & c && (c = c_(l, c + 1, d_))
        }
        return e_(a, 0, i + t_(c) + r)
    }
      , f_ = function() {
        for (var t = new Cy(256), e = 0; e < 256; ++e) {
            for (var n = e, i = 9; --i; )
                n = (1 & n && 3988292384) ^ n >>> 1;
            t[e] = n
        }
        return t
    }()
      , m_ = function() {
        var t = -1;
        return {
            p: function(e) {
                for (var n = t, i = 0; i < e.length; ++i)
                    n = f_[255 & n ^ e[i]] ^ n >>> 8;
                t = n
            },
            d: function() {
                return ~t
            }
        }
    }
      , g_ = function() {
        var t = 1
          , e = 0;
        return {
            p: function(n) {
                for (var i = t, r = e, s = n.length, o = 0; o != s; ) {
                    for (var a = Math.min(o + 2655, s); o < a; ++o)
                        r += i += n[o];
                    i = (65535 & i) + 15 * (i >> 16),
                    r = (65535 & r) + 15 * (r >> 16)
                }
                t = i,
                e = r
            },
            d: function() {
                return (255 & (t %= 65521)) << 24 | t >>> 8 << 16 | (255 & (e %= 65521)) << 8 | e >>> 8
            }
        }
    }
      , v_ = function(t, e, n, i, r) {
        return p_(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, n, i, !r)
    }
      , y_ = function(t, e) {
        var n = {};
        for (var i in t)
            n[i] = t[i];
        for (var i in e)
            n[i] = e[i];
        return n
    }
      , __ = function(t, e, n) {
        for (var i = t(), r = t.toString(), s = r.slice(r.indexOf("[") + 1, r.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < i.length; ++o) {
            var a = i[o]
              , l = s[o];
            if ("function" == typeof a) {
                e += ";" + l + "=";
                var c = a.toString();
                if (a.prototype)
                    if (-1 != c.indexOf("[native code]")) {
                        var h = c.indexOf(" ", 8) + 1;
                        e += c.slice(h, c.indexOf("(", h))
                    } else
                        for (var u in e += c,
                        a.prototype)
                            e += ";" + l + ".prototype." + u + "=" + a.prototype[u].toString();
                else
                    e += c
            } else
                n[l] = a
        }
        return [e, n]
    }
      , x_ = []
      , b_ = function(t, e, n, i) {
        var r;
        if (!x_[n]) {
            for (var s = "", o = {}, a = t.length - 1, l = 0; l < a; ++l)
                s = (r = __(t[l], s, o))[0],
                o = r[1];
            x_[n] = __(t[a], s, o)
        }
        var c = y_({}, x_[n][1]);
        return function(t, e, n, i, r) {
            var s = Ay(Ty[e] || (Ty[e] = Ey(t)));
            return s.onerror = function(t) {
                return r(t.error, null)
            }
            ,
            s.onmessage = function(t) {
                return r(null, t.data)
            }
            ,
            s.postMessage(n, i),
            s
        }(x_[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", n, c, function(t) {
            var e = [];
            for (var n in t)
                (t[n]instanceof Ry || t[n]instanceof Ly || t[n]instanceof Cy) && e.push((t[n] = new t[n].constructor(t[n])).buffer);
            return e
        }(c), i)
    }
      , w_ = function() {
        return [Ry, Ly, Cy, Py, Dy, Iy, Ny, Fy, Yy, Jy, Hy, Wy, Ky, Qy, $y, t_, e_, n_, K_, R_, L_]
    }
      , M_ = function() {
        return [Ry, Ly, Cy, Py, Dy, Iy, zy, Uy, qy, jy, Zy, Xy, Hy, u_, d_, Wy, i_, r_, s_, o_, a_, l_, c_, h_, t_, e_, p_, v_, q_, R_]
    }
      , S_ = function() {
        return [z_, U_, N_, m_, f_]
    }
      , T_ = function() {
        return [B_, F_]
    }
      , E_ = function() {
        return [H_, N_, g_]
    }
      , A_ = function() {
        return [V_]
    }
      , R_ = function(t) {
        return postMessage(t, [t.buffer])
    }
      , L_ = function(t) {
        return t && t.size && new Ry(t.size)
    }
      , C_ = function(t, e, n, i, r, s) {
        var o = b_(n, i, r, (function(t, e) {
            o.terminate(),
            s(t, e)
        }
        ));
        return o.postMessage([t, e], e.consume ? [t.buffer] : []),
        function() {
            o.terminate()
        }
    }
      , P_ = function(t) {
        return t.ondata = function(t, e) {
            return postMessage([t, e], [t.buffer])
        }
        ,
        function(e) {
            return t.push(e.data[0], e.data[1])
        }
    }
      , D_ = function(t, e, n, i, r) {
        var s, o = b_(t, i, r, (function(t, n) {
            t ? (o.terminate(),
            e.ondata.call(e, t)) : (n[1] && o.terminate(),
            e.ondata.call(e, t, n[0], n[1]))
        }
        ));
        o.postMessage(n),
        e.push = function(t, n) {
            if (s)
                throw "stream finished";
            if (!e.ondata)
                throw "no stream handler";
            o.postMessage([t, s = n], [t.buffer])
        }
        ,
        e.terminate = function() {
            o.terminate()
        }
    }
      , I_ = function(t, e) {
        return t[e] | t[e + 1] << 8
    }
      , O_ = function(t, e) {
        return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0
    }
      , k_ = function(t, e) {
        return O_(t, e) + 4294967296 * O_(t, e + 4)
    }
      , N_ = function(t, e, n) {
        for (; n; ++e)
            t[e] = n,
            n >>>= 8
    }
      , z_ = function(t, e) {
        var n = e.filename;
        if (t[0] = 31,
        t[1] = 139,
        t[2] = 8,
        t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0,
        t[9] = 3,
        0 != e.mtime && N_(t, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)),
        n) {
            t[3] = 8;
            for (var i = 0; i <= n.length; ++i)
                t[i + 10] = n.charCodeAt(i)
        }
    }
      , B_ = function(t) {
        if (31 != t[0] || 139 != t[1] || 8 != t[2])
            throw "invalid gzip data";
        var e = t[3]
          , n = 10;
        4 & e && (n += t[10] | 2 + (t[11] << 8));
        for (var i = (e >> 3 & 1) + (e >> 4 & 1); i > 0; i -= !t[n++])
            ;
        return n + (2 & e)
    }
      , F_ = function(t) {
        var e = t.length;
        return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0
    }
      , U_ = function(t) {
        return 10 + (t.filename && t.filename.length + 1 || 0)
    }
      , H_ = function(t, e) {
        var n = e.level
          , i = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
        t[0] = 120,
        t[1] = i << 6 | (i ? 32 - 2 * i : 1)
    }
      , V_ = function(t) {
        if (8 != (15 & t[0]) || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31)
            throw "invalid zlib data";
        if (32 & t[1])
            throw "invalid zlib data: preset dictionaries not supported"
    };
    function G_(t, e) {
        return e || "function" != typeof t || (e = t,
        t = {}),
        this.ondata = e,
        t
    }
    var W_ = function() {
        function t(t, e) {
            e || "function" != typeof t || (e = t,
            t = {}),
            this.ondata = e,
            this.o = t || {}
        }
        return t.prototype.p = function(t, e) {
            this.ondata(v_(t, this.o, 0, 0, !e), e)
        }
        ,
        t.prototype.push = function(t, e) {
            if (this.d)
                throw "stream finished";
            if (!this.ondata)
                throw "no stream handler";
            this.d = e,
            this.p(t, e || !1)
        }
        ,
        t
    }()
      , j_ = function() {
        return function(t, e) {
            D_([M_, function() {
                return [P_, W_]
            }
            ], this, G_.call(this, t, e), (function(t) {
                var e = new W_(t.data);
                onmessage = P_(e)
            }
            ), 6)
        }
    }();
    function X_(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return C_(t, e, [M_], (function(t) {
            return R_(q_(t.data[0], t.data[1]))
        }
        ), 0, n)
    }
    function q_(t, e) {
        return v_(t, e || {}, 0, 0)
    }
    var Y_ = function() {
        function t(t) {
            this.s = {},
            this.p = new Ry(0),
            this.ondata = t
        }
        return t.prototype.e = function(t) {
            if (this.d)
                throw "stream finished";
            if (!this.ondata)
                throw "no stream handler";
            var e = this.p.length
              , n = new Ry(e + t.length);
            n.set(this.p),
            n.set(t, e),
            this.p = n
        }
        ,
        t.prototype.c = function(t) {
            this.d = this.s.i = t || !1;
            var e = this.s.b
              , n = n_(this.p, this.o, this.s);
            this.ondata(e_(n, e, this.s.b), this.d),
            this.o = e_(n, this.s.b - 32768),
            this.s.b = this.o.length,
            this.p = e_(this.p, this.s.p / 8 | 0),
            this.s.p &= 7
        }
        ,
        t.prototype.push = function(t, e) {
            this.e(t),
            this.c(e)
        }
        ,
        t
    }()
      , Z_ = function() {
        return function(t) {
            this.ondata = t,
            D_([w_, function() {
                return [P_, Y_]
            }
            ], this, 0, (function() {
                var t = new Y_;
                onmessage = P_(t)
            }
            ), 7)
        }
    }();
    function J_(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return C_(t, e, [w_], (function(t) {
            return R_(K_(t.data[0], L_(t.data[1])))
        }
        ), 1, n)
    }
    function K_(t, e) {
        return n_(t, e)
    }
    var Q_ = function() {
        function t(t, e) {
            this.c = m_(),
            this.l = 0,
            this.v = 1,
            W_.call(this, t, e)
        }
        return t.prototype.push = function(t, e) {
            W_.prototype.push.call(this, t, e)
        }
        ,
        t.prototype.p = function(t, e) {
            this.c.p(t),
            this.l += t.length;
            var n = v_(t, this.o, this.v && U_(this.o), e && 8, !e);
            this.v && (z_(n, this.o),
            this.v = 0),
            e && (N_(n, n.length - 8, this.c.d()),
            N_(n, n.length - 4, this.l)),
            this.ondata(n, e)
        }
        ,
        t
    }()
      , $_ = function() {
        return function(t, e) {
            D_([M_, S_, function() {
                return [P_, W_, Q_]
            }
            ], this, G_.call(this, t, e), (function(t) {
                var e = new Q_(t.data);
                onmessage = P_(e)
            }
            ), 8)
        }
    }();
    function tx(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return C_(t, e, [M_, S_, function() {
            return [ex]
        }
        ], (function(t) {
            return R_(ex(t.data[0], t.data[1]))
        }
        ), 2, n)
    }
    function ex(t, e) {
        e || (e = {});
        var n = m_()
          , i = t.length;
        n.p(t);
        var r = v_(t, e, U_(e), 8)
          , s = r.length;
        return z_(r, e),
        N_(r, s - 8, n.d()),
        N_(r, s - 4, i),
        r
    }
    var nx = function() {
        function t(t) {
            this.v = 1,
            Y_.call(this, t)
        }
        return t.prototype.push = function(t, e) {
            if (Y_.prototype.e.call(this, t),
            this.v) {
                var n = this.p.length > 3 ? B_(this.p) : 4;
                if (n >= this.p.length && !e)
                    return;
                this.p = this.p.subarray(n),
                this.v = 0
            }
            if (e) {
                if (this.p.length < 8)
                    throw "invalid gzip stream";
                this.p = this.p.subarray(0, -8)
            }
            Y_.prototype.c.call(this, e)
        }
        ,
        t
    }()
      , ix = function() {
        return function(t) {
            this.ondata = t,
            D_([w_, T_, function() {
                return [P_, Y_, nx]
            }
            ], this, 0, (function() {
                var t = new nx;
                onmessage = P_(t)
            }
            ), 9)
        }
    }();
    function rx(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return C_(t, e, [w_, T_, function() {
            return [sx]
        }
        ], (function(t) {
            return R_(sx(t.data[0]))
        }
        ), 3, n)
    }
    function sx(t, e) {
        return n_(t.subarray(B_(t), -8), e || new Ry(F_(t)))
    }
    var ox = function() {
        function t(t, e) {
            this.c = g_(),
            this.v = 1,
            W_.call(this, t, e)
        }
        return t.prototype.push = function(t, e) {
            W_.prototype.push.call(this, t, e)
        }
        ,
        t.prototype.p = function(t, e) {
            this.c.p(t);
            var n = v_(t, this.o, this.v && 2, e && 4, !e);
            this.v && (H_(n, this.o),
            this.v = 0),
            e && N_(n, n.length - 4, this.c.d()),
            this.ondata(n, e)
        }
        ,
        t
    }()
      , ax = function() {
        return function(t, e) {
            D_([M_, E_, function() {
                return [P_, W_, ox]
            }
            ], this, G_.call(this, t, e), (function(t) {
                var e = new ox(t.data);
                onmessage = P_(e)
            }
            ), 10)
        }
    }();
    function lx(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return C_(t, e, [M_, E_, function() {
            return [cx]
        }
        ], (function(t) {
            return R_(cx(t.data[0], t.data[1]))
        }
        ), 4, n)
    }
    function cx(t, e) {
        e || (e = {});
        var n = g_();
        n.p(t);
        var i = v_(t, e, 2, 4);
        return H_(i, e),
        N_(i, i.length - 4, n.d()),
        i
    }
    var hx = function() {
        function t(t) {
            this.v = 1,
            Y_.call(this, t)
        }
        return t.prototype.push = function(t, e) {
            if (Y_.prototype.e.call(this, t),
            this.v) {
                if (this.p.length < 2 && !e)
                    return;
                this.p = this.p.subarray(2),
                this.v = 0
            }
            if (e) {
                if (this.p.length < 4)
                    throw "invalid zlib stream";
                this.p = this.p.subarray(0, -4)
            }
            Y_.prototype.c.call(this, e)
        }
        ,
        t
    }()
      , ux = function() {
        return function(t) {
            this.ondata = t,
            D_([w_, A_, function() {
                return [P_, Y_, hx]
            }
            ], this, 0, (function() {
                var t = new hx;
                onmessage = P_(t)
            }
            ), 11)
        }
    }();
    function dx(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return C_(t, e, [w_, A_, function() {
            return [px]
        }
        ], (function(t) {
            return R_(px(t.data[0], L_(t.data[1])))
        }
        ), 5, n)
    }
    function px(t, e) {
        return n_((V_(t),
        t.subarray(2, -4)), e)
    }
    var fx = function() {
        function t(t) {
            this.G = nx,
            this.I = Y_,
            this.Z = hx,
            this.ondata = t
        }
        return t.prototype.push = function(t, e) {
            if (!this.ondata)
                throw "no stream handler";
            if (this.s)
                this.s.push(t, e);
            else {
                if (this.p && this.p.length) {
                    var n = new Ry(this.p.length + t.length);
                    n.set(this.p),
                    n.set(t, this.p.length)
                } else
                    this.p = t;
                if (this.p.length > 2) {
                    var i = this
                      , r = function() {
                        i.ondata.apply(i, arguments)
                    };
                    this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(r) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(r) : new this.Z(r),
                    this.s.push(this.p, e),
                    this.p = null
                }
            }
        }
        ,
        t
    }()
      , mx = function() {
        function t(t) {
            this.G = ix,
            this.I = Z_,
            this.Z = ux,
            this.ondata = t
        }
        return t.prototype.push = function(t, e) {
            fx.prototype.push.call(this, t, e)
        }
        ,
        t
    }();
    function gx(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        return 31 == t[0] && 139 == t[1] && 8 == t[2] ? rx(t, e, n) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? J_(t, e, n) : dx(t, e, n)
    }
    function vx(t, e) {
        return 31 == t[0] && 139 == t[1] && 8 == t[2] ? sx(t, e) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? K_(t, e) : px(t, e)
    }
    var yx = function(t, e, n, i) {
        for (var r in t) {
            var s = t[r]
              , o = e + r;
            s instanceof Ry ? n[o] = [s, i] : Array.isArray(s) ? n[o] = [s[0], y_(i, s[1])] : yx(s, o + "/", n, i)
        }
    }
      , _x = "undefined" != typeof TextEncoder && new TextEncoder
      , xx = "undefined" != typeof TextDecoder && new TextDecoder
      , bx = 0;
    try {
        xx.decode(d_, {
            stream: !0
        }),
        bx = 1
    } catch (t) {}
    var wx = function(t) {
        for (var e = "", n = 0; ; ) {
            var i = t[n++]
              , r = (i > 127) + (i > 223) + (i > 239);
            if (n + r > t.length)
                return [e, e_(t, n - 1)];
            r ? 3 == r ? (i = ((15 & i) << 18 | (63 & t[n++]) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) - 65536,
            e += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i)) : e += 1 & r ? String.fromCharCode((31 & i) << 6 | 63 & t[n++]) : String.fromCharCode((15 & i) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) : e += String.fromCharCode(i)
        }
    }
      , Mx = function() {
        function t(t) {
            this.ondata = t,
            bx ? this.t = new TextDecoder : this.p = d_
        }
        return t.prototype.push = function(t, e) {
            if (!this.ondata)
                throw "no callback";
            if (e = !!e,
            this.t) {
                if (this.ondata(this.t.decode(t, {
                    stream: !0
                }), e),
                e) {
                    if (this.t.decode().length)
                        throw "invalid utf-8 data";
                    this.t = null
                }
            } else {
                if (!this.p)
                    throw "stream finished";
                var n = new Ry(this.p.length + t.length);
                n.set(this.p),
                n.set(t, this.p.length);
                var i = wx(n)
                  , r = i[0]
                  , s = i[1];
                if (e) {
                    if (s.length)
                        throw "invalid utf-8 data";
                    this.p = null
                } else
                    this.p = s;
                this.ondata(r, e)
            }
        }
        ,
        t
    }()
      , Sx = function() {
        function t(t) {
            this.ondata = t
        }
        return t.prototype.push = function(t, e) {
            if (!this.ondata)
                throw "no callback";
            if (this.d)
                throw "stream finished";
            this.ondata(Tx(t), this.d = e || !1)
        }
        ,
        t
    }();
    function Tx(t, e) {
        if (e) {
            for (var n = new Ry(t.length), i = 0; i < t.length; ++i)
                n[i] = t.charCodeAt(i);
            return n
        }
        if (_x)
            return _x.encode(t);
        var r = t.length
          , s = new Ry(t.length + (t.length >> 1))
          , o = 0
          , a = function(t) {
            s[o++] = t
        };
        for (i = 0; i < r; ++i) {
            if (o + 5 > s.length) {
                var l = new Ry(o + 8 + (r - i << 1));
                l.set(s),
                s = l
            }
            var c = t.charCodeAt(i);
            c < 128 || e ? a(c) : c < 2048 ? (a(192 | c >> 6),
            a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & t.charCodeAt(++i)) >> 18),
            a(128 | c >> 12 & 63),
            a(128 | c >> 6 & 63),
            a(128 | 63 & c)) : (a(224 | c >> 12),
            a(128 | c >> 6 & 63),
            a(128 | 63 & c))
        }
        return e_(s, 0, o)
    }
    function Ex(t, e) {
        if (e) {
            for (var n = "", i = 0; i < t.length; i += 16384)
                n += String.fromCharCode.apply(null, t.subarray(i, i + 16384));
            return n
        }
        if (xx)
            return xx.decode(t);
        var r = wx(t)
          , s = r[0];
        if (r[1].length)
            throw "invalid utf-8 data";
        return s
    }
    var Ax = function(t) {
        return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0
    }
      , Rx = function(t, e) {
        return e + 30 + I_(t, e + 26) + I_(t, e + 28)
    }
      , Lx = function(t, e, n) {
        var i = I_(t, e + 28)
          , r = Ex(t.subarray(e + 46, e + 46 + i), !(2048 & I_(t, e + 8)))
          , s = e + 46 + i
          , o = O_(t, e + 20)
          , a = n && 4294967295 == o ? Cx(t, s) : [o, O_(t, e + 24), O_(t, e + 42)]
          , l = a[0]
          , c = a[1]
          , h = a[2];
        return [I_(t, e + 10), l, c, r, s + I_(t, e + 30) + I_(t, e + 32), h]
    }
      , Cx = function(t, e) {
        for (; 1 != I_(t, e); e += 4 + I_(t, e + 2))
            ;
        return [k_(t, e + 12), k_(t, e + 4), k_(t, e + 20)]
    }
      , Px = function(t) {
        var e = 0;
        if (t)
            for (var n in t) {
                var i = t[n].length;
                if (i > 65535)
                    throw "extra field too long";
                e += i + 4
            }
        return e
    }
      , Dx = function(t, e, n, i, r, s, o, a) {
        var l = i.length
          , c = n.extra
          , h = a && a.length
          , u = Px(c);
        N_(t, e, null != o ? 33639248 : 67324752),
        e += 4,
        null != o && (t[e++] = 20,
        t[e++] = n.os),
        t[e] = 20,
        e += 2,
        t[e++] = n.flag << 1 | (null == s && 8),
        t[e++] = r && 8,
        t[e++] = 255 & n.compression,
        t[e++] = n.compression >> 8;
        var d = new Date(null == n.mtime ? Date.now() : n.mtime)
          , p = d.getFullYear() - 1980;
        if (p < 0 || p > 119)
            throw "date not in range 1980-2099";
        if (N_(t, e, p << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1),
        e += 4,
        null != s && (N_(t, e, n.crc),
        N_(t, e + 4, s),
        N_(t, e + 8, n.size)),
        N_(t, e + 12, l),
        N_(t, e + 14, u),
        e += 16,
        null != o && (N_(t, e, h),
        N_(t, e + 6, n.attrs),
        N_(t, e + 10, o),
        e += 14),
        t.set(i, e),
        e += l,
        u)
            for (var f in c) {
                var m = c[f]
                  , g = m.length;
                N_(t, e, +f),
                N_(t, e + 2, g),
                t.set(m, e + 4),
                e += 4 + g
            }
        return h && (t.set(a, e),
        e += h),
        e
    }
      , Ix = function(t, e, n, i, r) {
        N_(t, e, 101010256),
        N_(t, e + 8, n),
        N_(t, e + 10, n),
        N_(t, e + 12, i),
        N_(t, e + 16, r)
    }
      , Ox = function() {
        function t(t) {
            this.filename = t,
            this.c = m_(),
            this.size = 0,
            this.compression = 0
        }
        return t.prototype.process = function(t, e) {
            this.ondata(null, t, e)
        }
        ,
        t.prototype.push = function(t, e) {
            if (!this.ondata)
                throw "no callback - add to ZIP archive before pushing";
            this.c.p(t),
            this.size += t.length,
            e && (this.crc = this.c.d()),
            this.process(t, e || !1)
        }
        ,
        t
    }()
      , kx = function() {
        function t(t, e) {
            var n = this;
            e || (e = {}),
            Ox.call(this, t),
            this.d = new W_(e,(function(t, e) {
                n.ondata(null, t, e)
            }
            )),
            this.compression = 8,
            this.flag = Ax(e.level)
        }
        return t.prototype.process = function(t, e) {
            try {
                this.d.push(t, e)
            } catch (t) {
                this.ondata(t, null, e)
            }
        }
        ,
        t.prototype.push = function(t, e) {
            Ox.prototype.push.call(this, t, e)
        }
        ,
        t
    }()
      , Nx = function() {
        function t(t, e) {
            var n = this;
            e || (e = {}),
            Ox.call(this, t),
            this.d = new j_(e,(function(t, e, i) {
                n.ondata(t, e, i)
            }
            )),
            this.compression = 8,
            this.flag = Ax(e.level),
            this.terminate = this.d.terminate
        }
        return t.prototype.process = function(t, e) {
            this.d.push(t, e)
        }
        ,
        t.prototype.push = function(t, e) {
            Ox.prototype.push.call(this, t, e)
        }
        ,
        t
    }()
      , zx = function() {
        function t(t) {
            this.ondata = t,
            this.u = [],
            this.d = 1
        }
        return t.prototype.add = function(t) {
            var e = this;
            if (2 & this.d)
                throw "stream finished";
            var n = Tx(t.filename)
              , i = n.length
              , r = t.comment
              , s = r && Tx(r)
              , o = i != t.filename.length || s && r.length != s.length
              , a = i + Px(t.extra) + 30;
            if (i > 65535)
                throw "filename too long";
            var l = new Ry(a);
            Dx(l, 0, t, n, o);
            var c = [l]
              , h = function() {
                for (var t = 0, n = c; t < n.length; t++) {
                    var i = n[t];
                    e.ondata(null, i, !1)
                }
                c = []
            }
              , u = this.d;
            this.d = 0;
            var d = this.u.length
              , p = y_(t, {
                f: n,
                u: o,
                o: s,
                t: function() {
                    t.terminate && t.terminate()
                },
                r: function() {
                    if (h(),
                    u) {
                        var t = e.u[d + 1];
                        t ? t.r() : e.d = 1
                    }
                    u = 1
                }
            })
              , f = 0;
            t.ondata = function(n, i, r) {
                if (n)
                    e.ondata(n, i, r),
                    e.terminate();
                else if (f += i.length,
                c.push(i),
                r) {
                    var s = new Ry(16);
                    N_(s, 0, 134695760),
                    N_(s, 4, t.crc),
                    N_(s, 8, f),
                    N_(s, 12, t.size),
                    c.push(s),
                    p.c = f,
                    p.b = a + f + 16,
                    p.crc = t.crc,
                    p.size = t.size,
                    u && p.r(),
                    u = 1
                } else
                    u && h()
            }
            ,
            this.u.push(p)
        }
        ,
        t.prototype.end = function() {
            var t = this;
            if (2 & this.d) {
                if (1 & this.d)
                    throw "stream finishing";
                throw "stream finished"
            }
            this.d ? this.e() : this.u.push({
                r: function() {
                    1 & t.d && (t.u.splice(-1, 1),
                    t.e())
                },
                t: function() {}
            }),
            this.d = 3
        }
        ,
        t.prototype.e = function() {
            for (var t = 0, e = 0, n = 0, i = 0, r = this.u; i < r.length; i++)
                n += 46 + (l = r[i]).f.length + Px(l.extra) + (l.o ? l.o.length : 0);
            for (var s = new Ry(n + 22), o = 0, a = this.u; o < a.length; o++) {
                var l = a[o];
                Dx(s, t, l, l.f, l.u, l.c, e, l.o),
                t += 46 + l.f.length + Px(l.extra) + (l.o ? l.o.length : 0),
                e += l.b
            }
            Ix(s, t, this.u.length, n, e),
            this.ondata(null, s, !0),
            this.d = 2
        }
        ,
        t.prototype.terminate = function() {
            for (var t = 0, e = this.u; t < e.length; t++)
                e[t].t();
            this.d = 2
        }
        ,
        t
    }();
    function Bx(t, e, n) {
        if (n || (n = e,
        e = {}),
        "function" != typeof n)
            throw "no callback";
        var i = {};
        yx(t, "", i, e);
        var r = Object.keys(i)
          , s = r.length
          , o = 0
          , a = 0
          , l = s
          , c = new Array(s)
          , h = []
          , u = function() {
            for (var t = 0; t < h.length; ++t)
                h[t]()
        }
          , d = function() {
            var t = new Ry(a + 22)
              , e = o
              , i = a - o;
            a = 0;
            for (var r = 0; r < l; ++r) {
                var s = c[r];
                try {
                    var h = s.c.length;
                    Dx(t, a, s, s.f, s.u, h);
                    var u = 30 + s.f.length + Px(s.extra)
                      , d = a + u;
                    t.set(s.c, d),
                    Dx(t, o, s, s.f, s.u, h, a, s.m),
                    o += 16 + u + (s.m ? s.m.length : 0),
                    a = d + h
                } catch (t) {
                    return n(t, null)
                }
            }
            Ix(t, o, c.length, i, e),
            n(null, t)
        };
        s || d();
        for (var p = function(t) {
            var e = r[t]
              , l = i[e]
              , p = l[0]
              , f = l[1]
              , m = m_()
              , g = p.length;
            m.p(p);
            var v = Tx(e)
              , y = v.length
              , _ = f.comment
              , x = _ && Tx(_)
              , b = x && x.length
              , w = Px(f.extra)
              , M = 0 == f.level ? 0 : 8
              , S = function(i, r) {
                if (i)
                    u(),
                    n(i, null);
                else {
                    var l = r.length;
                    c[t] = y_(f, {
                        size: g,
                        crc: m.d(),
                        c: r,
                        f: v,
                        m: x,
                        u: y != e.length || x && _.length != b,
                        compression: M
                    }),
                    o += 30 + y + w + l,
                    a += 76 + 2 * (y + w) + (b || 0) + l,
                    --s || d()
                }
            };
            if (y > 65535 && S("filename too long", null),
            M)
                if (g < 16e4)
                    try {
                        S(null, q_(p, f))
                    } catch (t) {
                        S(t, null)
                    }
                else
                    h.push(X_(p, f, S));
            else
                S(null, p)
        }, f = 0; f < l; ++f)
            p(f);
        return u
    }
    function Fx(t, e) {
        e || (e = {});
        var n = {}
          , i = [];
        yx(t, "", n, e);
        var r = 0
          , s = 0;
        for (var o in n) {
            var a = n[o]
              , l = a[0]
              , c = a[1]
              , h = 0 == c.level ? 0 : 8
              , u = (M = Tx(o)).length
              , d = c.comment
              , p = d && Tx(d)
              , f = p && p.length
              , m = Px(c.extra);
            if (u > 65535)
                throw "filename too long";
            var g = h ? q_(l, c) : l
              , v = g.length
              , y = m_();
            y.p(l),
            i.push(y_(c, {
                size: l.length,
                crc: y.d(),
                c: g,
                f: M,
                m: p,
                u: u != o.length || p && d.length != f,
                o: r,
                compression: h
            })),
            r += 30 + u + m + v,
            s += 76 + 2 * (u + m) + (f || 0) + v
        }
        for (var _ = new Ry(s + 22), x = r, b = s - r, w = 0; w < i.length; ++w) {
            var M = i[w];
            Dx(_, M.o, M, M.f, M.u, M.c.length);
            var S = 30 + M.f.length + Px(M.extra);
            _.set(M.c, M.o + S),
            Dx(_, r, M, M.f, M.u, M.c.length, M.o, M.m),
            r += 16 + S + (M.m ? M.m.length : 0)
        }
        return Ix(_, r, i.length, b, x),
        _
    }
    var Ux = function() {
        function t() {}
        return t.prototype.push = function(t, e) {
            this.ondata(null, t, e)
        }
        ,
        t.compression = 0,
        t
    }()
      , Hx = function() {
        function t() {
            var t = this;
            this.i = new Y_((function(e, n) {
                t.ondata(null, e, n)
            }
            ))
        }
        return t.prototype.push = function(t, e) {
            try {
                this.i.push(t, e)
            } catch (n) {
                this.ondata(n, t, e)
            }
        }
        ,
        t.compression = 8,
        t
    }()
      , Vx = function() {
        function t(t, e) {
            var n = this;
            e < 32e4 ? this.i = new Y_((function(t, e) {
                n.ondata(null, t, e)
            }
            )) : (this.i = new Z_((function(t, e, i) {
                n.ondata(t, e, i)
            }
            )),
            this.terminate = this.i.terminate)
        }
        return t.prototype.push = function(t, e) {
            this.i.terminate && (t = e_(t, 0)),
            this.i.push(t, e)
        }
        ,
        t.compression = 8,
        t
    }()
      , Gx = function() {
        function t(t) {
            this.onfile = t,
            this.k = [],
            this.o = {
                0: Ux
            },
            this.p = d_
        }
        return t.prototype.push = function(t, e) {
            var n = this;
            if (!this.onfile)
                throw "no callback";
            if (!this.p)
                throw "stream finished";
            if (this.c > 0) {
                var i = Math.min(this.c, t.length)
                  , r = t.subarray(0, i);
                if (this.c -= i,
                this.d ? this.d.push(r, !this.c) : this.k[0].push(r),
                (t = t.subarray(i)).length)
                    return this.push(t, e)
            } else {
                var s = 0
                  , o = 0
                  , a = void 0
                  , l = void 0;
                this.p.length ? t.length ? ((l = new Ry(this.p.length + t.length)).set(this.p),
                l.set(t, this.p.length)) : l = this.p : l = t;
                for (var c = l.length, h = this.c, u = h && this.d, d = function() {
                    var t, e = O_(l, o);
                    if (67324752 == e) {
                        s = 1,
                        a = o,
                        p.d = null,
                        p.c = 0;
                        var i = I_(l, o + 6)
                          , r = I_(l, o + 8)
                          , u = 2048 & i
                          , d = 8 & i
                          , f = I_(l, o + 26)
                          , m = I_(l, o + 28);
                        if (c > o + 30 + f + m) {
                            var g = [];
                            p.k.unshift(g),
                            s = 2;
                            var v, y = O_(l, o + 18), _ = O_(l, o + 22), x = Ex(l.subarray(o + 30, o += 30 + f), !u);
                            4294967295 == y ? (t = d ? [-2] : Cx(l, o),
                            y = t[0],
                            _ = t[1]) : d && (y = -1),
                            o += m,
                            p.c = y;
                            var b = {
                                name: x,
                                compression: r,
                                start: function() {
                                    if (!b.ondata)
                                        throw "no callback";
                                    if (y) {
                                        var t = n.o[r];
                                        if (!t)
                                            throw "unknown compression type " + r;
                                        (v = y < 0 ? new t(x) : new t(x,y,_)).ondata = function(t, e, n) {
                                            b.ondata(t, e, n)
                                        }
                                        ;
                                        for (var e = 0, i = g; e < i.length; e++) {
                                            var s = i[e];
                                            v.push(s, !1)
                                        }
                                        n.k[0] == g && n.c ? n.d = v : v.push(d_, !0)
                                    } else
                                        b.ondata(null, d_, !0)
                                },
                                terminate: function() {
                                    v && v.terminate && v.terminate()
                                }
                            };
                            y >= 0 && (b.size = y,
                            b.originalSize = _),
                            p.onfile(b)
                        }
                        return "break"
                    }
                    if (h) {
                        if (134695760 == e)
                            return a = o += 12 + (-2 == h && 8),
                            s = 3,
                            p.c = 0,
                            "break";
                        if (33639248 == e)
                            return a = o -= 4,
                            s = 3,
                            p.c = 0,
                            "break"
                    }
                }, p = this; o < c - 4 && "break" !== d(); ++o)
                    ;
                if (this.p = d_,
                h < 0) {
                    var f = s ? l.subarray(0, a - 12 - (-2 == h && 8) - (134695760 == O_(l, a - 16) && 4)) : l.subarray(0, o);
                    u ? u.push(f, !!s) : this.k[+(2 == s)].push(f)
                }
                if (2 & s)
                    return this.push(l.subarray(o), e);
                this.p = l.subarray(o)
            }
            if (e) {
                if (this.c)
                    throw "invalid zip file";
                this.p = null
            }
        }
        ,
        t.prototype.register = function(t) {
            this.o[t.compression] = t
        }
        ,
        t
    }();
    function Wx(t, e) {
        if ("function" != typeof e)
            throw "no callback";
        for (var n = [], i = function() {
            for (var t = 0; t < n.length; ++t)
                n[t]()
        }, r = {}, s = t.length - 22; 101010256 != O_(t, s); --s)
            if (!s || t.length - s > 65558)
                return void e("invalid zip file", null);
        var o = I_(t, s + 8);
        o || e(null, {});
        var a = o
          , l = O_(t, s + 16)
          , c = 4294967295 == l;
        if (c) {
            if (s = O_(t, s - 12),
            101075792 != O_(t, s))
                return void e("invalid zip file", null);
            a = o = O_(t, s + 32),
            l = O_(t, s + 48)
        }
        for (var h = function(s) {
            var a = Lx(t, l, c)
              , h = a[0]
              , u = a[1]
              , d = a[2]
              , p = a[3]
              , f = a[4]
              , m = a[5]
              , g = Rx(t, m);
            l = f;
            var v = function(t, n) {
                t ? (i(),
                e(t, null)) : (r[p] = n,
                --o || e(null, r))
            };
            if (h)
                if (8 == h) {
                    var y = t.subarray(g, g + u);
                    if (u < 32e4)
                        try {
                            v(null, K_(y, new Ry(d)))
                        } catch (t) {
                            v(t, null)
                        }
                    else
                        n.push(J_(y, {
                            size: d
                        }, v))
                } else
                    v("unknown compression type " + h, null);
            else
                v(null, e_(t, g, g + u))
        }, u = 0; u < a; ++u)
            h();
        return i
    }
    function jx(t) {
        for (var e = {}, n = t.length - 22; 101010256 != O_(t, n); --n)
            if (!n || t.length - n > 65558)
                throw "invalid zip file";
        var i = I_(t, n + 8);
        if (!i)
            return {};
        var r = O_(t, n + 16)
          , s = 4294967295 == r;
        if (s) {
            if (n = O_(t, n - 12),
            101075792 != O_(t, n))
                throw "invalid zip file";
            i = O_(t, n + 32),
            r = O_(t, n + 48)
        }
        for (var o = 0; o < i; ++o) {
            var a = Lx(t, r, s)
              , l = a[0]
              , c = a[1]
              , h = a[2]
              , u = a[3]
              , d = a[4]
              , p = a[5]
              , f = Rx(t, p);
            if (r = d,
            l) {
                if (8 != l)
                    throw "unknown compression type " + l;
                e[u] = K_(t.subarray(f, f + c), new Ry(h))
            } else
                e[u] = e_(t, f, f + c)
        }
        return e
    }
    var Xx = class extends qc {
        constructor(t=new Ea) {
            super({
                name: "KawaseBlurMaterial",
                uniforms: {
                    inputBuffer: new cg(null),
                    texelSize: new cg(new Ea),
                    halfTexelSize: new cg(new Ea),
                    kernel: new cg(0),
                    scale: new cg(1)
                },
                blending: 0,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <encodings_fragment>\n#include <dithering_fragment>\n}",
                vertexShader: "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
            }),
            this.toneMapped = !1,
            this.setTexelSize(t.x, t.y)
        }
        setInputBuffer(t) {
            this.uniforms.inputBuffer.value = t
        }
        getScale() {
            return this.uniforms.scale.value
        }
        setScale(t) {
            this.uniforms.scale.value = t
        }
        getKernel() {
            return null
        }
        setKernel(t) {
            this.uniforms.kernel.value = t
        }
        setTexelSize(t, e) {
            this.uniforms.texelSize.value.set(t, e),
            this.uniforms.halfTexelSize.value.set(t, e).multiplyScalar(.5)
        }
        setSize(t, e) {
            const n = this.uniforms;
            n.texelSize.value.set(1 / t, 1 / e),
            n.halfTexelSize.value.copy(n.texelSize.value).multiplyScalar(.5)
        }
    }
      , qx = new Yc
      , Yx = null
      , Zx = (new lc,
    -1)
      , Jx = class extends da {
        constructor(t, e=-1, n=-1, i=1) {
            super(),
            this.resizable = t,
            this.base = new Ea(1,1),
            this.preferred = new Ea(e,n),
            this.target = this.preferred,
            this.s = i
        }
        get scale() {
            return this.getScale()
        }
        set scale(t) {
            this.setScale(t)
        }
        get width() {
            return this.getWidth()
        }
        set width(t) {
            this.setPreferredWidth(t)
        }
        get height() {
            return this.getHeight()
        }
        set height(t) {
            this.setPreferredHeight(t)
        }
        copy(t) {
            this.base.set(t.getBaseWidth(), t.getBaseHeight()),
            this.preferred.set(t.getPreferredWidth(), t.getPreferredHeight()),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height)
        }
        getWidth() {
            const {base: t, preferred: e, scale: n} = this;
            let i;
            return i = e.width !== Zx ? e.width : e.height !== Zx ? Math.round(e.height * (t.width / Math.max(t.height, 1))) : Math.round(t.width * n),
            i
        }
        getHeight() {
            const {base: t, preferred: e, scale: n} = this;
            let i;
            return i = e.height !== Zx ? e.height : e.width !== Zx ? Math.round(e.width / Math.max(t.width / Math.max(t.height, 1), 1)) : Math.round(t.height * n),
            i
        }
        getScale() {
            return this.s
        }
        setScale(t) {
            this.s !== t && (this.s = t,
            this.preferred.setScalar(Zx),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        getBaseWidth() {
            return this.base.width
        }
        setBaseWidth(t) {
            this.base.width !== t && (this.base.width = t,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        getBaseHeight() {
            return this.base.height
        }
        setBaseHeight(t) {
            this.base.height !== t && (this.base.height = t,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        setBaseSize(t, e) {
            this.base.width === t && this.base.height === e || (this.base.set(t, e),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        getPreferredWidth() {
            return this.preferred.width
        }
        setPreferredWidth(t) {
            this.preferred.width !== t && (this.preferred.width = t,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        getPreferredHeight() {
            return this.preferred.height
        }
        setPreferredHeight(t) {
            this.preferred.height !== t && (this.preferred.height = t,
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        setPreferredSize(t, e) {
            this.preferred.width === t && this.preferred.height === e || (this.preferred.set(t, e),
            this.dispatchEvent({
                type: "change"
            }),
            this.resizable.setSize(this.base.width, this.base.height))
        }
        static get AUTO_SIZE() {
            return Zx
        }
    }
    ;
    new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]);
    var Kx = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]
      , Qx = {
        VERY_SMALL: 0,
        SMALL: 1,
        MEDIUM: 2,
        LARGE: 3,
        VERY_LARGE: 4,
        HUGE: 5
    };
    function $x(t, e, n) {
        return t + (e - t) * n
    }
    function tb(t, e, n, i) {
        const r = $x(t, e, .75)
          , s = $x(n, i, .75);
        return $x(r, s, .875)
    }
    Set,
    new Ua,
    new vl,
    new lc,
    Math.PI,
    new Ua,
    new Ua,
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array(3),
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1]),
    new Float32Array([0, 0, 0]),
    new Float32Array([1, 0, 0]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1]),
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([1, 0, 1]),
    new Float32Array([1, 1, 1]),
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([1, 1, 0]),
    new Float32Array([1, 1, 1]),
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 1, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1]),
    new Float32Array([0, 0, 0]),
    new Float32Array([0, 0, 1]),
    new Float32Array([0, 1, 1]),
    new Float32Array([1, 1, 1]),
    new Float32Array(2),
    new Float32Array(2),
    new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]),
    new Float32Array([0, 0]),
    new Float32Array([.25, -.25]),
    new Float32Array([-.25, .25]),
    new Float32Array([.125, -.125]),
    new Float32Array([-.125, .125]),
    new Uint8Array([0, 0]),
    new Uint8Array([3, 0]),
    new Uint8Array([0, 3]),
    new Uint8Array([3, 3]),
    new Uint8Array([1, 0]),
    new Uint8Array([4, 0]),
    new Uint8Array([1, 3]),
    new Uint8Array([4, 3]),
    new Uint8Array([0, 1]),
    new Uint8Array([3, 1]),
    new Uint8Array([0, 4]),
    new Uint8Array([3, 4]),
    new Uint8Array([1, 1]),
    new Uint8Array([4, 1]),
    new Uint8Array([1, 4]),
    new Uint8Array([4, 4]),
    new Uint8Array([0, 0]),
    new Uint8Array([1, 0]),
    new Uint8Array([0, 2]),
    new Uint8Array([1, 2]),
    new Uint8Array([2, 0]),
    new Uint8Array([3, 0]),
    new Uint8Array([2, 2]),
    new Uint8Array([3, 2]),
    new Uint8Array([0, 1]),
    new Uint8Array([1, 1]),
    new Uint8Array([0, 3]),
    new Uint8Array([1, 3]),
    new Uint8Array([2, 1]),
    new Uint8Array([3, 1]),
    new Uint8Array([2, 3]),
    new Uint8Array([3, 3]),
    tb(0, 0, 0, 0),
    new Float32Array([0, 0, 0, 0]),
    tb(0, 0, 0, 1),
    new Float32Array([0, 0, 0, 1]),
    tb(0, 0, 1, 0),
    new Float32Array([0, 0, 1, 0]),
    tb(0, 0, 1, 1),
    new Float32Array([0, 0, 1, 1]),
    tb(0, 1, 0, 0),
    new Float32Array([0, 1, 0, 0]),
    tb(0, 1, 0, 1),
    new Float32Array([0, 1, 0, 1]),
    tb(0, 1, 1, 0),
    new Float32Array([0, 1, 1, 0]),
    tb(0, 1, 1, 1),
    new Float32Array([0, 1, 1, 1]),
    tb(1, 0, 0, 0),
    new Float32Array([1, 0, 0, 0]),
    tb(1, 0, 0, 1),
    new Float32Array([1, 0, 0, 1]),
    tb(1, 0, 1, 0),
    new Float32Array([1, 0, 1, 0]),
    tb(1, 0, 1, 1),
    new Float32Array([1, 0, 1, 1]),
    tb(1, 1, 0, 0),
    new Float32Array([1, 1, 0, 0]),
    tb(1, 1, 0, 1),
    new Float32Array([1, 1, 0, 1]),
    tb(1, 1, 1, 0),
    new Float32Array([1, 1, 1, 0]),
    tb(1, 1, 1, 1),
    new Float32Array([1, 1, 1, 1]);
    class eb extends Yf {
        constructor(t, e, n, i, {mixBlur: r=0, mixStrength: s=1, resolution: o=256, blur: a=[0, 0], minDepthThreshold: l=.9, maxDepthThreshold: c=1, depthScale: h=0, depthToBlurRatioBias: u=.25, mirror: d=0, distortion: p=1, mixContrast: f=1, distortionMap: m, reflectorOffset: g=0, bufferSamples: v=8, planeNormal: y=new Ua(0,0,1)}={}) {
            super(),
            this.gl = t,
            this.camera = e,
            this.scene = n,
            this.parent = i,
            this.hasBlur = a[0] + a[1] > 0,
            this.reflectorPlane = new ih,
            this.normal = new Ua,
            this.reflectorWorldPosition = new Ua,
            this.cameraWorldPosition = new Ua,
            this.rotationMatrix = new vl,
            this.lookAtPosition = new Ua(0,-1,0),
            this.clipPlane = new Na,
            this.view = new Ua,
            this.target = new Ua,
            this.q = new Na,
            this.textureMatrix = new vl,
            this.virtualCamera = new Zc,
            this.reflectorOffset = g,
            this.planeNormal = y,
            this.setupBuffers(o, a, v),
            this.reflectorProps = {
                mirror: d,
                textureMatrix: this.textureMatrix,
                mixBlur: r,
                tDiffuse: this.fbo1.texture,
                tDepth: this.fbo1.depthTexture,
                tDiffuseBlur: this.fbo2.texture,
                hasBlur: this.hasBlur,
                mixStrength: s,
                minDepthThreshold: l,
                maxDepthThreshold: c,
                depthScale: h,
                depthToBlurRatioBias: u,
                distortion: p,
                distortionMap: m,
                mixContrast: f,
                "defines-USE_BLUR": this.hasBlur ? "" : void 0,
                "defines-USE_DEPTH": h > 0 ? "" : void 0,
                "defines-USE_DISTORTION": m ? "" : void 0
            }
        }
        setupBuffers(t, e, n) {
            const i = {
                minFilter: Uo,
                magFilter: Uo,
                encoding: this.gl.outputEncoding
            }
              , r = new za(t,t,i);
            r.depthBuffer = !0,
            r.depthTexture = new qp(t,t),
            r.depthTexture.format = Jo,
            r.depthTexture.type = Go;
            const s = new za(t,t,i);
            this.gl.capabilities.isWebGL2 && (r.samples = n),
            this.fbo1 = r,
            this.fbo2 = s,
            this.kawaseBlurPass = new class extends class {
                constructor(t="Pass", e=new Yd, n=qx) {
                    this.name = t,
                    this.renderer = null,
                    this.scene = e,
                    this.camera = n,
                    this.screen = null,
                    this.rtt = !0,
                    this.needsSwap = !0,
                    this.needsDepthTexture = !1,
                    this.enabled = !0
                }
                get renderToScreen() {
                    return !this.rtt
                }
                set renderToScreen(t) {
                    if (this.rtt === t) {
                        const e = this.getFullscreenMaterial();
                        null !== e && (e.needsUpdate = !0),
                        this.rtt = !t
                    }
                }
                setRenderer(t) {
                    this.renderer = t
                }
                isEnabled() {
                    return this.enabled
                }
                setEnabled(t) {
                    this.enabled = t
                }
                getFullscreenMaterial() {
                    return null !== this.screen ? this.screen.material : null
                }
                setFullscreenMaterial(t) {
                    let e = this.screen;
                    null !== e ? e.material = t : (e = new Hc(function() {
                        if (null === Yx) {
                            const t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
                              , e = new Float32Array([0, 0, 2, 0, 0, 2]);
                            void 0 !== (Yx = new Mc).setAttribute ? (Yx.setAttribute("position", new dc(t,3)),
                            Yx.setAttribute("uv", new dc(e,2))) : (Yx.addAttribute("position", new dc(t,3)),
                            Yx.addAttribute("uv", new dc(e,2)))
                        }
                        return Yx
                    }(),t),
                    e.frustumCulled = !1,
                    null === this.scene && (this.scene = new Yd),
                    this.scene.add(e),
                    this.screen = e)
                }
                getDepthTexture() {
                    return null
                }
                setDepthTexture(t, e=0) {}
                render(t, e, n, i, r) {
                    throw new Error("Render method not implemented!")
                }
                setSize(t, e) {}
                initialize(t, e, n) {}
                dispose() {
                    const t = this.getFullscreenMaterial();
                    null !== t && t.dispose();
                    for (const t of Object.keys(this)) {
                        const e = this[t];
                        if (null !== e && "function" == typeof e.dispose) {
                            if (e instanceof Yd)
                                continue;
                            this[t].dispose()
                        }
                    }
                }
            }
            {
                constructor({resolutionScale: t=.5, width: e=Jx.AUTO_SIZE, height: n=Jx.AUTO_SIZE, kernelSize: i=Qx.LARGE}={}) {
                    super("KawaseBlurPass"),
                    this.renderTargetA = new za(1,1,{
                        minFilter: Uo,
                        magFilter: Uo,
                        stencilBuffer: !1,
                        depthBuffer: !1
                    }),
                    this.renderTargetA.texture.name = "Blur.Target.A",
                    this.renderTargetB = this.renderTargetA.clone(),
                    this.renderTargetB.texture.name = "Blur.Target.B",
                    this.resolution = new Jx(this,e,n,t),
                    this.resolution.addEventListener("change", (t=>this.setSize(this.resolution.getBaseWidth(), this.resolution.getBaseHeight()))),
                    this.blurMaterial = new Xx,
                    this.ditheredBlurMaterial = new Xx,
                    this.ditheredBlurMaterial.dithering = !0,
                    this.dithering = !1,
                    this.kernelSize = i
                }
                getResolution() {
                    return this.resolution
                }
                get width() {
                    return this.resolution.getWidth()
                }
                set width(t) {
                    this.resolution.setPreferredWidth(t)
                }
                get height() {
                    return this.resolution.getHeight()
                }
                set height(t) {
                    this.resolution.setPreferredHeight(t)
                }
                get scale() {
                    return this.getScale()
                }
                set scale(t) {
                    this.setScale(t)
                }
                getScale() {
                    return this.blurMaterial.getScale()
                }
                setScale(t) {
                    this.blurMaterial.setScale(t),
                    this.ditheredBlurMaterial.setScale(t)
                }
                getKernelSize() {
                    return this.kernelSize
                }
                setKernelSize(t) {
                    this.kernelSize = t
                }
                getResolutionScale() {
                    return this.resolution.scale
                }
                setResolutionScale(t) {
                    this.resolution.scale = t
                }
                render(t, e, n, i, r) {
                    const s = this.scene
                      , o = this.camera
                      , a = this.renderTargetA
                      , l = this.renderTargetB
                      , c = Kx[this.kernelSize];
                    let h, u, d = this.blurMaterial, p = e;
                    for (this.setFullscreenMaterial(d),
                    h = 0,
                    u = c.length - 1; h < u; ++h) {
                        const e = 0 == (1 & h) ? a : l;
                        d.setKernel(c[h]),
                        d.setInputBuffer(p.texture),
                        t.setRenderTarget(e),
                        t.render(s, o),
                        p = e
                    }
                    this.dithering && (d = this.ditheredBlurMaterial,
                    this.setFullscreenMaterial(d)),
                    d.setKernel(c[h]),
                    d.setInputBuffer(p.texture),
                    t.setRenderTarget(this.renderToScreen ? null : n),
                    t.render(s, o)
                }
                setSize(t, e) {
                    const n = this.resolution;
                    n.setBaseSize(t, e);
                    const i = n.getWidth()
                      , r = n.getHeight();
                    this.renderTargetA.setSize(i, r),
                    this.renderTargetB.setSize(i, r),
                    this.blurMaterial.setSize(i, r),
                    this.ditheredBlurMaterial.setSize(i, r)
                }
                initialize(t, e, n) {
                    void 0 !== n && (this.renderTargetA.texture.type = n,
                    this.renderTargetB.texture.type = n,
                    n !== Vo && (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                    this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"))
                }
                static get AUTO_SIZE() {
                    return Jx.AUTO_SIZE
                }
            }
            ,
            this.kawaseBlurPass.setSize(e[0], e[1])
        }
        beforeRender() {
            if (!this.parent)
                return;
            if (this.reflectorWorldPosition.setFromMatrixPosition(this.parent.matrixWorld),
            this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),
            this.rotationMatrix.extractRotation(this.parent.matrixWorld),
            this.normal.copy(this.planeNormal),
            this.normal.applyMatrix4(this.rotationMatrix),
            this.reflectorWorldPosition.addScaledVector(this.normal, this.reflectorOffset),
            this.view.subVectors(this.reflectorWorldPosition, this.cameraWorldPosition),
            this.view.dot(this.normal) > 0)
                return;
            this.view.reflect(this.normal).negate(),
            this.view.add(this.reflectorWorldPosition),
            this.rotationMatrix.extractRotation(this.camera.matrixWorld),
            this.lookAtPosition.set(0, 0, -1),
            this.lookAtPosition.applyMatrix4(this.rotationMatrix),
            this.lookAtPosition.add(this.cameraWorldPosition),
            this.target.subVectors(this.reflectorWorldPosition, this.lookAtPosition),
            this.target.reflect(this.normal).negate(),
            this.target.add(this.reflectorWorldPosition),
            this.virtualCamera.position.copy(this.view),
            this.virtualCamera.up.set(0, 1, 0),
            this.virtualCamera.up.applyMatrix4(this.rotationMatrix),
            this.virtualCamera.up.reflect(this.normal),
            this.virtualCamera.lookAt(this.target),
            this.virtualCamera.far = this.camera.far,
            this.virtualCamera.updateMatrixWorld(),
            this.virtualCamera.projectionMatrix.copy(this.camera.projectionMatrix),
            this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            this.textureMatrix.multiply(this.virtualCamera.projectionMatrix),
            this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse),
            this.textureMatrix.multiply(this.parent.matrixWorld),
            this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal, this.reflectorWorldPosition),
            this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse),
            this.clipPlane.set(this.reflectorPlane.normal.x, this.reflectorPlane.normal.y, this.reflectorPlane.normal.z, this.reflectorPlane.constant);
            const t = this.virtualCamera.projectionMatrix;
            this.q.x = (Math.sign(this.clipPlane.x) + t.elements[8]) / t.elements[0],
            this.q.y = (Math.sign(this.clipPlane.y) + t.elements[9]) / t.elements[5],
            this.q.z = -1,
            this.q.w = (1 + t.elements[10]) / t.elements[14],
            this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(this.q)),
            t.elements[2] = this.clipPlane.x,
            t.elements[6] = this.clipPlane.y,
            t.elements[10] = this.clipPlane.z + 1,
            t.elements[14] = this.clipPlane.w
        }
        update() {
            if (this.parent.material !== this)
                return;
            this.parent.visible = !1;
            const t = this.gl.xr.enabled
              , e = this.gl.shadowMap.autoUpdate;
            this.beforeRender(),
            this.gl.xr.enabled = !1,
            this.gl.shadowMap.autoUpdate = !1,
            this.gl.setRenderTarget(this.fbo1),
            this.gl.state.buffers.depth.setMask(!0),
            this.gl.autoClear || this.gl.clear(),
            this.gl.render(this.scene, this.virtualCamera),
            this.hasBlur && this.kawaseBlurPass.render(this.gl, this.fbo1, this.fbo2),
            this.gl.xr.enabled = t,
            this.gl.shadowMap.autoUpdate = e,
            this.parent.visible = !0,
            this.gl.setRenderTarget(null)
        }
        onBeforeCompile(t, ...e) {
            super.onBeforeCompile(t, ...e),
            t.defines?.USE_UV || (t.defines.USE_UV = ""),
            t.defines.USE_DEPTH = !0,
            t.defines.USE_BLUR = this.hasBlur;
            let n = this.reflectorProps;
            for (let e in n)
                t.uniforms[e] = {
                    get value() {
                        return n[e]
                    }
                };
            t.vertexShader = `\n            uniform mat4 textureMatrix;\n            varying vec4 my_vUv;     \n          ${t.vertexShader}`,
            t.vertexShader = t.vertexShader.replace("#include <project_vertex>", "\n          #include <project_vertex>\n          my_vUv = textureMatrix * vec4( position, 1.0 );\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n          "),
            t.fragmentShader = `\n            uniform sampler2D tDiffuse;\n            uniform sampler2D tDiffuseBlur;\n            uniform sampler2D tDepth;\n            uniform sampler2D distortionMap;\n            uniform float distortion;\n            uniform float cameraNear;\n            uniform float cameraFar;\n            uniform bool hasBlur;\n            uniform float mixBlur;\n            uniform float mirror;\n            uniform float mixStrength;\n            uniform float minDepthThreshold;\n            uniform float maxDepthThreshold;\n            uniform float mixContrast;\n            uniform float depthScale;\n            uniform float depthToBlurRatioBias;\n            varying vec4 my_vUv;        \n            ${t.fragmentShader}`,
            t.fragmentShader = t.fragmentShader.replace("#include <emissivemap_fragment>", "\n          #include <emissivemap_fragment>\n        \n          float distortionFactor = 0.0;\n          #ifdef USE_DISTORTION\n            distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n          #endif\n    \n          vec4 new_vUv = my_vUv;\n          new_vUv.x += distortionFactor;\n          new_vUv.y += distortionFactor;\n    \n          vec4 base = texture2DProj(tDiffuse, new_vUv);\n          vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n          \n          vec4 merge = base;\n          \n          #ifdef USE_NORMALMAP\n            vec2 normal_uv = vec2(0.0);\n            \n            vec3 coord = new_vUv.xyz / new_vUv.w;\n            normal_uv = coord.xy + coord.z * normal.xz * 0.1;\n            \n            vec4 base_normal = texture2D(tDiffuse, normal_uv);\n            vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n\n            merge = base_normal;\n            blur = blur_normal;\n          #endif\n    \n          float depthFactor = 0.0001;\n          float blurFactor = 0.0;\n    \n          #ifdef USE_DEPTH\n            vec4 depth = texture2DProj(tDepth, new_vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0001, min(1.0, depthFactor));\n    \n            #ifdef USE_BLUR\n              blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n              merge = merge * min(1.0, depthFactor + 0.5);\n            #else\n              merge = merge * depthFactor;\n            #endif\n      \n          #endif\n    \n          float reflectorRoughnessFactor = roughness;\n          #ifdef USE_ROUGHNESSMAP\n            vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n            \n            reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n          #endif\n          \n          #ifdef USE_BLUR\n            blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n            merge = mix(merge, blur, blurFactor);\n          #endif\n    \n          vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n          newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n          newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n          newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n          // need to use max due to adjusting the contrast\n          vec3 reflectionClr = max(vec3(0.), newMerge.rgb) * mixStrength;\n          \n          diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + reflectionClr);\n          ")
        }
    }
    Xi.registerPlugin(ws),
    document.getElementById("btnVoltar");
    const nb = document.getElementById("header")
      , ib = document.getElementById("button-scroll")
      , rb = document.getElementById("music")
      , sb = document.getElementById("btn-continue-explore")
      , ob = document.getElementById("button-zoom")
      , ab = document.querySelector(".loading-bar")
      , lb = (document.getElementById("progress"),
    document.querySelector(".lds-roller"));
    let cb, hb, ub, db, pb, fb, mb, gb, vb, yb, _b, xb, bb, wb, Mb, Sb, Tb, Eb, Ab, Rb, Lb, Cb, Pb, Db, Ib, Ob, kb, Nb, zb = new Ea, Bb = !0, Fb = !1, Ub = !1, Hb = !1;
    const Vb = new Vm;
    let Gb = !0
      , Wb = !1;
    const jb = new Lo({
        el: document.querySelector(".scrollContainer"),
        smooth: !0
    });
    jb.on("scroll", ws.update),
    ws.scrollerProxy(".scrollContainer", {
        scrollTop(t) {
            return arguments.length ? jb.scrollTo(t, 0, 0) : jb.scroll.instance.scroll.y
        },
        getBoundingClientRect: ()=>({
            top: 0,
            left: 0,
            width: window.innerWidth,
            height: window.innerHeight
        }),
        pinType: document.querySelector(".scrollContainer").style.transform ? "transform" : "fixed"
    }),
    ws.addEventListener("refresh", (()=>jb.update())),
    ws.refresh(),
    jb.stop();
    let Xb = !1;
    if (window.location.hash)
        var qb = window.location.hash.substring(1);
    function Yb() {
        Hb = !0,
        Nb = new Vm
    }
    "debug" == qb && (Xb = !0,
    kb = new wy,
    kb.closed = !0,
    window.setTimeout((function() {
        pb = new Sy,
        document.body.appendChild(pb.dom),
        fb.remove(xw),
        _b.enablePan = !0,
        _b.screenSpacePanning = !0,
        _b.enabled = !0,
        _b.enableRotate = !0,
        db.lookAt(_b.target),
        document.getElementById("loading-text-intro").parentNode.removeChild(document.getElementById("loading-text-intro")),
        document.getElementById("div-points").style.visibility = "visible",
        document.getElementById("body").style.overflow = "hidden",
        ob.style.visibility = "hidden",
        jb.stop()
    }
    ), 200),
    window.setTimeout(Yb, 3e3),
    lb.parentNode.removeChild(lb),
    document.getElementById("body").style.overflow = "hidden",
    document.getElementById("section-logo").style.visibility = "hidden",
    document.getElementById("section-concept").style.visibility = "hidden",
    document.getElementById("section-logo").style.pointerEvents = "none");
    let Zb = !1;
    "max" == qb && (Zb = !0,
    lb.parentNode.removeChild(lb)),
    0 == Xb && (Cb = new dm((()=>{
        fb.remove(xw),
        Xi.to("#loading-text-intro", {
            y: "100%",
            onComplete: function() {
                document.getElementById("loading-text-intro").parentNode.removeChild(document.getElementById("loading-text-intro"))
            },
            duration: .9,
            ease: "power3.inOut"
        }),
        ab.parentNode.removeChild(ab),
        lb.parentNode.removeChild(lb),
        ab.style.transform = "",
        ab.classList.add("ended"),
        document.getElementById("body").style.overflow = "auto",
        document.getElementById("section-logo").style.visibility = "visible",
        document.getElementById("btn-continue-explore").style.display = "flex",
        ws.matchMedia({
            "(prefers-reduced-motion: no-preference)": vw
        }),
        window.setTimeout(Yb, 2e3),
        document.querySelector(".sectionContainer").style.display = "flex",
        document.querySelector(".footerContainer").style.display = "flex",
        Kb.to(_b.target.set(.9, .9, -.07), {
            x: -1.4,
            y: 1.8,
            z: 1,
            duration: 6,
            ease: "power3.inOut"
        }).to(db.position.set(-3.7, .9, 4.2), {
            x: -4.1,
            y: 1.5,
            z: 9,
            duration: 6,
            ease: "power3.inOut"
        }, "-=6").to(Tw.uniforms.uPadding.value, {
            x: iw / 7.5,
            y: 40,
            z: 20,
            w: nw / 2.9,
            duration: 2.5,
            ease: "Elastic.easeInOut"
        }, "-=3").to(Tw.uniforms.iRadius, {
            value: "10.0",
            duration: .5,
            ease: "power3.inOut"
        }, "-=2").from("#section-logo h1", {
            y: 150,
            skewY: 5,
            autoAlpha: 0,
            duration: 1.5
        }, "-=2.5").from("#section-logo p", {
            x: 150,
            autoAlpha: 0,
            duration: 1
        }, "-=1").from("#button-scroll", {
            y: -20,
            autoAlpha: 0,
            duration: .5
        }, "-=0.8").from("#button-zoom", {
            y: "120%",
            autoAlpha: 0,
            duration: .5,
            ease: "Elastic.easeOut",
            onComplete: function() {
                nb.style.display = "flex",
                nb.classList.add("down"),
                jb.start(),
                Kb.kill(),
                Wb = !0
            }
        }, "-=0.2")
    }
    ),((t,e,n)=>{
        const i = e / n;
        ab.style.transform = `scaleX(${i})`
    }
    )));
    const Jb = document.getElementById("canvas-container");
    fb = new Yd,
    fb.background = new lc(16777215),
    fb.fog = new Xd(16447706,.018),
    mb = new jd({
        antialias: !0,
        powerPreference: "high-performance"
    }),
    mb.autoClear = !1,
    mb.setPixelRatio(Math.min(window.devicePixelRatio, 1)),
    mb.setSize(Jb.clientWidth, Jb.clientHeight),
    mb.outputEncoding = sa,
    mb.shadowMap.enabled = !1,
    Jb.appendChild(mb.domElement);
    const Kb = Xi.timeline()
      , Qb = Xi.timeline()
      , $b = new class extends fm {
        constructor(t) {
            super(t),
            this.decoderPath = "",
            this.decoderConfig = {},
            this.decoderBinary = null,
            this.decoderPending = null,
            this.workerLimit = 4,
            this.workerPool = [],
            this.workerNextTaskID = 1,
            this.workerSourceURL = "",
            this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            },
            this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            }
        }
        setDecoderPath(t) {
            return this.decoderPath = t,
            this
        }
        setDecoderConfig(t) {
            return this.decoderConfig = t,
            this
        }
        setWorkerLimit(t) {
            return this.workerLimit = t,
            this
        }
        load(t, e, n, i) {
            const r = new gm(this.manager);
            r.setPath(this.path),
            r.setResponseType("arraybuffer"),
            r.setRequestHeader(this.requestHeader),
            r.setWithCredentials(this.withCredentials),
            r.load(t, (t=>{
                const n = {
                    attributeIDs: this.defaultAttributeIDs,
                    attributeTypes: this.defaultAttributeTypes,
                    useUniqueIDs: !1
                };
                this.decodeGeometry(t, n).then(e).catch(i)
            }
            ), n, i)
        }
        decodeDracoFile(t, e, n, i) {
            const r = {
                attributeIDs: n || this.defaultAttributeIDs,
                attributeTypes: i || this.defaultAttributeTypes,
                useUniqueIDs: !!n
            };
            this.decodeGeometry(t, r).then(e)
        }
        decodeGeometry(t, e) {
            for (const t in e.attributeTypes) {
                const n = e.attributeTypes[t];
                void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name)
            }
            const n = JSON.stringify(e);
            if (pv.has(t)) {
                const e = pv.get(t);
                if (e.key === n)
                    return e.promise;
                if (0 === t.byteLength)
                    throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
            }
            let i;
            const r = this.workerNextTaskID++
              , s = t.byteLength
              , o = this._getWorker(r, s).then((n=>(i = n,
            new Promise(((n,s)=>{
                i._callbacks[r] = {
                    resolve: n,
                    reject: s
                },
                i.postMessage({
                    type: "decode",
                    id: r,
                    taskConfig: e,
                    buffer: t
                }, [t])
            }
            ))))).then((t=>this._createGeometry(t.geometry)));
            return o.catch((()=>!0)).then((()=>{
                i && r && this._releaseTask(i, r)
            }
            )),
            pv.set(t, {
                key: n,
                promise: o
            }),
            o
        }
        _createGeometry(t) {
            const e = new Mc;
            t.index && e.setIndex(new dc(t.index.array,1));
            for (let n = 0; n < t.attributes.length; n++) {
                const i = t.attributes[n]
                  , r = i.name
                  , s = i.array
                  , o = i.itemSize;
                e.setAttribute(r, new dc(s,o))
            }
            return e
        }
        _loadLibrary(t, e) {
            const n = new gm(this.manager);
            return n.setPath(this.decoderPath),
            n.setResponseType(e),
            n.setWithCredentials(this.withCredentials),
            new Promise(((e,i)=>{
                n.load(t, e, void 0, i)
            }
            ))
        }
        preload() {
            return this._initDecoder(),
            this
        }
        _initDecoder() {
            if (this.decoderPending)
                return this.decoderPending;
            const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
              , e = [];
            return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
            e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
            this.decoderPending = Promise.all(e).then((e=>{
                const n = e[0];
                t || (this.decoderConfig.wasmBinary = e[1]);
                const i = fv.toString()
                  , r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([r]))
            }
            )),
            this.decoderPending
        }
        _getWorker(t, e) {
            return this._initDecoder().then((()=>{
                if (this.workerPool.length < this.workerLimit) {
                    const t = new Worker(this.workerSourceURL);
                    t._callbacks = {},
                    t._taskCosts = {},
                    t._taskLoad = 0,
                    t.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }),
                    t.onmessage = function(e) {
                        const n = e.data;
                        switch (n.type) {
                        case "decode":
                            t._callbacks[n.id].resolve(n);
                            break;
                        case "error":
                            t._callbacks[n.id].reject(n);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                        }
                    }
                    ,
                    this.workerPool.push(t)
                } else
                    this.workerPool.sort((function(t, e) {
                        return t._taskLoad > e._taskLoad ? -1 : 1
                    }
                    ));
                const n = this.workerPool[this.workerPool.length - 1];
                return n._taskCosts[t] = e,
                n._taskLoad += e,
                n
            }
            ))
        }
        _releaseTask(t, e) {
            t._taskLoad -= t._taskCosts[e],
            delete t._callbacks[e],
            delete t._taskCosts[e]
        }
        debug() {
            console.log("Task load: ", this.workerPool.map((t=>t._taskLoad)))
        }
        dispose() {
            for (let t = 0; t < this.workerPool.length; ++t)
                this.workerPool[t].terminate();
            return this.workerPool.length = 0,
            this
        }
    }
    ;
    function tw() {
        Bb && (Mb = new Ym,
        Sb = new Zm(Mb),
        Tb = "./sounds/music_loop.mp3",
        Eb = new Audio(Tb),
        Ab = new Hm(Cb),
        Bb = !1),
        Ub ? (Ub = !1,
        Eb.pause()) : (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) ? Ab.load(Tb, (function(t) {
            Sb.setBuffer(t),
            Sb.play()
        }
        )) : (Eb.play(),
        Eb.loop = !0,
        Sb.setVolume(.3)),
        Ub = !0,
        Eb.volume = .3)
    }
    $b.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"),
    $b.setDecoderConfig({
        type: "js"
    }),
    0 == Xb ? (Rb = new xm(Cb),
    Lb = new Eg(Cb),
    Lb.setDRACOLoader($b)) : (Rb = new xm,
    Lb = new Eg,
    Lb.setDRACOLoader($b)),
    (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) && (Fb = !0);
    let ew = [];
    Lb.load("static/models/gltf/bird.glb", (function(t) {
        xb = t.scene,
        Pb = new lg(t.scene),
        t.animations.forEach((t=>{
            Pb.clipAction(t).play()
        }
        )),
        xb.scale.set(.1, .1, .1),
        xb.position.set(-40, 15, -90),
        xb.rotation.y = .6,
        xb.name = "bird",
        fb.add(xb)
    }
    )),
    zb = new Ea,
    vb = new hg,
    yb = new hg;
    let nw = Jb.clientWidth
      , iw = Jb.clientHeight
      , rw = !0;
    function sw() {
        rw = !1,
        void 0 !== Eb && Eb.pause()
    }
    function ow() {
        rw = !0,
        Ub && (Eb.play(),
        Eb.volume = .3)
    }
    document.addEventListener("visibilitychange", (function() {
        document.hidden ? void 0 !== Eb & Ub && sw() : void 0 !== Eb & Ub && ow()
    }
    ));
    const aw = new Ud;
    fb.add(aw),
    db = new Zc(46,Jb.clientWidth / Jb.clientHeight,1,85),
    db.position.set(-3.7, 1.7, 11),
    aw.add(db),
    _b = new class extends da {
        constructor(t, e) {
            super(),
            void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
            e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
            this.object = t,
            this.domElement = e,
            this.domElement.style.touchAction = "none",
            this.enabled = !0,
            this.target = new Ua,
            this.minDistance = 0,
            this.maxDistance = 1 / 0,
            this.minZoom = 0,
            this.maxZoom = 1 / 0,
            this.minPolarAngle = 0,
            this.maxPolarAngle = Math.PI,
            this.minAzimuthAngle = -1 / 0,
            this.maxAzimuthAngle = 1 / 0,
            this.enableDamping = !1,
            this.dampingFactor = .05,
            this.enableZoom = !0,
            this.zoomSpeed = 1,
            this.enableRotate = !0,
            this.rotateSpeed = 1,
            this.enablePan = !0,
            this.panSpeed = 1,
            this.screenSpacePanning = !0,
            this.keyPanSpeed = 7,
            this.autoRotate = !1,
            this.autoRotateSpeed = 2,
            this.keys = {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown"
            },
            this.mouseButtons = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            },
            this.touches = {
                ONE: 0,
                TWO: 2
            },
            this.target0 = this.target.clone(),
            this.position0 = this.object.position.clone(),
            this.zoom0 = this.object.zoom,
            this._domElementKeyEvents = null,
            this.getPolarAngle = function() {
                return o.phi
            }
            ,
            this.getAzimuthalAngle = function() {
                return o.theta
            }
            ,
            this.getDistance = function() {
                return this.object.position.distanceTo(this.target)
            }
            ,
            this.listenToKeyEvents = function(t) {
                t.addEventListener("keydown", G),
                this._domElementKeyEvents = t
            }
            ,
            this.saveState = function() {
                n.target0.copy(n.target),
                n.position0.copy(n.object.position),
                n.zoom0 = n.object.zoom
            }
            ,
            this.reset = function() {
                n.target.copy(n.target0),
                n.object.position.copy(n.position0),
                n.object.zoom = n.zoom0,
                n.object.updateProjectionMatrix(),
                n.dispatchEvent(Mg),
                n.update(),
                r = i.NONE
            }
            ,
            this.update = function() {
                const e = new Ua
                  , u = (new Fa).setFromUnitVectors(t.up, new Ua(0,1,0))
                  , d = u.clone().invert()
                  , p = new Ua
                  , f = new Fa
                  , m = 2 * Math.PI;
                return function() {
                    const t = n.object.position;
                    e.copy(t).sub(n.target),
                    e.applyQuaternion(u),
                    o.setFromVector3(e),
                    n.autoRotate && r === i.NONE && M(2 * Math.PI / 60 / 60 * n.autoRotateSpeed),
                    n.enableDamping ? (o.theta += a.theta * n.dampingFactor,
                    o.phi += a.phi * n.dampingFactor) : (o.theta += a.theta,
                    o.phi += a.phi);
                    let g = n.minAzimuthAngle
                      , v = n.maxAzimuthAngle;
                    return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += m : g > Math.PI && (g -= m),
                    v < -Math.PI ? v += m : v > Math.PI && (v -= m),
                    o.theta = g <= v ? Math.max(g, Math.min(v, o.theta)) : o.theta > (g + v) / 2 ? Math.max(g, o.theta) : Math.min(v, o.theta)),
                    o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)),
                    o.makeSafe(),
                    o.radius *= l,
                    o.radius = Math.max(n.minDistance, Math.min(n.maxDistance, o.radius)),
                    !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c),
                    e.setFromSpherical(o),
                    e.applyQuaternion(d),
                    t.copy(n.target).add(e),
                    n.object.lookAt(n.target),
                    !0 === n.enableDamping ? (a.theta *= 1 - n.dampingFactor,
                    a.phi *= 1 - n.dampingFactor,
                    c.multiplyScalar(1 - n.dampingFactor)) : (a.set(0, 0, 0),
                    c.set(0, 0, 0)),
                    l = 1,
                    !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - f.dot(n.object.quaternion)) > s) && (n.dispatchEvent(Mg),
                    p.copy(n.object.position),
                    f.copy(n.object.quaternion),
                    h = !1,
                    !0)
                }
            }(),
            this.dispose = function() {
                n.domElement.removeEventListener("contextmenu", W),
                n.domElement.removeEventListener("pointerdown", B),
                n.domElement.removeEventListener("pointercancel", H),
                n.domElement.removeEventListener("wheel", V),
                n.domElement.removeEventListener("pointermove", F),
                n.domElement.removeEventListener("pointerup", U),
                null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", G)
            }
            ;
            const n = this
              , i = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6
            };
            let r = i.NONE;
            const s = 1e-6
              , o = new pg
              , a = new pg;
            let l = 1;
            const c = new Ua;
            let h = !1;
            const u = new Ea
              , d = new Ea
              , p = new Ea
              , f = new Ea
              , m = new Ea
              , g = new Ea
              , v = new Ea
              , y = new Ea
              , _ = new Ea
              , x = []
              , b = {};
            function w() {
                return Math.pow(.95, n.zoomSpeed)
            }
            function M(t) {
                a.theta -= t
            }
            function S(t) {
                a.phi -= t
            }
            const T = function() {
                const t = new Ua;
                return function(e, n) {
                    t.setFromMatrixColumn(n, 0),
                    t.multiplyScalar(-e),
                    c.add(t)
                }
            }()
              , E = function() {
                const t = new Ua;
                return function(e, i) {
                    !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0),
                    t.crossVectors(n.object.up, t)),
                    t.multiplyScalar(e),
                    c.add(t)
                }
            }()
              , A = function() {
                const t = new Ua;
                return function(e, i) {
                    const r = n.domElement;
                    if (n.object.isPerspectiveCamera) {
                        const s = n.object.position;
                        t.copy(s).sub(n.target);
                        let o = t.length();
                        o *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                        T(2 * e * o / r.clientHeight, n.object.matrix),
                        E(2 * i * o / r.clientHeight, n.object.matrix)
                    } else
                        n.object.isOrthographicCamera ? (T(e * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix),
                        E(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                        n.enablePan = !1)
                }
            }();
            function R(t) {
                n.object.isPerspectiveCamera ? l /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)),
                n.object.updateProjectionMatrix(),
                h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                n.enableZoom = !1)
            }
            function L(t) {
                n.object.isPerspectiveCamera ? l *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)),
                n.object.updateProjectionMatrix(),
                h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                n.enableZoom = !1)
            }
            function C(t) {
                u.set(t.clientX, t.clientY)
            }
            function P(t) {
                f.set(t.clientX, t.clientY)
            }
            function D() {
                if (1 === x.length)
                    u.set(x[0].pageX, x[0].pageY);
                else {
                    const t = .5 * (x[0].pageX + x[1].pageX)
                      , e = .5 * (x[0].pageY + x[1].pageY);
                    u.set(t, e)
                }
            }
            function I() {
                if (1 === x.length)
                    f.set(x[0].pageX, x[0].pageY);
                else {
                    const t = .5 * (x[0].pageX + x[1].pageX)
                      , e = .5 * (x[0].pageY + x[1].pageY);
                    f.set(t, e)
                }
            }
            function O() {
                const t = x[0].pageX - x[1].pageX
                  , e = x[0].pageY - x[1].pageY
                  , n = Math.sqrt(t * t + e * e);
                v.set(0, n)
            }
            function k(t) {
                if (1 == x.length)
                    d.set(t.pageX, t.pageY);
                else {
                    const e = q(t)
                      , n = .5 * (t.pageX + e.x)
                      , i = .5 * (t.pageY + e.y);
                    d.set(n, i)
                }
                p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
                const e = n.domElement;
                M(2 * Math.PI * p.x / e.clientHeight),
                S(2 * Math.PI * p.y / e.clientHeight),
                u.copy(d)
            }
            function N(t) {
                if (1 === x.length)
                    m.set(t.pageX, t.pageY);
                else {
                    const e = q(t)
                      , n = .5 * (t.pageX + e.x)
                      , i = .5 * (t.pageY + e.y);
                    m.set(n, i)
                }
                g.subVectors(m, f).multiplyScalar(n.panSpeed),
                A(g.x, g.y),
                f.copy(m)
            }
            function z(t) {
                const e = q(t)
                  , i = t.pageX - e.x
                  , r = t.pageY - e.y
                  , s = Math.sqrt(i * i + r * r);
                y.set(0, s),
                _.set(0, Math.pow(y.y / v.y, n.zoomSpeed)),
                R(_.y),
                v.copy(y)
            }
            function B(t) {
                !1 !== n.enabled && (0 === x.length && (n.domElement.setPointerCapture(t.pointerId),
                n.domElement.addEventListener("pointermove", F),
                n.domElement.addEventListener("pointerup", U)),
                function(t) {
                    x.push(t)
                }(t),
                "touch" === t.pointerType ? function(t) {
                    switch (X(t),
                    x.length) {
                    case 1:
                        switch (n.touches.ONE) {
                        case 0:
                            if (!1 === n.enableRotate)
                                return;
                            D(),
                            r = i.TOUCH_ROTATE;
                            break;
                        case 1:
                            if (!1 === n.enablePan)
                                return;
                            I(),
                            r = i.TOUCH_PAN;
                            break;
                        default:
                            r = i.NONE
                        }
                        break;
                    case 2:
                        switch (n.touches.TWO) {
                        case 2:
                            if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                            n.enableZoom && O(),
                            n.enablePan && I(),
                            r = i.TOUCH_DOLLY_PAN;
                            break;
                        case 3:
                            if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                            n.enableZoom && O(),
                            n.enableRotate && D(),
                            r = i.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            r = i.NONE
                        }
                        break;
                    default:
                        r = i.NONE
                    }
                    r !== i.NONE && n.dispatchEvent(Sg)
                }(t) : function(t) {
                    let e;
                    switch (t.button) {
                    case 0:
                        e = n.mouseButtons.LEFT;
                        break;
                    case 1:
                        e = n.mouseButtons.MIDDLE;
                        break;
                    case 2:
                        e = n.mouseButtons.RIGHT;
                        break;
                    default:
                        e = -1
                    }
                    switch (e) {
                    case 1:
                        if (!1 === n.enableZoom)
                            return;
                        !function(t) {
                            v.set(t.clientX, t.clientY)
                        }(t),
                        r = i.DOLLY;
                        break;
                    case 0:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan)
                                return;
                            P(t),
                            r = i.PAN
                        } else {
                            if (!1 === n.enableRotate)
                                return;
                            C(t),
                            r = i.ROTATE
                        }
                        break;
                    case 2:
                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate)
                                return;
                            C(t),
                            r = i.ROTATE
                        } else {
                            if (!1 === n.enablePan)
                                return;
                            P(t),
                            r = i.PAN
                        }
                        break;
                    default:
                        r = i.NONE
                    }
                    r !== i.NONE && n.dispatchEvent(Sg)
                }(t))
            }
            function F(t) {
                !1 !== n.enabled && ("touch" === t.pointerType ? function(t) {
                    switch (X(t),
                    r) {
                    case i.TOUCH_ROTATE:
                        if (!1 === n.enableRotate)
                            return;
                        k(t),
                        n.update();
                        break;
                    case i.TOUCH_PAN:
                        if (!1 === n.enablePan)
                            return;
                        N(t),
                        n.update();
                        break;
                    case i.TOUCH_DOLLY_PAN:
                        if (!1 === n.enableZoom && !1 === n.enablePan)
                            return;
                        !function(t) {
                            n.enableZoom && z(t),
                            n.enablePan && N(t)
                        }(t),
                        n.update();
                        break;
                    case i.TOUCH_DOLLY_ROTATE:
                        if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                        !function(t) {
                            n.enableZoom && z(t),
                            n.enableRotate && k(t)
                        }(t),
                        n.update();
                        break;
                    default:
                        r = i.NONE
                    }
                }(t) : function(t) {
                    if (!1 !== n.enabled)
                        switch (r) {
                        case i.ROTATE:
                            if (!1 === n.enableRotate)
                                return;
                            !function(t) {
                                d.set(t.clientX, t.clientY),
                                p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
                                const e = n.domElement;
                                M(2 * Math.PI * p.x / e.clientHeight),
                                S(2 * Math.PI * p.y / e.clientHeight),
                                u.copy(d),
                                n.update()
                            }(t);
                            break;
                        case i.DOLLY:
                            if (!1 === n.enableZoom)
                                return;
                            !function(t) {
                                y.set(t.clientX, t.clientY),
                                _.subVectors(y, v),
                                _.y > 0 ? R(w()) : _.y < 0 && L(w()),
                                v.copy(y),
                                n.update()
                            }(t);
                            break;
                        case i.PAN:
                            if (!1 === n.enablePan)
                                return;
                            !function(t) {
                                m.set(t.clientX, t.clientY),
                                g.subVectors(m, f).multiplyScalar(n.panSpeed),
                                A(g.x, g.y),
                                f.copy(m),
                                n.update()
                            }(t)
                        }
                }(t))
            }
            function U(t) {
                !1 !== n.enabled && (t.pointerType,
                n.dispatchEvent(Tg),
                r = i.NONE,
                j(t),
                0 === x.length && (n.domElement.releasePointerCapture(t.pointerId),
                n.domElement.removeEventListener("pointermove", F),
                n.domElement.removeEventListener("pointerup", U)))
            }
            function H(t) {
                j(t)
            }
            function V(t) {
                !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (t.preventDefault(),
                n.dispatchEvent(Sg),
                function(t) {
                    t.deltaY < 0 ? L(w()) : t.deltaY > 0 && R(w()),
                    n.update()
                }(t),
                n.dispatchEvent(Tg))
            }
            function G(t) {
                !1 !== n.enabled && !1 !== n.enablePan && function(t) {
                    let e = !1;
                    switch (t.code) {
                    case n.keys.UP:
                        A(0, n.keyPanSpeed),
                        e = !0;
                        break;
                    case n.keys.BOTTOM:
                        A(0, -n.keyPanSpeed),
                        e = !0;
                        break;
                    case n.keys.LEFT:
                        A(n.keyPanSpeed, 0),
                        e = !0;
                        break;
                    case n.keys.RIGHT:
                        A(-n.keyPanSpeed, 0),
                        e = !0
                    }
                    e && (t.preventDefault(),
                    n.update())
                }(t)
            }
            function W(t) {
                !1 !== n.enabled && t.preventDefault()
            }
            function j(t) {
                delete b[t.pointerId];
                for (let e = 0; e < x.length; e++)
                    if (x[e].pointerId == t.pointerId)
                        return void x.splice(e, 1)
            }
            function X(t) {
                let e = b[t.pointerId];
                void 0 === e && (e = new Ea,
                b[t.pointerId] = e),
                e.set(t.pageX, t.pageY)
            }
            function q(t) {
                const e = t.pointerId === x[0].pointerId ? x[1] : x[0];
                return b[e.pointerId]
            }
            n.domElement.addEventListener("contextmenu", W),
            n.domElement.addEventListener("pointerdown", B),
            n.domElement.addEventListener("pointercancel", H),
            n.domElement.addEventListener("wheel", V, {
                passive: !1
            }),
            this.update()
        }
    }
    (db,mb.domElement),
    _b.target.set(-.1, 2.1, 1.5),
    _b.enableDamping = !0,
    _b.dampingFactor = .08,
    _b.enableRotate = !0,
    _b.screenSpacePanning = !1,
    _b.enablePan = !1,
    _b.enabled = !1,
    _b.enableZoom = !0,
    _b.zoomSpeed = .25,
    _b.autoRotateSpeed = .4,
    _b.enabled = !1,
    gb = new Om(3945763,.019),
    gb.position.set(36, 23, -53),
    fb.add(gb.target),
    fb.add(gb);
    var lw = {
        color: gb.color.getHex(),
        color4: fb.fog.color,
        color3: "#e1f4ff",
        color4: "#d5f7f7"
    };
    const cw = function() {
        var t = new lc(lw.color)
          , e = new lc(lw.color3)
          , n = new lc(lw.color4);
        gb.color.set(t),
        fb.background.set(e),
        fb.fog.color = n
    };
    if (1 == Xb) {
        var hw = {
            reset: function() {
                mb.shadowMap.enabled ? (mb.shadowMap.enabled = !1,
                gb.shadow.map.dispose(),
                materialLambertGreen.needsUpdate = !0,
                materialLambertWhite.needsUpdate = !0,
                mb.shadowMap.autoUpdate = !1) : (mb.shadowMap.enabled = !0,
                materialLambertGreen.needsUpdate = !0,
                materialLambertWhite.needsUpdate = !0,
                mb.shadowMap.autoUpdate = !0)
            },
            setmaxconfig: function() {
                Zb = !Zb
            },
            hideCeiling: function() {
                Mw.visible = !1
            }
        };
        kb.add(gb, "intensity").min(0).max(10).step(1e-4).name("Dir intensity"),
        kb.add(gb.position, "y").min(0).max(100).step(1e-5).name("Dir Y pos"),
        kb.add(gb.position, "x").min(-100).max(100).step(1e-5).name("Dir X pos"),
        kb.add(gb.position, "z").min(-100).max(100).step(1e-5).name("Dir Z pos"),
        kb.addColor(lw, "color").name("Dir color").onChange(cw),
        kb.addColor(lw, "color4").name("Fog Color").onChange(cw),
        kb.add(hw, "hideCeiling").name("Hide Ceiling")
    }
    const uw = new Oh(mb);
    uw.compileEquirectangularShader();
    const dw = new qf(25,25,25)
      , pw = Rb.load("textures/sky7.jpg");
    pw.flipY = !1;
    const fw = new cc({
        map: pw,
        side: 1,
        depthTest: !1
    })
      , mw = new Hc(dw,fw);
    function gw(t) {
        Gb = t
    }
    mw.position.set(0, -5, 0),
    mw.rotation.set(0, 24, 0),
    fb.add(mw),
    (new class extends _m {
        constructor(t) {
            super(t),
            this.type = Xo
        }
        parse(t) {
            const n = 65536
              , i = 14
              , r = 65537
              , s = Math.pow(2.7182818, 2.2);
            var o = new DataView(new ArrayBuffer(8));
            function a(t) {
                if (0 === t)
                    return [t, 0];
                o.setFloat64(0, t);
                var e = o.getUint32(0) >>> 20 & 2047;
                0 === e && (o.setFloat64(0, t * Math.pow(2, 64)),
                e = (o.getUint32(0) >>> 20 & 2047) - 64);
                var n = e - 1022
                  , i = function(t, e) {
                    for (var n = Math.min(3, Math.ceil(Math.abs(e) / 1023)), i = t, r = 0; r < n; r++)
                        i *= Math.pow(2, Math.floor((e + r) / n));
                    return i
                }(t, -n);
                return [i, n]
            }
            const l = {
                l: 0,
                c: 0,
                lc: 0
            };
            function c(t, e, n, i, r) {
                for (; n < t; )
                    e = e << 8 | B(i, r),
                    n += 8;
                n -= t,
                l.l = e >> n & (1 << t) - 1,
                l.c = e,
                l.lc = n
            }
            const h = new Array(59);
            function u(t) {
                return 63 & t
            }
            function d(t) {
                return t >> 6
            }
            const p = {
                c: 0,
                lc: 0
            };
            function f(t, e, n, i) {
                t = t << 8 | B(n, i),
                e += 8,
                p.c = t,
                p.lc = e
            }
            const m = {
                c: 0,
                lc: 0
            };
            function g(t, e, n, i, r, s, o, a, l, c) {
                if (t == e) {
                    i < 8 && (f(n, i, r, o),
                    n = p.c,
                    i = p.lc);
                    var h = n >> (i -= 8);
                    if (h = new Uint8Array([h])[0],
                    l.value + h > c)
                        return !1;
                    for (var u = a[l.value - 1]; h-- > 0; )
                        a[l.value++] = u
                } else {
                    if (!(l.value < c))
                        return !1;
                    a[l.value++] = t
                }
                m.c = n,
                m.lc = i
            }
            function v(t) {
                return 65535 & t
            }
            function y(t) {
                var e = v(t);
                return e > 32767 ? e - 65536 : e
            }
            const _ = {
                a: 0,
                b: 0
            };
            function x(t, e) {
                var n = y(t)
                  , i = y(e)
                  , r = n + (1 & i) + (i >> 1)
                  , s = r
                  , o = r - i;
                _.a = s,
                _.b = o
            }
            function b(t, e) {
                var n = v(t)
                  , i = v(e)
                  , r = n - (i >> 1) & 65535
                  , s = i + r - 32768 & 65535;
                _.a = s,
                _.b = r
            }
            function w(t, e, n, i, r, s, o) {
                for (var a, l = o < 16384, c = n > r ? r : n, h = 1; h <= c; )
                    h <<= 1;
                for (a = h >>= 1,
                h >>= 1; h >= 1; ) {
                    for (var u, d, p, f, m = 0, g = m + s * (r - a), v = s * h, y = s * a, w = i * h, M = i * a; m <= g; m += y) {
                        for (var S = m, T = m + i * (n - a); S <= T; S += M) {
                            var E = S + w
                              , A = (R = S + v) + w;
                            l ? (x(t[S + e], t[R + e]),
                            u = _.a,
                            p = _.b,
                            x(t[E + e], t[A + e]),
                            d = _.a,
                            f = _.b,
                            x(u, d),
                            t[S + e] = _.a,
                            t[E + e] = _.b,
                            x(p, f),
                            t[R + e] = _.a,
                            t[A + e] = _.b) : (b(t[S + e], t[R + e]),
                            u = _.a,
                            p = _.b,
                            b(t[E + e], t[A + e]),
                            d = _.a,
                            f = _.b,
                            b(u, d),
                            t[S + e] = _.a,
                            t[E + e] = _.b,
                            b(p, f),
                            t[R + e] = _.a,
                            t[A + e] = _.b)
                        }
                        if (n & h) {
                            var R = S + v;
                            l ? x(t[S + e], t[R + e]) : b(t[S + e], t[R + e]),
                            u = _.a,
                            t[R + e] = _.b,
                            t[S + e] = u
                        }
                    }
                    if (r & h)
                        for (S = m,
                        T = m + i * (n - a); S <= T; S += M)
                            E = S + w,
                            l ? x(t[S + e], t[E + e]) : b(t[S + e], t[E + e]),
                            u = _.a,
                            t[E + e] = _.b,
                            t[S + e] = u;
                    a = h,
                    h >>= 1
                }
                return m
            }
            function M(t, e, n, s, o, a) {
                var v = n.value
                  , y = z(e, n)
                  , _ = z(e, n);
                n.value += 4;
                var x = z(e, n);
                if (n.value += 4,
                y < 0 || y >= r || _ < 0 || _ >= r)
                    throw "Something wrong with HUF_ENCSIZE";
                var b = new Array(r)
                  , w = new Array(16384);
                if (function(t) {
                    for (var e = 0; e < 16384; e++)
                        t[e] = {},
                        t[e].len = 0,
                        t[e].lit = 0,
                        t[e].p = null
                }(w),
                function(t, e, n, i, s, o, a) {
                    for (var u = n, d = 0, p = 0; s <= o; s++) {
                        if (u.value - n.value > i)
                            return !1;
                        c(6, d, p, t, u);
                        var f = l.l;
                        if (d = l.c,
                        p = l.lc,
                        a[s] = f,
                        63 == f) {
                            if (u.value - n.value > i)
                                throw "Something wrong with hufUnpackEncTable";
                            c(8, d, p, t, u);
                            var m = l.l + 6;
                            if (d = l.c,
                            p = l.lc,
                            s + m > o + 1)
                                throw "Something wrong with hufUnpackEncTable";
                            for (; m--; )
                                a[s++] = 0;
                            s--
                        } else if (f >= 59) {
                            if (s + (m = f - 59 + 2) > o + 1)
                                throw "Something wrong with hufUnpackEncTable";
                            for (; m--; )
                                a[s++] = 0;
                            s--
                        }
                    }
                    !function(t) {
                        for (var e = 0; e <= 58; ++e)
                            h[e] = 0;
                        for (e = 0; e < r; ++e)
                            h[t[e]] += 1;
                        var n = 0;
                        for (e = 58; e > 0; --e) {
                            var i = n + h[e] >> 1;
                            h[e] = n,
                            n = i
                        }
                        for (e = 0; e < r; ++e) {
                            var s = t[e];
                            s > 0 && (t[e] = s | h[s]++ << 6)
                        }
                    }(a)
                }(t, 0, n, s - (n.value - v), y, _, b),
                x > 8 * (s - (n.value - v)))
                    throw "Something wrong with hufUncompress";
                !function(t, e, n, r) {
                    for (; e <= n; e++) {
                        var s = d(t[e])
                          , o = u(t[e]);
                        if (s >> o)
                            throw "Invalid table entry";
                        if (o > i) {
                            if ((h = r[s >> o - i]).len)
                                throw "Invalid table entry";
                            if (h.lit++,
                            h.p) {
                                var a = h.p;
                                h.p = new Array(h.lit);
                                for (var l = 0; l < h.lit - 1; ++l)
                                    h.p[l] = a[l]
                            } else
                                h.p = new Array(1);
                            h.p[h.lit - 1] = e
                        } else if (o) {
                            var c = 0;
                            for (l = 1 << i - o; l > 0; l--) {
                                var h;
                                if ((h = r[(s << i - o) + c]).len || h.p)
                                    throw "Invalid table entry";
                                h.len = o,
                                h.lit = e,
                                c++
                            }
                        }
                    }
                }(b, y, _, w),
                function(t, e, n, r, s, o, a, l, c, h) {
                    for (var v = 0, y = 0, _ = l, x = Math.trunc(s.value + (o + 7) / 8); s.value < x; )
                        for (f(v, y, n, s),
                        v = p.c,
                        y = p.lc; y >= i; )
                            if ((S = e[v >> y - i & 16383]).len)
                                y -= S.len,
                                g(S.lit, a, v, y, n, 0, s, c, h, _),
                                v = m.c,
                                y = m.lc;
                            else {
                                if (!S.p)
                                    throw "hufDecode issues";
                                var b;
                                for (b = 0; b < S.lit; b++) {
                                    for (var w = u(t[S.p[b]]); y < w && s.value < x; )
                                        f(v, y, n, s),
                                        v = p.c,
                                        y = p.lc;
                                    if (y >= w && d(t[S.p[b]]) == (v >> y - w & (1 << w) - 1)) {
                                        y -= w,
                                        g(S.p[b], a, v, y, n, 0, s, c, h, _),
                                        v = m.c,
                                        y = m.lc;
                                        break
                                    }
                                }
                                if (b == S.lit)
                                    throw "hufDecode issues"
                            }
                    var M = 8 - o & 7;
                    for (v >>= M,
                    y -= M; y > 0; ) {
                        var S;
                        if (!(S = e[v << i - y & 16383]).len)
                            throw "hufDecode issues";
                        y -= S.len,
                        g(S.lit, a, v, y, n, 0, s, c, h, _),
                        v = m.c,
                        y = m.lc
                    }
                }(b, w, t, 0, n, x, _, a, o, {
                    value: 0
                })
            }
            function S(t) {
                for (var e = 1; e < t.length; e++) {
                    var n = t[e - 1] + t[e] - 128;
                    t[e] = n
                }
            }
            function T(t, e) {
                for (var n = 0, i = Math.floor((t.length + 1) / 2), r = 0, s = t.length - 1; !(r > s || (e[r++] = t[n++],
                r > s)); )
                    e[r++] = t[i++]
            }
            function E(t) {
                for (var e = t.byteLength, n = new Array, i = 0, r = new DataView(t); e > 0; ) {
                    var s = r.getInt8(i++);
                    if (s < 0) {
                        e -= 1 + (a = -s);
                        for (var o = 0; o < a; o++)
                            n.push(r.getUint8(i++))
                    } else {
                        var a = s;
                        e -= 2;
                        var l = r.getUint8(i++);
                        for (o = 0; o < a + 1; o++)
                            n.push(l)
                    }
                }
                return n
            }
            function A(t, e, n) {
                for (var i, r = 1; r < 64; )
                    65280 == (i = e[t.value]) ? r = 64 : i >> 8 == 255 ? r += 255 & i : (n[r] = i,
                    r++),
                    t.value++
            }
            function R(t, e) {
                e[0] = V(t[0]),
                e[1] = V(t[1]),
                e[2] = V(t[5]),
                e[3] = V(t[6]),
                e[4] = V(t[14]),
                e[5] = V(t[15]),
                e[6] = V(t[27]),
                e[7] = V(t[28]),
                e[8] = V(t[2]),
                e[9] = V(t[4]),
                e[10] = V(t[7]),
                e[11] = V(t[13]),
                e[12] = V(t[16]),
                e[13] = V(t[26]),
                e[14] = V(t[29]),
                e[15] = V(t[42]),
                e[16] = V(t[3]),
                e[17] = V(t[8]),
                e[18] = V(t[12]),
                e[19] = V(t[17]),
                e[20] = V(t[25]),
                e[21] = V(t[30]),
                e[22] = V(t[41]),
                e[23] = V(t[43]),
                e[24] = V(t[9]),
                e[25] = V(t[11]),
                e[26] = V(t[18]),
                e[27] = V(t[24]),
                e[28] = V(t[31]),
                e[29] = V(t[40]),
                e[30] = V(t[44]),
                e[31] = V(t[53]),
                e[32] = V(t[10]),
                e[33] = V(t[19]),
                e[34] = V(t[23]),
                e[35] = V(t[32]),
                e[36] = V(t[39]),
                e[37] = V(t[45]),
                e[38] = V(t[52]),
                e[39] = V(t[54]),
                e[40] = V(t[20]),
                e[41] = V(t[22]),
                e[42] = V(t[33]),
                e[43] = V(t[38]),
                e[44] = V(t[46]),
                e[45] = V(t[51]),
                e[46] = V(t[55]),
                e[47] = V(t[60]),
                e[48] = V(t[21]),
                e[49] = V(t[34]),
                e[50] = V(t[37]),
                e[51] = V(t[47]),
                e[52] = V(t[50]),
                e[53] = V(t[56]),
                e[54] = V(t[59]),
                e[55] = V(t[61]),
                e[56] = V(t[35]),
                e[57] = V(t[36]),
                e[58] = V(t[48]),
                e[59] = V(t[49]),
                e[60] = V(t[57]),
                e[61] = V(t[58]),
                e[62] = V(t[62]),
                e[63] = V(t[63])
            }
            function L(t) {
                const e = .5 * Math.cos(.7853975)
                  , n = .5 * Math.cos(3.14159 / 16)
                  , i = .5 * Math.cos(3.14159 / 8)
                  , r = .5 * Math.cos(3 * 3.14159 / 16)
                  , s = .5 * Math.cos(.981746875)
                  , o = .5 * Math.cos(3 * 3.14159 / 8)
                  , a = .5 * Math.cos(1.374445625);
                for (var l = new Array(4), c = new Array(4), h = new Array(4), u = new Array(4), d = 0; d < 8; ++d) {
                    var p = 8 * d;
                    l[0] = i * t[p + 2],
                    l[1] = o * t[p + 2],
                    l[2] = i * t[p + 6],
                    l[3] = o * t[p + 6],
                    c[0] = n * t[p + 1] + r * t[p + 3] + s * t[p + 5] + a * t[p + 7],
                    c[1] = r * t[p + 1] - a * t[p + 3] - n * t[p + 5] - s * t[p + 7],
                    c[2] = s * t[p + 1] - n * t[p + 3] + a * t[p + 5] + r * t[p + 7],
                    c[3] = a * t[p + 1] - s * t[p + 3] + r * t[p + 5] - n * t[p + 7],
                    h[0] = e * (t[p + 0] + t[p + 4]),
                    h[3] = e * (t[p + 0] - t[p + 4]),
                    h[1] = l[0] + l[3],
                    h[2] = l[1] - l[2],
                    u[0] = h[0] + h[1],
                    u[1] = h[3] + h[2],
                    u[2] = h[3] - h[2],
                    u[3] = h[0] - h[1],
                    t[p + 0] = u[0] + c[0],
                    t[p + 1] = u[1] + c[1],
                    t[p + 2] = u[2] + c[2],
                    t[p + 3] = u[3] + c[3],
                    t[p + 4] = u[3] - c[3],
                    t[p + 5] = u[2] - c[2],
                    t[p + 6] = u[1] - c[1],
                    t[p + 7] = u[0] - c[0]
                }
                for (var f = 0; f < 8; ++f)
                    l[0] = i * t[16 + f],
                    l[1] = o * t[16 + f],
                    l[2] = i * t[48 + f],
                    l[3] = o * t[48 + f],
                    c[0] = n * t[8 + f] + r * t[24 + f] + s * t[40 + f] + a * t[56 + f],
                    c[1] = r * t[8 + f] - a * t[24 + f] - n * t[40 + f] - s * t[56 + f],
                    c[2] = s * t[8 + f] - n * t[24 + f] + a * t[40 + f] + r * t[56 + f],
                    c[3] = a * t[8 + f] - s * t[24 + f] + r * t[40 + f] - n * t[56 + f],
                    h[0] = e * (t[f] + t[32 + f]),
                    h[3] = e * (t[f] - t[32 + f]),
                    h[1] = l[0] + l[3],
                    h[2] = l[1] - l[2],
                    u[0] = h[0] + h[1],
                    u[1] = h[3] + h[2],
                    u[2] = h[3] - h[2],
                    u[3] = h[0] - h[1],
                    t[0 + f] = u[0] + c[0],
                    t[8 + f] = u[1] + c[1],
                    t[16 + f] = u[2] + c[2],
                    t[24 + f] = u[3] + c[3],
                    t[32 + f] = u[3] - c[3],
                    t[40 + f] = u[2] - c[2],
                    t[48 + f] = u[1] - c[1],
                    t[56 + f] = u[0] - c[0]
            }
            function C(t) {
                for (var e = 0; e < 64; ++e) {
                    var n = t[0][e]
                      , i = t[1][e]
                      , r = t[2][e];
                    t[0][e] = n + 1.5747 * r,
                    t[1][e] = n - .1873 * i - .4682 * r,
                    t[2][e] = n + 1.8556 * i
                }
            }
            function P(t, e, n) {
                for (var i = 0; i < 64; ++i)
                    e[n + i] = wg.toHalfFloat((r = t[i]) <= 1 ? Math.sign(r) * Math.pow(Math.abs(r), 2.2) : Math.sign(r) * Math.pow(s, Math.abs(r) - 1));
                var r
            }
            function D(t) {
                var n = t.array.slice(t.offset.value, t.offset.value + t.size);
                void 0 === e && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                var i = px(n)
                  , r = new Uint8Array(i.length);
                return S(i),
                T(i, r),
                new DataView(r.buffer)
            }
            function I(t) {
                var e = t.viewer
                  , n = {
                    value: t.offset.value
                }
                  , i = new Uint8Array(t.width * t.lines * (q.channels.length * t.type * 2))
                  , r = {
                    version: U(e, n),
                    unknownUncompressedSize: U(e, n),
                    unknownCompressedSize: U(e, n),
                    acCompressedSize: U(e, n),
                    dcCompressedSize: U(e, n),
                    rleCompressedSize: U(e, n),
                    rleUncompressedSize: U(e, n),
                    rleRawSize: U(e, n),
                    totalAcUncompressedCount: U(e, n),
                    totalDcUncompressedCount: U(e, n),
                    acCompression: U(e, n)
                };
                if (r.version < 2)
                    throw "EXRLoader.parse: " + q.compression + " version " + r.version + " is unsupported";
                for (var s = new Array, o = G(e, n) - 2; o > 0; ) {
                    var a = O(e.buffer, n)
                      , l = F(e, n)
                      , c = l >> 2 & 3
                      , h = new Int8Array([(l >> 4) - 1])[0]
                      , u = F(e, n);
                    s.push({
                        name: a,
                        index: h,
                        type: u,
                        compression: c
                    }),
                    o -= a.length + 3
                }
                for (var d = q.channels, p = new Array(t.channels), f = 0; f < t.channels; ++f) {
                    var m = p[f] = {}
                      , g = d[f];
                    m.name = g.name,
                    m.compression = 0,
                    m.decoded = !1,
                    m.type = g.pixelType,
                    m.pLinear = g.pLinear,
                    m.width = t.width,
                    m.height = t.lines
                }
                for (var v = {
                    idx: new Array(3)
                }, y = 0; y < t.channels; ++y)
                    for (m = p[y],
                    f = 0; f < s.length; ++f) {
                        var _ = s[f];
                        m.name == _.name && (m.compression = _.compression,
                        _.index >= 0 && (v.idx[_.index] = y),
                        m.offset = y)
                    }
                if (r.acCompressedSize > 0)
                    switch (r.acCompression) {
                    case 0:
                        var x = new Uint16Array(r.totalAcUncompressedCount);
                        M(t.array, e, n, r.acCompressedSize, x, r.totalAcUncompressedCount);
                        break;
                    case 1:
                        var b = px(t.array.slice(n.value, n.value + r.totalAcUncompressedCount));
                        x = new Uint16Array(b.buffer),
                        n.value += r.totalAcUncompressedCount
                    }
                if (r.dcCompressedSize > 0) {
                    var w = {
                        array: t.array,
                        offset: n,
                        size: r.dcCompressedSize
                    }
                      , S = new Uint16Array(D(w).buffer);
                    n.value += r.dcCompressedSize
                }
                if (r.rleRawSize > 0) {
                    var T = E((b = px(t.array.slice(n.value, n.value + r.rleCompressedSize))).buffer);
                    n.value += r.rleCompressedSize
                }
                var I = 0
                  , k = new Array(p.length);
                for (f = 0; f < k.length; ++f)
                    k[f] = new Array;
                for (var N = 0; N < t.lines; ++N)
                    for (var z = 0; z < p.length; ++z)
                        k[z].push(I),
                        I += p[z].width * t.type * 2;
                for (function(t, e, n, i, r, s) {
                    var o = new DataView(s.buffer)
                      , a = n[t.idx[0]].width
                      , l = n[t.idx[0]].height
                      , c = Math.floor(a / 8)
                      , h = Math.ceil(a / 8)
                      , u = Math.ceil(l / 8)
                      , d = a - 8 * (h - 1)
                      , p = l - 8 * (u - 1)
                      , f = {
                        value: 0
                    }
                      , m = new Array(3)
                      , g = new Array(3)
                      , v = new Array(3)
                      , y = new Array(3)
                      , _ = new Array(3);
                    for (let n = 0; n < 3; ++n)
                        _[n] = e[t.idx[n]],
                        m[n] = n < 1 ? 0 : m[n - 1] + h * u,
                        g[n] = new Float32Array(64),
                        v[n] = new Uint16Array(64),
                        y[n] = new Uint16Array(64 * h);
                    for (let e = 0; e < u; ++e) {
                        var x = 8;
                        e == u - 1 && (x = p);
                        var b = 8;
                        for (let t = 0; t < h; ++t) {
                            t == h - 1 && (b = d);
                            for (let t = 0; t < 3; ++t)
                                v[t].fill(0),
                                v[t][0] = r[m[t]++],
                                A(f, i, v[t]),
                                R(v[t], g[t]),
                                L(g[t]);
                            C(g);
                            for (let e = 0; e < 3; ++e)
                                P(g[e], y[e], 64 * t)
                        }
                        let s = 0;
                        for (let i = 0; i < 3; ++i) {
                            const r = n[t.idx[i]].type;
                            for (let t = 8 * e; t < 8 * e + x; ++t) {
                                s = _[i][t];
                                for (let e = 0; e < c; ++e) {
                                    const n = 64 * e + 8 * (7 & t);
                                    o.setUint16(s + 0 * r, y[i][n + 0], !0),
                                    o.setUint16(s + 2 * r, y[i][n + 1], !0),
                                    o.setUint16(s + 4 * r, y[i][n + 2], !0),
                                    o.setUint16(s + 6 * r, y[i][n + 3], !0),
                                    o.setUint16(s + 8 * r, y[i][n + 4], !0),
                                    o.setUint16(s + 10 * r, y[i][n + 5], !0),
                                    o.setUint16(s + 12 * r, y[i][n + 6], !0),
                                    o.setUint16(s + 14 * r, y[i][n + 7], !0),
                                    s += 16 * r
                                }
                            }
                            if (c != h)
                                for (let t = 8 * e; t < 8 * e + x; ++t) {
                                    const e = _[i][t] + 8 * c * 2 * r
                                      , n = 64 * c + 8 * (7 & t);
                                    for (let t = 0; t < b; ++t)
                                        o.setUint16(e + 2 * t * r, y[i][n + t], !0)
                                }
                        }
                    }
                    for (var w = new Uint16Array(a), M = (o = new DataView(s.buffer),
                    0); M < 3; ++M) {
                        n[t.idx[M]].decoded = !0;
                        var S = n[t.idx[M]].type;
                        if (2 == n[M].type)
                            for (var T = 0; T < l; ++T) {
                                const t = _[M][T];
                                for (var E = 0; E < a; ++E)
                                    w[E] = o.getUint16(t + 2 * E * S, !0);
                                for (E = 0; E < a; ++E)
                                    o.setFloat32(t + 2 * E * S, V(w[E]), !0)
                            }
                    }
                }(v, k, p, x, S, i),
                f = 0; f < p.length; ++f)
                    if (!(m = p[f]).decoded) {
                        if (2 !== m.compression)
                            throw "EXRLoader.parse: unsupported channel compression";
                        var B = 0
                          , H = 0;
                        for (N = 0; N < t.lines; ++N) {
                            for (var W = k[f][B], j = 0; j < m.width; ++j) {
                                for (var X = 0; X < 2 * m.type; ++X)
                                    i[W++] = T[H + X * m.width * m.height];
                                H++
                            }
                            B++
                        }
                    }
                return new DataView(i.buffer)
            }
            function O(t, e) {
                for (var n = new Uint8Array(t), i = 0; 0 != n[e.value + i]; )
                    i += 1;
                var r = (new TextDecoder).decode(n.slice(e.value, e.value + i));
                return e.value = e.value + i + 1,
                r
            }
            function k(t, e) {
                var n = t.getUint32(0, !0);
                return e.value = e.value + 8,
                n
            }
            function N(t, e) {
                var n = t.getInt32(e.value, !0);
                return e.value = e.value + 4,
                n
            }
            function z(t, e) {
                var n = t.getUint32(e.value, !0);
                return e.value = e.value + 4,
                n
            }
            function B(t, e) {
                var n = t[e.value];
                return e.value = e.value + 1,
                n
            }
            function F(t, e) {
                var n = t.getUint8(e.value);
                return e.value = e.value + 1,
                n
            }
            function U(t, e) {
                var n = Number(t.getBigInt64(e.value, !0));
                return e.value += 8,
                n
            }
            function H(t, e) {
                var n = t.getFloat32(e.value, !0);
                return e.value += 4,
                n
            }
            function V(t) {
                var e = (31744 & t) >> 10
                  , n = 1023 & t;
                return (t >> 15 ? -1 : 1) * (e ? 31 === e ? n ? NaN : 1 / 0 : Math.pow(2, e - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
            }
            function G(t, e) {
                var n = t.getUint16(e.value, !0);
                return e.value += 2,
                n
            }
            function W(t, e, n, i, r) {
                return "string" === i || "stringvector" === i || "iccProfile" === i ? function(t, e, n) {
                    var i = (new TextDecoder).decode(new Uint8Array(t).slice(e.value, e.value + n));
                    return e.value = e.value + n,
                    i
                }(e, n, r) : "chlist" === i ? function(t, e, n, i) {
                    for (var r = n.value, s = []; n.value < r + i - 1; ) {
                        var o = O(e, n)
                          , a = N(t, n)
                          , l = F(t, n);
                        n.value += 3;
                        var c = N(t, n)
                          , h = N(t, n);
                        s.push({
                            name: o,
                            pixelType: a,
                            pLinear: l,
                            xSampling: c,
                            ySampling: h
                        })
                    }
                    return n.value += 1,
                    s
                }(t, e, n, r) : "chromaticities" === i ? function(t, e) {
                    return {
                        redX: H(t, e),
                        redY: H(t, e),
                        greenX: H(t, e),
                        greenY: H(t, e),
                        blueX: H(t, e),
                        blueY: H(t, e),
                        whiteX: H(t, e),
                        whiteY: H(t, e)
                    }
                }(t, n) : "compression" === i ? function(t, e) {
                    return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][F(t, e)]
                }(t, n) : "box2i" === i ? function(t, e) {
                    return {
                        xMin: z(t, e),
                        yMin: z(t, e),
                        xMax: z(t, e),
                        yMax: z(t, e)
                    }
                }(t, n) : "lineOrder" === i ? function(t, e) {
                    return ["INCREASING_Y"][F(t, e)]
                }(t, n) : "float" === i ? H(t, n) : "v2f" === i ? function(t, e) {
                    return [H(t, e), H(t, e)]
                }(t, n) : "v3f" === i ? function(t, e) {
                    return [H(t, e), H(t, e), H(t, e)]
                }(t, n) : "int" === i ? N(t, n) : "rational" === i ? function(t, e) {
                    return [N(t, e), z(t, e)]
                }(t, n) : "timecode" === i ? function(t, e) {
                    return [z(t, e), z(t, e)]
                }(t, n) : "preview" === i ? (n.value += r,
                "skipped") : void (n.value += r)
            }
            var j = new DataView(t)
              , X = new Uint8Array(t)
              , q = {};
            j.getUint32(0, !0),
            j.getUint8(4, !0),
            j.getUint8(5, !0);
            for (var Y = {
                value: 8
            }, Z = !0; Z; ) {
                var J = O(t, Y);
                if (0 == J)
                    Z = !1;
                else {
                    var K = O(t, Y)
                      , Q = W(j, t, Y, K, z(j, Y));
                    void 0 === Q ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${K}'.`) : q[J] = Q
                }
            }
            var $, tt, et, nt, it = q.dataWindow.yMax + 1;
            switch (q.compression) {
            case "NO_COMPRESSION":
                tt = 1,
                $ = function(t) {
                    return new DataView(t.array.buffer,t.offset.value,t.size)
                }
                ;
                break;
            case "RLE_COMPRESSION":
                tt = 1,
                $ = function(t) {
                    var e = t.viewer.buffer.slice(t.offset.value, t.offset.value + t.size)
                      , n = new Uint8Array(E(e))
                      , i = new Uint8Array(n.length);
                    return S(n),
                    T(n, i),
                    new DataView(i.buffer)
                }
                ;
                break;
            case "ZIPS_COMPRESSION":
                tt = 1,
                $ = D;
                break;
            case "ZIP_COMPRESSION":
                tt = 16,
                $ = D;
                break;
            case "PIZ_COMPRESSION":
                tt = 32,
                $ = function(t) {
                    for (var e = t.viewer, i = {
                        value: t.offset.value
                    }, r = t.width * tt * (q.channels.length * t.type), s = new Uint16Array(r), o = new Uint8Array(8192), a = 0, l = new Array(t.channels), c = 0; c < t.channels; c++)
                        l[c] = {},
                        l[c].start = a,
                        l[c].end = l[c].start,
                        l[c].nx = t.width,
                        l[c].ny = t.lines,
                        l[c].size = t.type,
                        a += l[c].nx * l[c].ny * l[c].size;
                    var h = G(e, i)
                      , u = G(e, i);
                    if (u >= 8192)
                        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
                    if (h <= u)
                        for (c = 0; c < u - h + 1; c++)
                            o[c + h] = F(e, i);
                    var d = new Uint16Array(n)
                      , p = function(t, e) {
                        for (var i = 0, r = 0; r < n; ++r)
                            (0 == r || t[r >> 3] & 1 << (7 & r)) && (e[i++] = r);
                        for (var s = i - 1; i < n; )
                            e[i++] = 0;
                        return s
                    }(o, d)
                      , f = z(e, i);
                    for (M(t.array, e, i, f, s, a),
                    c = 0; c < t.channels; ++c)
                        for (var m = l[c], g = 0; g < l[c].size; ++g)
                            w(s, m.start + g, m.nx, m.size, m.ny, m.nx * m.size, p);
                    !function(t, e, n) {
                        for (var i = 0; i < n; ++i)
                            e[i] = t[e[i]]
                    }(d, s, a);
                    for (var v = 0, y = new Uint8Array(s.buffer.byteLength), _ = 0; _ < t.lines; _++)
                        for (var x = 0; x < t.channels; x++) {
                            var b = (m = l[x]).nx * m.size
                              , S = new Uint8Array(s.buffer,2 * m.end,2 * b);
                            y.set(S, v),
                            v += 2 * b,
                            m.end += b
                        }
                    return new DataView(y.buffer)
                }
                ;
                break;
            case "PXR24_COMPRESSION":
                tt = 16,
                $ = function(t) {
                    var n = t.array.slice(t.offset.value, t.offset.value + t.size);
                    void 0 === e && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                    var i = px(n);
                    const r = t.lines * t.channels * t.width
                      , s = 1 == t.type ? new Uint16Array(r) : new Uint32Array(r);
                    let o = 0
                      , a = 0;
                    const l = new Array(4);
                    for (let e = 0; e < t.lines; e++)
                        for (let e = 0; e < t.channels; e++) {
                            let e = 0;
                            switch (t.type) {
                            case 1:
                                l[0] = o,
                                l[1] = l[0] + t.width,
                                o = l[1] + t.width;
                                for (let n = 0; n < t.width; ++n)
                                    e += i[l[0]++] << 8 | i[l[1]++],
                                    s[a] = e,
                                    a++;
                                break;
                            case 2:
                                l[0] = o,
                                l[1] = l[0] + t.width,
                                l[2] = l[1] + t.width,
                                o = l[2] + t.width;
                                for (let n = 0; n < t.width; ++n)
                                    e += i[l[0]++] << 24 | i[l[1]++] << 16 | i[l[2]++] << 8,
                                    s[a] = e,
                                    a++
                            }
                        }
                    return new DataView(s.buffer)
                }
                ;
                break;
            case "DWAA_COMPRESSION":
                tt = 32,
                $ = I;
                break;
            case "DWAB_COMPRESSION":
                tt = 256,
                $ = I;
                break;
            default:
                throw "EXRLoader.parse: " + q.compression + " is unsupported"
            }
            var rt = q.channels[0].pixelType;
            if (1 === rt)
                switch (this.type) {
                case Vo:
                case jo:
                    nt = function(t, e) {
                        return V(G(t, e))
                    }
                    ,
                    et = 2;
                    break;
                case Xo:
                    nt = G,
                    et = 2
                }
            else {
                if (2 !== rt)
                    throw "EXRLoader.parse: unsupported pixelType " + rt + " for " + q.compression + ".";
                switch (this.type) {
                case Vo:
                case jo:
                    nt = H,
                    et = 4;
                    break;
                case Xo:
                    nt = function(t, e) {
                        return wg.toHalfFloat(H(t, e))
                    }
                    ,
                    et = 4
                }
            }
            for (var st = it / tt, ot = 0; ot < st; ot++)
                k(j, Y);
            var at = q.dataWindow.xMax - q.dataWindow.xMin + 1
              , lt = q.dataWindow.yMax - q.dataWindow.yMin + 1
              , ct = at * lt * 4;
            switch (this.type) {
            case Vo:
            case jo:
                var ht = new Float32Array(ct);
                q.channels.length < 4 && ht.fill(1, 0, ct);
                break;
            case Xo:
                ht = new Uint16Array(ct),
                q.channels.length < 4 && ht.fill(15360, 0, ct);
                break;
            default:
                console.error("THREE.EXRLoader: unsupported type: ", this.type)
            }
            for (var ut, dt, pt = {
                R: 0,
                G: 1,
                B: 2,
                A: 3
            }, ft = {
                size: 0,
                width: at,
                lines: tt,
                offset: Y,
                array: X,
                viewer: j,
                type: rt,
                channels: q.channels.length
            }, mt = {
                value: 0
            }, gt = 0; gt < lt / tt; gt++) {
                ut = z(j, Y),
                ct = z(j, Y),
                ft.lines = ut + tt > lt ? lt - ut : tt,
                ft.offset = Y,
                ft.size = ct,
                dt = $(ft),
                Y.value += ct;
                for (var vt = 0; vt < tt; vt++) {
                    var yt = vt + gt * tt;
                    if (yt >= lt)
                        break;
                    for (var _t = 0; _t < q.channels.length; _t++)
                        for (var xt = pt[q.channels[_t].name], bt = 0; bt < at; bt++) {
                            var wt = vt * (q.channels.length * at) + _t * at + bt;
                            mt.value = wt * et;
                            var Mt = nt(dt, mt);
                            ht[4 * at * (lt - 1 - yt) + 4 * bt + xt] = Mt
                        }
                }
            }
            if (this.type === Vo) {
                let t, e;
                const n = ht.length
                  , i = new Uint8Array(n);
                for (let n = 0; n < lt; ++n)
                    for (let r = 0; r < at; ++r) {
                        e = n * at * 4 + 4 * r;
                        const s = ht[e]
                          , o = ht[e + 1]
                          , l = ht[e + 2];
                        if (t = s > o ? s : o,
                        t = l > t ? l : t,
                        t < 1e-32)
                            i[e] = i[e + 1] = i[e + 2] = i[e + 3] = 0;
                        else {
                            const n = a(t);
                            t = 256 * n[0] / t,
                            i[e] = s * t,
                            i[e + 1] = o * t,
                            i[e + 2] = l * t,
                            i[e + 3] = n[1] + 128
                        }
                    }
                ht = i
            }
            const St = this.type === Vo ? 1023 : Zo;
            return {
                header: q,
                width: at,
                height: lt,
                data: ht,
                format: St,
                type: this.type
            }
        }
        setDataType(t) {
            return this.type = t,
            this
        }
        load(t, e, n, i) {
            return super.load(t, (function(t, n) {
                switch (t.type) {
                case Vo:
                    t.encoding = aa,
                    t.minFilter = zo,
                    t.magFilter = zo,
                    t.generateMipmaps = !1,
                    t.flipY = !1;
                    break;
                case jo:
                case Xo:
                    t.encoding = ra,
                    t.minFilter = Uo,
                    t.magFilter = Uo,
                    t.generateMipmaps = !1,
                    t.flipY = !1
                }
                e && e(t, n)
            }
            ), n, i)
        }
    }
    ).setDataType(Vo).load("textures/spruit_sunrise_1K.exr", (function(t) {
        cb = uw.fromEquirectangular(t),
        hb = cb.texture,
        ub = cb ? cb.texture : null,
        fb.environment = ub,
        t.dispose()
    }
    )),
    ib.addEventListener("click", (function() {
        jb.scrollTo("#section-intro")
    }
    )),
    document.getElementById("interior-view").addEventListener("click", (function() {
        zw(),
        Xi.to(_b.target, {
            x: -.7,
            y: 2.1,
            z: -7.3,
            duration: 2,
            ease: "power3.inOut"
        }),
        Xi.to(db.position, {
            x: -9.4,
            y: 11.2,
            z: -12.9,
            duration: 2,
            ease: "power3.inOut",
            onComplete: Bw
        }, "-=2"),
        Cw = !0,
        Pw = !1,
        Dw = !1,
        Xi.to(Mw.position, {
            y: 15,
            duration: 2,
            ease: "power3.inOut"
        }),
        _b.enableRotate = !0,
        _b.enableZoom = !1
    }
    )),
    document.getElementById("facade-view").addEventListener("click", (function() {
        zw(),
        Xi.to(_b.target, {
            x: -1.4,
            y: 1.8,
            z: 1,
            duration: 2,
            ease: "power3.inOut"
        }),
        Xi.to(db.position, {
            x: -4.1,
            y: 1.5,
            z: 9,
            duration: 2,
            ease: "power3.inOut",
            onComplete: Bw
        }, "-=2"),
        Cw = !1,
        Xi.to(Mw.position, {
            y: 0,
            duration: 2,
            ease: "power3.inOut"
        }),
        Pw = !1,
        Dw = !1,
        _b.enableRotate = !0,
        _b.enableZoom = !0
    }
    )),
    document.getElementById("garden-view").addEventListener("click", (function() {
        zw(),
        Xi.to(_b.target, {
            x: 1.6,
            y: 2.1,
            z: -9,
            duration: 2,
            ease: "power3.inOut"
        }),
        Xi.to(db.position, {
            x: 6.4,
            y: 5.7,
            z: -17,
            duration: 2,
            ease: "power3.inOut",
            onComplete: Bw
        }, "-=2"),
        Cw = !1,
        Xi.to(Mw.position, {
            y: 0,
            duration: 3,
            ease: "power3.inOut"
        }),
        Pw = !1,
        Dw = !0,
        _b.enableRotate = !0,
        _b.enableZoom = !1
    }
    )),
    document.getElementById("floor-view").addEventListener("click", (function() {
        zw(),
        Xi.to(_b.target, {
            x: .6,
            y: 1.9,
            z: -4,
            duration: 2,
            ease: "power3.inOut"
        }),
        Xi.to(db.position, {
            x: 0,
            y: 17,
            z: -4,
            duration: 2,
            ease: "power3.inOut",
            onComplete: Iw
        }, "-=2"),
        Cw = !1,
        Xi.to(Mw.position, {
            y: 15,
            duration: 2,
            ease: "power3.inOut"
        }),
        Dw = !1,
        _b.enableRotate = !0,
        _b.enableZoom = !0
    }
    )),
    Xi.to("#img-intro", {
        scrollTrigger: {
            trigger: "#section-intro",
            start: "top bottom",
            end: "bottom center",
            scroller: ".scrollContainer",
            scrub: !0
        },
        x: "-20%",
        opacity: 1,
        duration: 1
    }),
    Xi.to("#parallax", {
        scrollTrigger: {
            trigger: "#section-concept",
            start: "top center",
            scrub: !0,
            scroller: ".scrollContainer"
        },
        y: (t,e)=>-ws.maxScroll(window) * e.dataset.speed,
        ease: "none"
    }),
    Xi.to("#parallax-img", {
        scrollTrigger: {
            trigger: "#section-concept",
            start: "top bottom",
            scrub: !0,
            scroller: ".scrollContainer"
        },
        y: (t,e)=>-ws.maxScroll(window) * e.dataset.speed,
        ease: "none"
    }),
    Xi.to("#parallax-laguna", {
        scrollTrigger: {
            trigger: "#section-transition",
            scrub: !0,
            scroller: ".scrollContainer"
        },
        backgroundPositionX: (t,e)=>ws.maxScroll(window) * e.dataset.speed,
        ease: "none"
    });
    const vw = ()=>{
        Xi.timeline({
            default: {
                ease: "none"
            },
            scrollTrigger: {
                trigger: "#section-logo",
                start: "top top",
                end: "bottom 5%",
                scrub: !0,
                scroller: ".scrollContainer",
                onLeave: ()=>gw(!1),
                onEnterBack: ()=>gw(!0)
            }
        }).to(db.position, {
            x: 7.4,
            y: 1.3,
            z: 9.6,
            duration: 2.5
        }).to(_b.target, {
            x: -.21,
            y: 1.6,
            z: -.51,
            duration: 2.5
        }, "-=2.5")
    }
      , yw = new cc({
        color: 7899035,
        transparent: !0,
        side: 2
    })
      , _w = new ch(nw,iw,1,1)
      , xw = new Hc(_w,yw);
    xw.position.set(_b.target.x + 7, _b.target.y, 0),
    xw.rotation.set(0, -Math.PI / 2, 0),
    0 == Xb && fb.add(xw);
    const bw = Rb.load("textures/wallTexture2.jpg");
    let ww, Mw, Sw;
    bw.flipY = !0,
    bw.wrapS = Oo,
    bw.wrapT = Oo,
    bw.repeat.set(80, 80),
    Lb.load("static/models/gltf/houses15.glb", (function(t) {
        t.scene.traverse((e=>{
            if (ww = t.scene,
            e.isMesh && ("Laje" == e.name && (Mw = e),
            "AB1_OBJ_06" == e.name && ew.push(e),
            "AB1_OBJ_12" == e.name && ew.push(e),
            "piso_externo" == e.name && !Fb)) {
                Sw = e;
                const t = e.material.map;
                Sw.material = new eb(mb,db,fb,Sw,{
                    resolution: 2048,
                    blur: [2048, 512],
                    mixStrength: 133,
                    planeNormal: new Ua(0,1,0),
                    depthToBlurRatioBias: .5,
                    mixBlur: 5.8,
                    mixContrast: 1.34,
                    minDepthThreshold: .68,
                    maxDepthThreshold: 1.684,
                    depthScale: 4.1,
                    mirror: 0
                }),
                Sw.material.setValues({
                    roughnessMap: bw,
                    map: t,
                    normalScale: new Ea(.3,.5),
                    normalMap: bw,
                    emissiveMap: t,
                    emissive: new lc(16777215),
                    emissiveIntensity: 1.5,
                    envMapIntensity: .08,
                    roughness: .27,
                    color: 16777215
                }),
                function() {
                    if (Xb) {
                        const t = kb.addFolder("Reflector");
                        t.add(Sw.material, "roughness").min(0).max(2).step(.001),
                        t.add(Sw.material, "envMapIntensity").min(0).max(2).step(.001),
                        t.add(Sw.material, "emissiveIntensity").min(0).max(2).step(.001),
                        t.add(Sw.material, "metalness").min(0).max(2).step(.001),
                        t.add(Sw.material.reflectorProps, "mixBlur").min(0).max(7).step(.001),
                        t.add(Sw.material.reflectorProps, "mixStrength").min(0).max(200).step(.001),
                        t.add(Sw.material.reflectorProps, "depthScale").min(0).max(20).step(.1),
                        t.add(Sw.material.reflectorProps, "mixContrast").min(0).max(7).step(.001),
                        t.add(Sw.material.reflectorProps, "minDepthThreshold").min(0).max(7).step(.001),
                        t.add(Sw.material.reflectorProps, "depthToBlurRatioBias").min(0).max(7).step(.001),
                        t.add(Sw.material.reflectorProps, "maxDepthThreshold").min(-5).max(7).step(.001).onChange((function() {
                            Sw.material.needsUpdate = !0
                        }
                        ))
                    }
                }()
            }
        }
        )),
        fb.add(ww)
    }
    )),
    document.addEventListener("mousemove", (function(t) {
        t.preventDefault(),
        zb.x = t.clientX / window.innerWidth * 2 - 1,
        zb.y = -t.clientY / window.innerHeight * 2 + 1,
        Lw.x = t.clientX / window.innerWidth - .5,
        Lw.y = t.clientY / window.innerHeight - .5,
        bb = t.clientX - window.innerWidth / 2,
        wb = t.clientY - window.innerHeight / 2
    }
    ), !1),
    document.addEventListener("mousedown", (function() {}
    )),
    document.addEventListener("mouseup", (function() {}
    )),
    window.addEventListener("blur", sw),
    window.addEventListener("focus", ow),
    window.addEventListener("resize", (function() {
        nw = Jb.clientWidth,
        iw = Jb.clientHeight,
        db.aspect = nw / iw,
        db.updateProjectionMatrix(),
        mb.setSize(nw, iw),
        Fb || mb.setPixelRatio(Math.min(window.devicePixelRatio, 1)),
        "visible" != sb.style.visibility && ob.style.opacity >= 1 && !Fb && Tw.uniforms.uPadding.value.set(window.innerHeight / 7.5, 40, 20, window.innerWidth / 2.5)
    }
    )),
    rb.addEventListener("click", tw),
    sb.addEventListener("click", (function() {
        document.getElementById("body").style.overflow = "auto",
        document.getElementById("canvas-container").style.pointerEvents = "none",
        document.getElementById("div-points").style.visibility = "hidden",
        document.querySelector(".sectionContainer").style.display = "flex",
        document.querySelector(".footerContainer").style.display = "flex",
        document.getElementById("btn-continue-explore").style.display = "visible",
        _b.enabled = !1,
        _b.enableRotate = !1,
        _b.autoRotate = !1,
        _b.enablePan = !1,
        sb.style.visibility = "hidden",
        sb.style.display = "none",
        sb.style.opacity = 0,
        Eb.pause(),
        Ub = !1,
        Fw.to(_b.target, {
            x: -2.4,
            y: 1.8,
            z: 1,
            duration: 2,
            ease: "power3.inOut"
        }).to(db.position, {
            x: -4.1,
            y: 1.5,
            z: 9,
            duration: 2,
            ease: "power3.inOut"
        }, "-=2").to(Tw.uniforms.uPadding.value, {
            x: iw / 7.5,
            y: 40,
            z: 20,
            w: nw / 2.5,
            duration: 2.5,
            ease: "Elastic.easeInOut"
        }, "-=2").to(Tw.uniforms.iRadius, {
            value: "10.0",
            duration: .5,
            ease: "power3.inOut"
        }, "-=2").to("#section-logo h1", {
            y: 0,
            skewY: 0,
            autoAlpha: 1,
            duration: .5
        }, "-=1.5").to("#section-logo p", {
            x: 0,
            autoAlpha: 1,
            duration: .5
        }, "-=0.4").to("#button-scroll", {
            y: 0,
            autoAlpha: 1,
            duration: .5
        }, "-=0.3").to("#button-zoom", {
            y: 0,
            autoAlpha: 1,
            duration: .5,
            ease: "Elastic.easeOut"
        }, "-=0.4"),
        jb.start()
    }
    )),
    ob.addEventListener("click", (function() {
        jb.scrollTo(0),
        Qb.to(Tw.uniforms.uPadding.value, {
            x: 0,
            y: 0,
            z: 0,
            w: 0,
            duration: 1,
            ease: "power3.inOut"
        }).to(Tw.uniforms.iRadius, {
            value: "1.0",
            duration: .5,
            ease: "power3.inOut"
        }, "-=0.5").to("#section-logo h1", {
            y: 150,
            skewY: 5,
            autoAlpha: 0,
            duration: 1.5
        }, "-=2.5").to("#section-logo p", {
            x: 150,
            autoAlpha: 0,
            duration: 1
        }, "-=1").to("#button-zoom", {
            y: "120%",
            autoAlpha: 0,
            duration: .5,
            ease: "power3.inOut"
        }, "-=1.0"),
        document.getElementById("body").style.overflow = "hidden",
        document.getElementById("canvas-container").style.pointerEvents = "all",
        document.querySelector(".sectionContainer").style.display = "none",
        document.querySelector(".footerContainer").style.display = "none",
        document.getElementById("button-scroll").style.opacity = 0,
        document.getElementById("btn-continue-explore").style.display = "none",
        _b.enabled = !0,
        _b.enableRotate = !0,
        tw(),
        jb.stop(),
        Xi.to(_b.target, {
            x: -.1,
            y: 1.3,
            z: .7,
            duration: 2,
            ease: "power3.inOut"
        }),
        Xi.to(db.position, {
            x: -4.6,
            y: 2.1,
            z: 11.8,
            duration: 2,
            ease: "power3.inOut",
            onComplete: Uw
        }, "-=2")
    }
    ));
    const Tw = new qc({
        extensions: {
            derivatives: 1,
            fragDepth: 1,
            drawBuffers: 1,
            shaderTextureLOD: 1
        },
        wireframe: 1,
        transparent: !0,
        depthTest: 1,
        depthWrite: 0,
        lights: 1,
        uniforms: {
            iResolution: {
                value: new Ua
            },
            uPadding: {
                value: new Na(0,0,0,0)
            },
            iRadius: {
                value: 0
            }
        },
        vertexShader: "\n            #define GLSLIFY 1\n            varying vec2 vUv;\n    \n            void main()\n            {\n                gl_Position = vec4(position, 1.0);\n                vUv = uv;\n    \n            }\n        ",
        fragmentShader: "\n            #define GLSLIFY 1\n        \n            uniform vec2 iResolution;\n            uniform vec4 uPadding;\n            uniform float uDisplacement;\n            uniform float iRadius;\n            varying vec2 vUv;\n\n            float udRoundBox( vec2 p, vec2 b, float r )\n            {\n                return length(max(abs(p)-b+r,0.0))-r;\n            }\n            \n            void main()\n            {           \n                vec2 displacedUv = vUv;\n    \n                // Draw rounded box\n                vec2 borderUv = displacedUv * iResolution;\n                \n                borderUv -= iResolution * 0.5;\n                \n                borderUv.x -= (uPadding.w - uPadding.y) * 0.5;\n                borderUv.y -= (uPadding.z - uPadding.x) * 0.5;\n    \n                float strength = udRoundBox(\n                    borderUv,\n                            vec2(\n                                (iResolution.x - uPadding.y - uPadding.w) * 0.5,\n                                (iResolution.y - uPadding.x - uPadding.z) * 0.5),\n                    iRadius);\n                    \n                gl_FragColor = vec4(1.0, 1.0, 1.0, strength);\n    \n            }\n    \n        "
    })
      , Ew = new ch(2,2)
      , Aw = new Hc(Ew,Tw);
    fb.add(Aw);
    const Rw = [{
        position: new Ua(2,2,-12.6),
        element: document.querySelector(".point-0")
    }, {
        position: new Ua(-2,4,-2.2),
        element: document.querySelector(".point-1")
    }, {
        position: new Ua(-2.5,.7,6.2),
        element: document.querySelector(".point-2")
    }, {
        position: new Ua(0,5,-3),
        element: document.querySelector(".point-3")
    }]
      , Lw = {
        x: 0,
        y: 0
    };
    let Cw = !1
      , Pw = !1
      , Dw = !1;
    function Iw() {
        _b.enableRotate = !1,
        _b.enableZoom = !1,
        Pw = !0,
        Bw()
    }
    var Ow = new Ua(-20,.8,-20)
      , kw = new Ua(10,10,10)
      , Nw = new Ua;
    function zw() {
        _b.enableDamping = !1,
        _b.dampingFactor = .08,
        _b.minDistance = 0,
        _b.maxDistance = 200,
        _b.maxPolarAngle = Math.PI / 1.9,
        _b.minPolarAngle = 0,
        _b.minAzimuthAngle = 1 / 0,
        _b.maxAzimuthAngle = 1 / 0
    }
    function Bw() {
        _b.enableDamping = !0,
        _b.dampingFactor = .08,
        Cw ? (_b.minDistance = 5,
        _b.maxDistance = 16,
        _b.minPolarAngle = Ta.degToRad(20),
        _b.maxPolarAngle = Math.PI / 2.5,
        _b.minAzimuthAngle = 1 / 0,
        _b.maxAzimuthAngle = 1 / 0) : Pw ? (_b.minDistance = 5,
        _b.maxDistance = 20,
        _b.maxPolarAngle = Math.PI,
        _b.minPolarAngle = 0) : Dw ? (_b.minDistance = 6,
        _b.maxDistance = 12,
        _b.minPolarAngle = 0,
        _b.maxPolarAngle = Math.PI / 1.9,
        _b.minAzimuthAngle = 1 / 0,
        _b.maxAzimuthAngle = 1 / 0) : (_b.minDistance = 6,
        _b.maxDistance = 12,
        _b.minPolarAngle = 0,
        _b.maxPolarAngle = Math.PI / 1.9,
        _b.minAzimuthAngle = Ta.degToRad(-55),
        _b.maxAzimuthAngle = Ta.degToRad(55))
    }
    _b.addEventListener("change", (function() {
        Nw.copy(_b.target),
        _b.target.clamp(Ow, kw),
        Nw.sub(_b.target),
        db.position.sub(Nw)
    }
    )),
    zw();
    const Fw = Xi.timeline();
    function Uw() {
        _b.enabled = !0,
        sb.style.visibility = "visible",
        sb.style.display = "flex",
        sb.style.opacity = 1,
        document.getElementById("div-points").style.visibility = "visible",
        Bw()
    }
    let Hw = {
        value: 0
    };
    Hw.target = Hw.value,
    Hw.easing = .05;
    let Vw = 0
      , Gw = [0];
    Fb && (_b.enableZoom = !0,
    _b.enableRotate = !0,
    _b.autoRotate = !1,
    db.fov = 65,
    db.updateProjectionMatrix(),
    mb.setPixelRatio(.8)),
    function t() {
        if (rw | document.hidden && Gb) {
            if (_b.update(),
            Zb || mb.render(fb, db),
            Sw && !Fb && Sw.material.update(),
            null != document.getElementById("div-points") && "visible" == document.getElementById("div-points").style.visibility)
                for (const t of Rw) {
                    const e = t.position.clone();
                    e.project(db),
                    vb.setFromCamera(e, db);
                    const n = vb.intersectObjects(fb.children, !0);
                    0 === n.length ? t.element.classList.add("visible") : (n[0].distance,
                    t.position.distanceTo(db.position));
                    const i = e.x * nw * .5
                      , r = -e.y * iw * .5;
                    t.element.style.transform = `translateX(${i}px) translateY(${r}px)`
                }
            const t = Vb.getElapsedTime()
              , e = t - Vw;
            if (Vw = t,
            Wb) {
                const t = -Lw.y;
                if (aw.position.y += 1.8 * (t - aw.position.y) * e,
                !Pw) {
                    const t = 4 * Lw.x;
                    aw.position.x += 1.8 * (t - aw.position.x) * e
                }
            }
            xb && (Pb.update(2 * e),
            xb.position.z > 60 && (xb.position.z = -90,
            xb.position.x = -40),
            xb.position.z += .1,
            xb.position.x += .1),
            mw.rotation.y += 3e-4,
            Vb.getElapsedTime(),
            Tw.uniforms.iResolution.value.set(Jb.clientWidth, Jb.clientHeight, 1),
            1 == Hb && function() {
                if (Nb.getElapsedTime() < 3) {
                    if (!Db)
                        return Db = Date.now(),
                        void (Ob = 0);
                    Ib = (Date.now() - Db) / 1e3,
                    Db = Date.now(),
                    Ob = 1 / Ib,
                    Gw.push(Math.round(Ob))
                } else {
                    function t(t, e) {
                        return t + e
                    }
                    Gw.reduce(t, 0) / Gw.length < 50 && (Zb = !1,
                    mb.setPixelRatio(.8),
                    mb.antialias = !1)
                }
            }()
        }
        Xb && pb && pb.update(),
        requestAnimationFrame(t)
    }()
}
)();
